/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <vector>

namespace OT
{
    /**
    * \class Enumerator Enumerator.h
    * A utility class for enumerating combinations on sets of elements.
    */
    class Enumerator
    {
    public:

        /**
        * The Enumerator class has no constructor since all its methods are static
        * and meant to be used without an Enumerator object.
        */
        Enumerator() = delete;

        /**
        * Computes the Cartesian product of different sets of elements. This method
        * uses a recursive algorithm, and is compatible with all STL containers
        * relevant for OpenTesting.
        * 
        * If the vector passed in argument is empty or contains any empty set
        * inside, then this method will return an empty vector, as per the
        * definition of a Cartesian product.
        * @param[in] sets The sets of elements, stored in a vector. If empty or if
        *   contains an empty set inside, the method will return an empty vector.
        */
        template<typename ContainerType>
        static std::vector<ContainerType> cartesianProduct(const std::vector<ContainerType>& sets);

    private:

        /**
        * The recursive method called by cartesianProduct() to compute the Cartesian
        * product of the given sets.
        * @param[in] sets The sets of elements, stored in a vector.
        */
        template<typename ContainerType>
        static std::vector<ContainerType> cartesianProductRecursive(const std::vector<ContainerType>& sets);
    };

    template<typename ContainerType>
    inline std::vector<ContainerType> Enumerator::cartesianProduct(const std::vector<ContainerType>& sets)
    {
        /* If the vector of sets is empty, we return an empty set. */
        if (sets.empty())
            return {};

        /* If at least one of the sets is empty, we return an empty set. */
        for (const auto& set : sets)
            if (set.empty())
                return {};

        /* Otherwise, we launch the recursion */
        return cartesianProductRecursive(sets);
    }

    template<typename ContainerType>
    inline std::vector<ContainerType> Enumerator::cartesianProductRecursive(const std::vector<ContainerType>& sets)
    {
        /*
        * If the vector of sets is empty, we return a singleton containing the empty
        * set only for the recursion to work.
        */
        if (sets.empty())
            return { ContainerType() };

        /* We initialize a result vector */
        std::vector<ContainerType> result;

        /* We grab the head and tail of the sets... */
        const ContainerType& head = *sets.cbegin();
        std::vector<ContainerType> tail = sets;
        tail.erase(tail.begin());

        /* ... And we recursively call the cartesianProduct method */
        std::vector<ContainerType> tailProduct = cartesianProductRecursive(tail);
        for (const auto& h : head)
            for (const auto& tailElement : tailProduct)
            {
                ContainerType element;
                element.insert(element.end(), h);
                for (const auto& x : tailElement)
                    element.insert(element.end(), x);
                result.insert(result.end(), std::move(element));
            }

        /* Finally, we return the result */
        return result;
    }
}