/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <vector>
#include <algorithm>
#include <iterator>

namespace OT
{
    /**
    * \class Enumerator Enumerator.h
    * A utility class for enumerating combinations on sets of elements.
    */
    class Enumerator
    {
    public:

        /**
        * The Enumerator class has no constructor since all its methods are static
        * and meant to be used without an Enumerator object.
        */
        Enumerator() = delete;

        /**
        * Computes the Cartesian product of different sets of elements. This method
        * is compatible with all STL containers relevant for OpenTesting.
        * 
        * If the vector passed in argument is empty or contains any empty set
        * inside, then this method will return an empty vector, as per the
        * definition of a Cartesian product.
        * @param[in] sets The sets of elements, stored in a vector. If empty or if
        *   it contains an empty set inside, the method will return an empty vector.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> cartesianProduct(const std::vector<InputContainerType>& sets);

        /**
        * Enumerates all possibles choices of a fixed number of objects from the
        * given STL container. Choices are made without replacement, so the same
        * object cannot be selected twice, except if it is present in multiple
        * copies in the input container.
        * 
        * If K denotes the number of objects to choose and N the number of objects
        * available in the input container, then this method will return a vector
        * containing exactly N choose K elements, provided K is not greater than N.
        * If this is not the case, then this method will return an empty vector.
        * 
        * Note that a choice represents a set of objects in which the order does not
        * matter (objects can be selected in any order). By convention, this method
        * will return objects in the order in which they appear in the input
        * container.
        * @param[in] objects The objects to choose from, stored in an STL container.
        *   If empty or if it contains fewer elements than the number of objects to
        *   choose, the method will return an empty vector.
        * @param[in] numObjectsToChoose The number of objects to choose from the
        *   container. It must be less than or equal to the number of objects in the
        *   container.
        */
        template<typename InputContainerType, typename OutputContainerType = InputContainerType>
        static std::vector<OutputContainerType> choices(const InputContainerType& objects, size_t numObjectsToChoose);

        /**
        * Enumerates all possibles permutations of the objects passed in argument.
        * 
        * All objects are treated as individual instances and are permutated based
        * on their position in the input container and not on their value.
        * Therefore, if multiple copies of the same object appear in the container,
        * then the output will contain duplicated permutations. For example, the
        * vector {"A", "A"} is treated as two independent, individual strings "A"
        * and will generate two permutations equal to {"A", "A"}. Although they
        * appear identical, these permutations are not the same in the eyes of the
        * algorithm: one left the original vector intact while the other permutated
        * the two As. If unique permutations are needed, one can still use the
        * vector returned by this method and simply build a set container from it.
        * 
        * If N denotes the number of objects passed in argument, then this method
        * will return a vector containing exactly N! elements.
        * @param[in] objects The objects to permutate, stored in an STL container.
        */
        template<typename ContainerType>
        static std::vector<ContainerType> permutations(const ContainerType& objects);
    };

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::cartesianProduct(const std::vector<InputContainerType>& sets)
    {
        /* If the vector of sets is empty, we return an empty set. */
        if (sets.empty())
            return {};

        /* If at least one of the sets is empty, we return an empty set. */
        for (const auto& set : sets)
            if (set.empty())
                return {};

        /*
        * Otherwise, we launch the computation, using the following algorithm:
        * assimilating each element in a set with its index in the set, we enumerate
        * all possible combinations of elements by enumerating all possible
        * combinations of indices from each set, which we obtain by incrementing a
        * vector of indices just like counting with a carry in arithmetic.
        * 
        * For example, to compute the Cartesian product of {A0, A1} and {B0, B1}, we
        * start with a vector of indices equal to [0, 0] representing (A0, B0) and
        * successively increment the vector of indices to obtain [0, 1], [1, 0], and
        * [1, 1] respectively representing (A0, B1), (A1, B0), and (A1, B1).
        */

        /*
        * We initialize a result vector, a vector of indices, and a vector
        * containing the size of each set to detect when to move the carry over.
        */

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /* We initialize the vector of indices to increment */
        std::vector<size_t> indices(sets.size(), 0);

        /*
        * We initialize a vector containing the size of each set, which will dictate
        * when to move the carry over.
        */
        std::vector<size_t> sizes(sets.size());
        std::transform(sets.cbegin(), sets.cend(), sizes.begin(), [](const InputContainerType& set) { return set.size(); });

        /* Then we start the algorithm */
        do
        {
            /* We add the current combination */
            OutputContainerType combination;
            std::transform(indices.cbegin(), indices.cend(), sets.cbegin(), std::inserter(combination, combination.end()), [](const size_t& index, const InputContainerType& set) { return *std::next(set.cbegin(), index); });
            result.insert(result.end(), std::move(combination));

            /* And we update the indices of the next combination */
            (*indices.rbegin())++;
            for (int i = static_cast<int>(indices.size()) - 1; i >= 0; i--)

                /* Is there a carry to move over? */
                if (indices[i] >= sizes[i])
                {
                    indices[i] = 0;
                    if (i > 0)
                        indices[i - 1]++;
                }
        } while (std::any_of(indices.cbegin(), indices.cend(), [](size_t i) { return i != 0; }));

        /* Finally, we return the result */
        return result;
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::choices(const InputContainerType& objects, size_t numObjectsToChoose)
    {
        /*
        * If there are not enough objects to choose from, we return an empty vector.
        */
        if (numObjectsToChoose > objects.size())
            return {};

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /*
        * We introduce a selection mask that determines whether an object should be
        * chosen or not. The enumeration of all possible choices then boils down to
        * the enumeration of all possible permutations of the selection mask.
        */
        std::vector<bool> selectionMask(numObjectsToChoose, true);
        selectionMask.resize(objects.size(), false);
        do
        {
            OutputContainerType choice;
            auto it = objects.cbegin();
            for (int i = 0; i < objects.size(); i++)
            {
                if (selectionMask[i])
                    choice.insert(choice.end(), *it);
                it++;
            }
            result.insert(result.end(), choice);
        } while (std::prev_permutation(selectionMask.begin(), selectionMask.end()));

        /* We return the result */
        return result;
    }

    template<typename ContainerType>
    inline std::vector<ContainerType> Enumerator::permutations(const ContainerType& objects)
    {
        /* We list all valid indices for the input container */
        std::vector<int> indices(objects.size());
        for (int i = 0; i < objects.size(); i++)
            indices[i] = i;

        /* We initialize a result vector */
        std::vector<ContainerType> result;

        /* And we permutate the objects based on their indices */
        do
        {
            ContainerType permutation;
            for (const auto& index : indices)
                permutation.insert(permutation.end(), *std::next(objects.cbegin(), index));
            result.insert(result.end(), permutation);
        } while (std::next_permutation(indices.begin(), indices.end()));

        /* We return the result */
        return result;
    }
}