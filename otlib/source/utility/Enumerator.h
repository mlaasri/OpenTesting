/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <vector>
#include <array>

namespace OT
{
    /**
    * \class Enumerator Enumerator.h
    * A utility class for enumerating combinations on sets of elements.
    */
    class Enumerator
    {
    public:

        /**
        * The Enumerator class has no constructor since all its methods are static
        * and meant to be used without an Enumerator object.
        */
        Enumerator() = delete;

        /**
        * Computes the Cartesian product of different sets of elements. This method
        * uses a recursive algorithm, and is compatible with all STL containers
        * relevant for OpenTesting.
        * 
        * If the vector passed in argument is empty or contains any empty set
        * inside, then this method will return an empty vector, as per the
        * definition of a Cartesian product.
        * @param[in] sets The sets of elements, stored in a vector. If empty or if
        *   it contains an empty set inside, the method will return an empty vector.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> cartesianProduct(const std::vector<InputContainerType>& sets);

        /**
        * Enumerates all possibles choices of a fixed number of objects from the
        * given STL container. Choices are made without replacement, so the same
        * object cannot be selected twice, except if it is present in multiple
        * copies in the input container. The number of objects to select is called
        * the "selection size".
        * 
        * If K denotes the selection size and N the size of the input container,
        * then this method will return a vector containing N choose K elements,
        * provided N is positive and the input container holds at least K elements.
        * If this is not the case, then this method will return an empty vector.
        * 
        * Note that a choice represents a set of objects in which the order does not
        * matter (objects can be selected in any order). By convention, this method
        * will return objects in the order in which they appear in the input
        * container.
        * 
        * This method uses a recursive algorithm, and is compatible with all STL
        * containers relevant for OpenTesting.
        * @param[in] objects The objects to choose from, stored in an STL container.
        *   If empty or if it contains fewer elements than the selection size, the
        *   method will return an empty vector.
        * @param[in] selectionSize The selection size. It must be a positive
        *   integer.
        */
        template<typename InputContainerType, typename OutputContainerType = InputContainerType>
        static std::vector<OutputContainerType> choices(const InputContainerType& objects, size_t selectionSize);

    private:

        /**
        * The recursive method called by cartesianProduct() to compute the Cartesian
        * product of the given sets.
        * @param[in] sets The sets of elements, stored in a vector.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> cartesianProductRecursive(const std::vector<InputContainerType>& sets);

        /**
        * The recursive method called by choices() to enumerate all possible choices
        * of a fixed number of objects from the given STL container.
        * @param[in] objects The objects to choose from, stored in an STL container.
        *   It must contain a number of elements of at least the selection size.
        * @param[in] selectionSize The selection size. It must be a positive
        *   integer.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> choicesRecursive(const InputContainerType& objects, size_t selectionSize);
    };

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::cartesianProduct(const std::vector<InputContainerType>& sets)
    {
        /* If the vector of sets is empty, we return an empty set. */
        if (sets.empty())
            return {};

        /* If at least one of the sets is empty, we return an empty set. */
        for (const auto& set : sets)
            if (set.empty())
                return {};

        /* Otherwise, we launch the recursion */
        return cartesianProductRecursive<InputContainerType, OutputContainerType>(sets);
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::cartesianProductRecursive(const std::vector<InputContainerType>& sets)
    {
        /*
        * If the vector of sets is empty, we return a singleton containing only
        * the empty set for the recursion to work.
        */
        if (sets.empty())
            return { OutputContainerType() };

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /* We grab the head and tail of the sets... */
        const InputContainerType& head = *sets.cbegin();
        std::vector<InputContainerType> tail = sets;
        tail.erase(tail.begin());

        /* ... And we recursively call the cartesianProduct method */
        std::vector<OutputContainerType> tailProduct = cartesianProductRecursive<InputContainerType, OutputContainerType>(tail);
        for (const auto& h : head)
            for (const auto& tailElement : tailProduct)
            {
                OutputContainerType element;
                element.insert(element.end(), h);
                for (const auto& x : tailElement)
                    element.insert(element.end(), x);
                result.insert(result.end(), std::move(element));
            }

        /* Finally, we return the result */
        return result;
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::choices(const InputContainerType& objects, size_t selectionSize)
    {
        /*
        * The selection size must be positive and the vector of objects must contain
        * at least this number of objects. Otherwise, we return an empty vector.
        */
        if (selectionSize == 0 || objects.size() < selectionSize)
            return {};

        /* Otherwise, we launch the recursion */
        return choicesRecursive<InputContainerType, OutputContainerType>(objects, selectionSize);
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::choicesRecursive(const InputContainerType& objects, size_t selectionSize)
    {
        /*
        * If the selection size is zero, we return a singleton containing only an
        * empty container for the recursion to work.
        */
        if (selectionSize == 0)
            return { OutputContainerType() };

        /*
        * If the container of objects is empty, we return an empty vector to stop
        * the recursion.
        */
        if (objects.empty())
            return {};

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /* We grab the tail of the vector of objects... */
        const auto& head = *objects.cbegin();
        InputContainerType tail = objects;
        tail.erase(tail.begin());

        /*
        * ... And we recursively call the choices() method upon choosing whether or
        * not to include the head element. Either we include it:
        */
        auto headSelected = choicesRecursive<InputContainerType, OutputContainerType>(tail, selectionSize - 1);
        for (const auto& subselection : headSelected)
        {
            OutputContainerType selection;
            selection.insert(selection.end(), head);
            for (const auto& choice : subselection)
                selection.insert(selection.end(), choice);
            result.insert(result.end(), selection);
        }

        /* ... Or we do not: */
        auto headNotSelected = choicesRecursive<InputContainerType, OutputContainerType>(tail, selectionSize);
        for (const auto& subselection : headNotSelected)
            result.insert(result.end(), subselection);

        /* Finally, we return the result */
        return result;
    }
}