/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#include <stdexcept>

#include "Reader.h"
#include "Serialized.h"
#include "Serializable.h"
#include "../../core/engine/Bucket.h"

OT::Reader::Reader(const std::string& source)
{
    /* We create an empty Serialized object */
    m_serialized = std::make_unique<Serialized>();

    /* We parse the source and internally save the serialized data */
    m_serialized->data = nlohmann::json::parse(source);
}

OT::Reader OT::Reader::createReaderFor(const std::string& key) const
{
    /* We extract the subtree of serialized data to create a Reader for */
    std::unique_ptr<Serialized> serialized = std::make_unique<Serialized>();
    serialized->data = m_serialized->data[key];

    /* And we create and return a Reader for it */
    return Reader(std::move(serialized));
}

std::vector<OT::Reader> OT::Reader::createReadersFor(const std::string& key) const
{
    /* We create a Reader for each data element in the internal array */
    std::vector<Reader> readers;
    for (const auto& data : m_serialized->data[key])
    {
        /* We extract the subtree of serialized data to create a Reader for */
        std::unique_ptr<Serialized> serialized = std::make_unique<Serialized>();
        serialized->data = data;

        /* And we create and append a Reader for it */
        readers.push_back(std::move(Reader(std::move(serialized))));
    }

    /* Finally, we return all the readers */
    return readers;
}

OT::Reader::Reader(std::unique_ptr<Serialized> serialized) :

    /* The Reader takes ownership of the Serialized object */
    m_serialized(std::move(serialized))
{}

void OT::Reader::read(const std::string& key, size_t& value) const
{
    value = m_serialized->data[key].get<size_t>();
}

void OT::Reader::read(const std::string& key, std::string& value) const
{
    value = m_serialized->data[key].get<std::string>();
}

void OT::Reader::read(const std::string& key, std::vector<std::string>& values) const
{
    values = m_serialized->data[key].get<std::vector<std::string>>();
}

void OT::Reader::read(const std::string& key, Bucket<std::string>& bucket) const
{
    /*
    * We create an intermediate Reader to read the data at the given key inside the
    * internal Serialized object.
    */
    Reader subreader = createReaderFor(key);

    /* We use the intermediate Reader to read the selection size */
    size_t selectionSize;
    subreader.read("selectionSize", selectionSize);

    /* And we do the same for the strings */
    std::vector<std::string> strings;
    subreader.read("objects", strings);

    /*
    * Finally, we replace the bucket's content with what we read from
    * deserialization.
    */
    bucket.setSelectionSize(selectionSize);
    bucket.clear();
    for (const auto& s : strings)
        bucket.append(s);
}

void OT::Reader::read(const std::string& key, Serializable& serializable) const
{
    /*
    * We read the data from the internal Serialized object and deserialize it into
    * the object with an intermediate Reader.
    */
    Reader subreader = createReaderFor(key);
    serializable.deserialize(subreader);
}
