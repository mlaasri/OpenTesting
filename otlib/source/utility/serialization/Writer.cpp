/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#include "Writer.h"
#include "../../dependencies/nlohmann-json/single_include/nlohmann/json.hpp"
#include "Serializable.h"
#include "../../core/engine/Bucket.h"

struct OT::Serialized
{
    /**
    * A JSON object from the [JSON for Modern C++ library]
    * (https://github.com/nlohmann/json) that serves as a root for the Serialized
    * object's tree-like structure.
    */
    nlohmann::json data;
};

OT::Writer::Writer()
{
    m_serialized = std::make_unique<Serialized>();
}

OT::Writer::~Writer()
{}

void OT::Writer::write(const std::string& key, size_t value)
{
    m_serialized->data[key] = value;
}

void OT::Writer::write(const std::string& key, const std::string& value)
{
    m_serialized->data[key] = value;
}

void OT::Writer::write(const std::string& key, const std::vector<std::string>& values)
{
    m_serialized->data[key] = values;
}

void OT::Writer::write(const std::string& key, const Serializable& serializable)
{
    /*
    * We serialize the object with an intermediate Writer and write the result into
    * the internal Serialized object.
    */
    Writer subwriter;
    serializable.serialize(subwriter);
    m_serialized->data[key] = subwriter.getSerialized()->data;
}

void OT::Writer::write(const std::string& key, const Bucket<std::string>& bucket)
{
    /*
    * We serialize the bucket with an intermediate Writer and write the result into
    * the internal Serialized object.
    */
    Writer subwriter;
    subwriter.write("selectionSize", bucket.getSelectionSize());
    subwriter.write("objects", bucket.getObjects());
    m_serialized->data[key] = subwriter.getSerialized()->data;
}

std::string OT::Writer::toString(bool compact) const
{
    /*
    * We simply call the dump() method on the JSON object with either no indent nor
    * new lines (-1) or with pretty-printing with a 4-space indent (4). See the
    * documentation of dump() at https://json.nlohmann.me/api/basic_json/dump/ for
    * more information.
    */
    return m_serialized->data.dump(compact ? -1 : 4);
}

const std::unique_ptr<OT::Serialized>& OT::Writer::getSerialized() const
{
    return m_serialized;
}

void OT::Writer::write(const std::string& key, const std::vector<const Serializable*>& serializables)
{
    /* We initialize an empty JSON array */
    m_serialized->data[key] = nlohmann::json::array();

    /* And then we complete it with the serialization of each object */
    for (const auto& serializable : serializables)
    {
        /*
        * We serialize the object with an intermediate Writer and append the result
        * at the end of the array.
        */
        Writer subwriter;
        serializable->serialize(subwriter);
        m_serialized->data[key].push_back(subwriter.getSerialized()->data);
    }
}