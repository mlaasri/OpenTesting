/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#include <memory>
#include <stdexcept>
#include <type_traits>

#include "Instantiator.h"
#include "../../core/questiongenerators/units/BlankUnit.h"
#include "../../core/questiongenerators/units/ExplanationCompletionUnit.h"
#include "../../core/questiongenerators/units/OptionSelectionUnit.h"
#include "../../core/questiongenerators/units/PromptInitializationUnit.h"
#include "../../core/questiongenerators/units/TokenReplacementUnit.h"
#include "../../core/engine/WrapperUnit.h"

/*
* We define two utility macros for expanding variadic arguments. The sole purpose of
* these macros is to solve the divergence of MSVC's preprocessor from the standard
* on how __VA_ARGS__ is handled (MSVC replaces it as one single token). We use two
* macros instead of just one because we need a sequence of two expansions within the
* same scope.
*/

#define OPENTESTING_INSTANTIATOR_EXPAND(X) X
#define OPENTESTING_INSTANTIATOR_EXPAND_2(X) X

/* We define an X-macro over all supported Unit types */
#define OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP(DO, ...) \
    DO(__VA_ARGS__, BlankUnit) \
    DO(__VA_ARGS__, ExplanationCompletionUnit) \
    DO(__VA_ARGS__, OptionSelectionUnit) \
    DO(__VA_ARGS__, PromptInitializationUnit) \
    DO(__VA_ARGS__, TokenReplacementUnit)

/*
* We define utility macros for computing the cross-product of the list above with
* itself so we can list all possible pairs of object types.
*/

#define OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP_1() OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP
#define OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP_2(...) OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP_1 OPENTESTING_INSTANTIATOR_EXPAND(())(__VA_ARGS__)

/*
* We define the core macro of the instantiateUnit() method. This macro tests if a
* candidate type matches a supported type and creates a new instance if so.
*/
#define OPENTESTING_INSTANTIATOR_TRY_INSTANTIATE_UNIT(candidateType, supportedType) if (candidateType == #supportedType) return std::make_unique<supportedType>();

/*
* We define the core macro of the instantiateWrapperUnit() method. This macro
* compares the candidate base and derived object types desired for the WrapperUnit
* and creates a new instance for them if they are compatible. Note that this macro
* is wrapped within another macro to handle MSVC's argument expansion.
*/
#define OPENTESTING_INSTANTIATOR_TRY_WRAP(candidateBaseUnitType, candidateDerivedObjectType, supportedUnitType1, supportedUnitType2) \
    if (candidateBaseUnitType == #supportedUnitType1 && candidateDerivedObjectType == typeid(supportedUnitType2::ObjectTypeValue))        \
        return std::make_unique<std::conditional<                                                                                    \
            std::is_base_of<supportedUnitType1::ObjectTypeValue, supportedUnitType2::ObjectTypeValue>::value,                                  \
            WrapperUnit<supportedUnitType1::ObjectTypeValue, supportedUnitType2::ObjectTypeValue>,                                             \
            WrapperUnitExceptionThrower>::type>();

/*
* We define a macro that wraps OPENTESTING_INSTANTIATOR_TRY_WRAP and is safe to use
* by the instantiateWrapperUnit() method with MSVC's argument expansion rules.
*/
#define OPENTESTING_INSTANTIATOR_TRY_INSTANTIATE_WRAPPERUNIT(...) OPENTESTING_INSTANTIATOR_TRY_WRAP OPENTESTING_INSTANTIATOR_EXPAND_2((__VA_ARGS__))

OT::Instantiator::WrapperUnitExceptionThrower::WrapperUnitExceptionThrower() :
    Serializable()
{
    throw std::invalid_argument("Incompatible object types: Instantiator cannot instantiate a WrapperUnit because its derived object type does not actually derive from its base object type.");
}

std::unique_ptr<OT::Serializable> OT::Instantiator::instantiateUnit(const std::string& typeName)
{
    /* We try every supported unit type and see if one matches the argument */
    OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP(OPENTESTING_INSTANTIATOR_TRY_INSTANTIATE_UNIT, typeName);

    /* If no supported type matches the argument, we throw an exception. */
    throw std::invalid_argument("Unsupported type: Instantiator cannot instantiate an object of type '" + typeName + "'.");
}

std::unique_ptr<OT::Serializable> OT::Instantiator::instantiateWrapperUnit(const std::string& internalUnitType, const std::type_info& derivedObjectTypeInfo)
{
    /*
    * We try every combinations of base and derived object types and see if one
    * matches the arguments.
    * 
    * Note that we use the OPENTESTING_INSTANTIATOR_EXPAND macro twice when only one
    * instance would have been sufficient. The only purpose of this redundancy is to
    * facilitate macro expansion in IDEs where an extra expansion might be needed to
    * fully display the final result. This redundancy has no extra cost since the
    * preprocessor will eventually generate the same code.
    */
    OPENTESTING_INSTANTIATOR_EXPAND(OPENTESTING_INSTANTIATOR_EXPAND(OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP(OPENTESTING_INSTANTIATOR_UNIT_TYPE_LOOP_2, OPENTESTING_INSTANTIATOR_TRY_INSTANTIATE_WRAPPERUNIT, internalUnitType, derivedObjectTypeInfo)));

    /* If no combination matches the arguments, we throw an exception. */
    throw std::invalid_argument("Unsupported type: Instantiator cannot instantiate a WrapperUnit with an internal unit of type '" + internalUnitType + "' and the given object type, named '" + std::string(derivedObjectTypeInfo.name()) +"'. At least one of the two types is not supported.");
}
