/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <string>
#include <vector>

#include "../TypeTraits.h"

namespace OT
{
    /* Forward declaration of the Serialized struct */
    struct Serialized;

    /* Forward declaration of the Bucket class */
    template<class ObjectType>
    class Bucket;

    /* Forward declaration of the Serializable class */
    class Serializable;

    /**
    * \class Reader Reader.h
    * A Reader is an object that deserializes data from an internal Serialized
    * object into variables of different types.
    * 
    * A Reader can read anything that a Writer can write. More precisely, it can
    * read key-value pairs where keys are strings that uniquely identify their
    * associated value and values are objects of one of the following supported
    * types:
    * - a 'basic type', which is any default-constructible type used for the second
    *   argument of any of the protected methods named read() (e.g. unsigned
    *   integers, strings, default-constructible Serializable objects);
    * - a unique pointer to a basic type;
    * - a vector of objects where each object is either a basic type or a unique
    *   pointer to a basic type.
    *
    * Basic types and unique pointers to basic types are easy to deserialize with
    * the two templated read() methods. One method covers non-pointer basic types,
    * i.e. bare basic types, while the other covers unique pointers to basic types.
    * 
    * Serializable objects can be deserialized in two ways: if a Serializable object
    * is default-constructible, then it qualifies as a basic type, so it can be
    * deserialized with the aforementioned templated read() methods. However, if it
    * is not default-constructible, then the object must be created beforehand and
    * the Reader can then be simply passed on to its Serializable::deserialize()
    * method.
    * 
    * Vectors of Serializable objects can be deserialized by creating a vector of
    * readers where each Reader can read its own object. This can be achieved with
    * the createReadersFor() method.
    * 
    * If one needs more control over deserialization, the createReaderFor() method
    * can help. This method creates a Reader that focuses on a specific key inside
    * the data of the current Reader. As such, it can be leveraged to manually and
    * recursively extract serialized data down the tree.
    */
    class Reader
    {
    public:

        /**
        * Creates a Serialized object from the given string representation and a
        * Reader for it.
        * @param[in] source The string representation of the Serialized object to
        *   read from. The string should be generated by the Writer::toString()
        *   method of a Writer.
        */
        Reader(const std::string& source);

        /**
        * Creates a Reader for the data associated with the given key.
        *
        * This method can be leveraged to manually extract serialized data down the
        * tree in a recursive fashion.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object.
        */
        Reader createReaderFor(const std::string& key) const;

        /**
        * Creates a Reader for each element in the vector of objects associated with
        * the given key. Each Reader can then be used individually to read each
        * object in the vector.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must be associated with a vector of objects, i.e. a Writer must
        *   have written a vector of objects associated with this key.
        */
        std::vector<Reader> createReadersFor(const std::string& key) const;

        /**
        * Returns the value associated with the given key.
        * 
        * This method is invoked when the template type is a bare basic type and not
        * a unique pointer to a basic type. See its counterpart with the same name
        * for unique pointers to basic types.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        */
        template<class ValueType>
        typename std::enable_if<!TypeTraits::isUniquePtr<ValueType>::value, ValueType>::type read(const std::string& key) const;

        /**
        * Returns a unique pointer to the value associated with the given key.
        *
        * This method is invoked when the template type is a pointer to a basic type
        * and not a bare basic type. See its counterpart with the same name for bare
        * basic types.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        */
        template<class UniquePtrType>
        typename std::enable_if<TypeTraits::isUniquePtr<UniquePtrType>::value, UniquePtrType>::type read(const std::string& key) const;

    protected:

        /**
        * Creates a Reader for the given Serialized object.
        *
        * Note that the Reader takes ownership of the Serialized object, i.e. the
        * pointer given in argument will be moved to the Reader's internal storage,
        * so it should not be accessed anymore after the Reader is created.
        * @param[in] serialized A pointer to the Serialized object to read from. The
        *   pointer will be moved inside the Reader, so it should not be accessed
        *   anymore after this constructor is called.
        */
        Reader(std::unique_ptr<Serialized> serialized);

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given unsigned integer.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] value The unsigned integer to write into.
        */
        void read(const std::string& key, size_t& value) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given string.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] value The string to write into.
        */
        void read(const std::string& key, std::string& value) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given vector of strings.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] values The vector of strings to write into. If the vector
        *   already contains some strings, they will be erased and replaced with the
        *   new strings read from deserialization.
        */
        void read(const std::string& key, std::vector<std::string>& values) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given Bucket of strings.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] bucket The Bucket of strings to write into. If the bucket
        *   already contains some strings, they will be erased and replaced with the
        *   new strings read from deserialization. The bucket's selection size will
        *   also be overriden with the new value obtained from deserialization.
        */
        void read(const std::string& key, Bucket<std::string>& bucket) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given Serializable object.
        * The Reader deserializes the data into the object by calling its
        * Serializable::deserialize() method and passing itself as the reader
        * argument.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] serializable The Serializable object to write into.
        */
        void read(const std::string& key, Serializable& serializable) const;

    private:

        /**
        * The internal Serialized object. Since it is not modified by Reader
        * objects, there is no need for exclusive ownership, so it is stored as a
        * shared pointer which Reader objects can reuse safely.
        */
        std::shared_ptr<const Serialized> m_serialized;
    };

    template<class ValueType>
    inline typename std::enable_if<!TypeTraits::isUniquePtr<ValueType>::value, ValueType>::type Reader::read(const std::string& key) const
    {
        /* We initialize the return value to a default value */
        ValueType value;

        /* We deserialize data into it */
        read(key, value);

        /* And we return the result */
        return value;
    }

    template<class UniquePtrType>
    inline typename std::enable_if<TypeTraits::isUniquePtr<UniquePtrType>::value, UniquePtrType>::type Reader::read(const std::string& key) const
    {
        /* We initialize the return value to a unique pointer to a default value */
        std::unique_ptr<std::pointer_traits<UniquePtrType>::element_type> value = std::make_unique<std::pointer_traits<UniquePtrType>::element_type>();

        /* We deserialize data into it */
        read(key, *value);

        /* And we return the result */
        return value;
    }
}