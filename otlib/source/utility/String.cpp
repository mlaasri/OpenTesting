/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#include <sstream>
#include <algorithm>

#include "String.h"

std::vector<std::string> OT::String::split(const std::string& string, char delimiter)
{
    std::istringstream stringAsStream(string);

    /* We prepare the result vector... */
    std::vector<std::string> result;

    /*
    * ... And we fill it with the pieces of the initial string. Note that if the
    * string does not contain the delimiter character at all, the string will be
    * returned entirely in the vector.
    */
    std::string pieceOfString;

    while (std::getline(stringAsStream, pieceOfString, delimiter))
    {
        result.emplace_back(pieceOfString);
    }

    /* Finally, we return the result vector */
    return result;
}

std::string& OT::String::replaceAll(std::string& string, const std::string& from, const std::string& to)
{
    size_t position = 0;
    while (position < string.length())
    {
        size_t found = string.find(from, position);
        if (found != std::string::npos)
        {
            string.replace(found, from.length(), to);
            position = found + 1;
        }
        else
            position = string.length();
    }
    return string;
}

std::string& OT::String::removeAll(std::string& string, char character)
{
    string.erase(std::remove(string.begin(), string.end(), character), string.end());
    return string;
}

std::string& OT::String::trim(std::string& string)
{
    trimLeft(string);
    trimRight(string);
    return string;
}

std::string& OT::String::trimLeft(std::string& string)
{
    string.erase(0, string.find_first_not_of("\t\n\v\f\r "));
    return string;
}

std::string& OT::String::trimRight(std::string& string)
{
    string.erase(string.find_last_not_of("\t\n\v\f\r ") + 1);
    return string;
}

bool OT::String::startsWith(const std::string& string, const std::string& substring)
{
    return string.find(substring, 0) == 0;
}

bool OT::String::endsWith(const std::string& string, const std::string& substring)
{
    return string.rfind(substring) == string.length() - substring.length();
}

bool OT::String::contains(const std::string& string, const std::string& substring)
{
    return string.find(substring) != std::string::npos;
}

bool OT::String::contains(const std::string& string, char character)
{
    return string.find(character) != std::string::npos;
}
