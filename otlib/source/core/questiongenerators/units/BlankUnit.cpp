/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#include <memory>

#include "BlankUnit.h"
#include "../../../config/Symbols.h"
#include "../../../config/SpecialKeys.h"
#include "InactiveProcessor.h"

OT::BlankUnit::Processor::Processor(const TokenReplacementUnit::Processor& promptProcessor, const OptionSelectionUnit::Processor& optionProcessor) :
    m_promptProcessor(promptProcessor),
    m_optionProcessor(optionProcessor)
{}

void OT::BlankUnit::Processor::process(MultipleChoiceQuestion& question) const
{
    m_promptProcessor.process(question);
    m_optionProcessor.process(question);
}

OT::BlankUnit::BlankUnit()
{
    setBlankIdentifier("");
    hideBlankIdentifer();
    setBlankSymbol(OPENTESTING_DEFAULT_BLANK_SYMBOL);

    /*
    * We configure the TokenReplacementUnit so it does not modify explanation
    * fields.
    */
    m_tokenReplacementUnit.disableReplacementInExplanation();
}

OT::BlankUnit::BlankUnit(const std::string & identifier)
{
    setBlankIdentifier(identifier);
    showBlankIdentifer();
    setBlankSymbol(OPENTESTING_DEFAULT_BLANK_SYMBOL);

    /*
    * We configure the TokenReplacementUnit so it does not modify explanation
    * fields.
    */
    m_tokenReplacementUnit.disableReplacementInExplanation();
}

std::set<std::string> OT::BlankUnit::getKeys() const
{
    return m_optionSelectionUnit.getKeys();
}

size_t OT::BlankUnit::getNumKeys() const
{
    return m_optionSelectionUnit.getNumKeys();
}

std::unique_ptr<OT::Pipeline<OT::MultipleChoiceQuestion>::Processor> OT::BlankUnit::generate(const std::string& key) const
{
    /*
    * If we receive the null key, we generate an inactive processor so that
    * questions will be left untouched.
    */
    if (key == OPENTESTING_NULL_KEY)
        return std::make_unique<InactiveProcessor<OT::MultipleChoiceQuestion>>();

    /*
    * Otherwise, we generate processors from the internal units. The
    * TokenReplacementUnit contains one single replacement string so we can just
    * generate its processor by index.
    */
    auto promptProcessorPointer = std::shared_ptr<Pipeline<Question>::Processor>(m_tokenReplacementUnit.generateFromIndex(0));
    auto promptProcessor = *std::dynamic_pointer_cast<TokenReplacementUnit::Processor>(promptProcessorPointer);
    auto optionProcessorPointer = std::shared_ptr<Pipeline<MultipleChoiceQuestion>::Processor>(m_optionSelectionUnit.generate(key));
    auto optionProcessor = *std::dynamic_pointer_cast<OptionSelectionUnit::Processor>(optionProcessorPointer);

    /* Then we create and return the corresponding BlankUnit::Processor */
    return std::make_unique<Processor>(promptProcessor, optionProcessor);
}

const std::string& OT::BlankUnit::getBlankIdentifier() const
{
    return m_blankIdentifier;
}

bool OT::BlankUnit::shouldShowBlankIdentifier() const
{
    return m_showBlankIdentifier;
}

const std::string& OT::BlankUnit::getBlankSymbol() const
{
    return m_blankSymbol;
}

const OT::TokenReplacementUnit& OT::BlankUnit::getTokenReplacementUnit()
{
    return m_tokenReplacementUnit;
}

const OT::OptionSelectionUnit& OT::BlankUnit::getOptionSelectionUnit()
{
    return m_optionSelectionUnit;
}

void OT::BlankUnit::setBlankIdentifier(const std::string& identifier)
{
    m_blankIdentifier = identifier;
    updateUnits();
}

void OT::BlankUnit::showBlankIdentifer()
{
    m_showBlankIdentifier = true;
    updateUnits();
}

void OT::BlankUnit::hideBlankIdentifer()
{
    m_showBlankIdentifier = false;
    updateUnits();
}

void OT::BlankUnit::setBlankSymbol(const std::string& symbol)
{
    m_blankSymbol = symbol;
    updateUnits();
}

void OT::BlankUnit::addToken(const std::string& token)
{
    m_tokenReplacementUnit.addToken(token);
}

void OT::BlankUnit::removeToken(const std::string& token)
{
    m_tokenReplacementUnit.removeToken(token);
}

void OT::BlankUnit::clearTokens()
{
    m_tokenReplacementUnit.clearTokens();
}

void OT::BlankUnit::appendCorrectOption(const std::string& option)
{
    m_optionSelectionUnit.appendCorrectOption(option);
}

void OT::BlankUnit::appendIncorrectOption(const std::string& option)
{
    m_optionSelectionUnit.appendIncorrectOption(option);
}

void OT::BlankUnit::removeCorrectOption(const std::string& option)
{
    m_optionSelectionUnit.removeCorrectOption(option);
}

void OT::BlankUnit::removeIncorrectOption(const std::string& option)
{
    m_optionSelectionUnit.removeIncorrectOption(option);
}

void OT::BlankUnit::clearCorrectOptions()
{
    m_optionSelectionUnit.clearCorrectOptions();
}

void OT::BlankUnit::clearIncorrectOptions()
{
    m_optionSelectionUnit.clearIncorrectOptions();
}

void OT::BlankUnit::setCorrectSelectionSize(size_t selectionSize)
{
    m_optionSelectionUnit.setCorrectSelectionSize(selectionSize);
}

void OT::BlankUnit::setIncorrectSelectionSize(size_t selectionSize)
{
    m_optionSelectionUnit.setIncorrectSelectionSize(selectionSize);
}

void OT::BlankUnit::serialize(Writer& writer) const
{
    writer.write("type", std::string("BlankUnit"));
    writer.write("blankIdentifier", m_blankIdentifier);
    writer.write("showBlankIdentifier", m_showBlankIdentifier);
    writer.write("blankSymbol", m_blankSymbol);
    writer.write("tokenReplacementUnit", m_tokenReplacementUnit);
    writer.write("optionSelectionUnit", m_optionSelectionUnit);
}

void OT::BlankUnit::deserialize(const Reader& reader)
{
    /* We deserialize each member variable as it was serialized */
    m_blankIdentifier = reader.read<std::string>("blankIdentifier");
    m_showBlankIdentifier = reader.read<bool>("showBlankIdentifier");
    m_blankSymbol = reader.read<std::string>("blankSymbol");
    m_tokenReplacementUnit = reader.read<TokenReplacementUnit>("tokenReplacementUnit");
    m_optionSelectionUnit = reader.read<OptionSelectionUnit>("optionSelectionUnit");
}

void OT::BlankUnit::updateUnits()
{
    /* We update the replacement string of the TokenReplacementUnit */
    std::string replacementString = m_showBlankIdentifier ? "(" + m_blankIdentifier + ")" + m_blankSymbol : m_blankSymbol;
    m_tokenReplacementUnit.clearReplacementStrings();
    m_tokenReplacementUnit.addReplacementString(replacementString);

    /*
    * We update the MultipleChoiceQuestion::OptionGroup title for the
    * OptionSelectionUnit
    */
    std::string title = m_showBlankIdentifier ? "Blank (" + m_blankIdentifier + ")" : "Blank";
    m_optionSelectionUnit.setTitle(title);
}
