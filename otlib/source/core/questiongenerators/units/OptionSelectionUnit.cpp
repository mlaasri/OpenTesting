/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#include <string>
#include <algorithm>

#include "OptionSelectionUnit.h"
#include "../../../config/SpecialKeys.h"
#include "../../../utility/Enumerator.h"
#include "../../../config/Delimiters.h"
#include "InactiveProcessor.h"
#include "../../../utility/String.h"

OT::OptionSelectionUnit::OptionProcessor::OptionProcessor(const MultipleChoiceQuestion::OptionGroup& optionGroup, const std::vector<std::string>& correctOptions) :

    /* We just copy the option group and correct options */
    m_optionGroup(optionGroup),
    m_correctOptions(correctOptions)
{}

void OT::OptionSelectionUnit::OptionProcessor::process(MultipleChoiceQuestion & question) const
{
    /* We add the option group */
    question.optionGroups.push_back(m_optionGroup);

    /*
    * And we add the correct options as correct answers. If there is no correct
    * answer yet, we create one and fill it with the correct options.
    */
    if (question.correctAnswers.empty())
    {
        Answer correctAnswer;
        correctAnswer.elements = m_correctOptions;
        question.correctAnswers.push_back(correctAnswer);
    }

    /* Otherwise, we add all correct options to each existing correct answer. */
    else
        for (auto& correctAnswer : question.correctAnswers)
            for (const auto& correctOption : m_correctOptions)
                correctAnswer.elements.push_back(correctOption);
}

std::set<std::string> OT::OptionSelectionUnit::getKeys() const
{
    /*
    * We retrieve the keys supported by each bucket. If any bucket does not contain
    * enough options to choose from, then it only supports the null key. In this
    * case the unit is not usable, so the only key it supports is the null key as
    * well.
    */
    std::set<std::string> correctKeys = m_correctOptions.getKeys();
    std::set<std::string> incorrectKeys = m_incorrectOptions.getKeys();
    if (correctKeys == std::set<std::string>({ OPENTESTING_NULL_KEY }) || incorrectKeys == std::set<std::string>({ OPENTESTING_NULL_KEY }))
        return { OPENTESTING_NULL_KEY };

    /*
    * Otherwise, we enumerate all possible combinations of options by computing the
    * Cartesian product of the keys we just retrieved and the set of all possible
    * permutations.
    */

    /* We first compute all possible permutation keys */
    std::vector<std::string> indices(getTotalSelectionSize());
    for (int i = 0; i < getTotalSelectionSize(); i++)
        indices[i] = std::to_string(i);
    std::set<std::string> permutationKeys;
    for (const auto& permutation : Enumerator::permutations(indices))
        permutationKeys.insert(String::join(permutation, OPENTESTING_DELIMITER_BUCKET_KEY));

    /*
    * And then we compute the Cartesian product of the bucket keys with the
    * permutation keys.
    */
    std::vector<std::set<std::string>> individualKeys = { correctKeys, incorrectKeys, permutationKeys };
    auto combinations = Enumerator::cartesianProduct<std::set<std::string>, std::vector<std::string>>(individualKeys);

    /*
    * Finally, we turn these combinations into keys using some character delimiters.
    */
    std::set<std::string> keys;
    for (const auto& combination : combinations)
        keys.insert(combination[0] + OPENTESTING_DELIMITER_BUCKET_KEYS + combination[1] + OPENTESTING_DELIMITER_PERMUTATION_KEY + combination[2]);
    return keys;
}

size_t OT::OptionSelectionUnit::getNumKeys() const
{
    /*
    * We first compute the total number of possible permutations, which is just N!
    * where N is the total selection size.
    */
    size_t numPermutations = 1;
    for (size_t i = 2; i <= getTotalSelectionSize(); i++)
        numPermutations *= i;

    /*
    * Then, since the keys supported by the unit are the result of a Cartesian
    * product, we can compute the number of keys with a simple multiplication:
    */
    return m_correctOptions.getNumKeys() * m_incorrectOptions.getNumKeys() * numPermutations;
}

std::unique_ptr<OT::Pipeline<OT::MultipleChoiceQuestion>::Processor> OT::OptionSelectionUnit::generate(const std::string& key) const
{
    /*
    * If we receive the null key, we generate an inactive processor so that
    * questions will be left untouched.
    */
    if (key == OPENTESTING_NULL_KEY)
        return std::make_unique<InactiveProcessor<OT::MultipleChoiceQuestion>>();

    /* Otherwise, we parse the key */
    std::vector<std::string> parts = String::split(key, OPENTESTING_DELIMITER_PERMUTATION_KEY);
    std::vector<std::string> bucketKeys = String::split(parts[0], OPENTESTING_DELIMITER_BUCKET_KEYS);
    std::string permutationKey = parts[1];

    /* Then we select options according to the key */
    std::vector<std::string> options;
    std::vector<std::string> correctOptions = m_correctOptions.generate(bucketKeys[0]);
    std::vector<std::string> incorrectOptions = m_incorrectOptions.generate(bucketKeys[1]);
    for (const auto& option : correctOptions)
        options.push_back(option);
    for (const auto& option : incorrectOptions)
        options.push_back(option);

    /*
    * And we create an OptionGroup which we populate with the options after applying
    * the permutation specified by the key.
    */
    MultipleChoiceQuestion::OptionGroup optionGroup;
    for (const auto& index : String::split(permutationKey, OPENTESTING_DELIMITER_BUCKET_KEY))
        optionGroup.options.push_back(options[std::stoi(index)]);

    /* Finally, we create and return the corresponding OptionProcessor */
    return std::make_unique<OptionProcessor>(optionGroup, correctOptions);
}

size_t OT::OptionSelectionUnit::getCorrectSelectionSize() const
{
    return m_correctOptions.getSelectionSize();
}

size_t OT::OptionSelectionUnit::getIncorrectSelectionSize() const
{
    return m_incorrectOptions.getSelectionSize();
}

size_t OT::OptionSelectionUnit::getTotalSelectionSize() const
{
    return m_correctOptions.getSelectionSize() + m_incorrectOptions.getSelectionSize();
}

void OT::OptionSelectionUnit::appendCorrectOption(const std::string& option)
{
    m_correctOptions.append(option);
}

void OT::OptionSelectionUnit::appendIncorrectOption(const std::string& option)
{
    m_incorrectOptions.append(option);
}

void OT::OptionSelectionUnit::clearCorrectOptions()
{
    m_correctOptions.clear();
}

void OT::OptionSelectionUnit::clearIncorrectOptions()
{
    m_incorrectOptions.clear();
}

void OT::OptionSelectionUnit::setCorrectSelectionSize(size_t selectionSize)
{
    m_correctOptions.setSelectionSize(selectionSize);
}

void OT::OptionSelectionUnit::setIncorrectSelectionSize(size_t selectionSize)
{
    m_incorrectOptions.setSelectionSize(selectionSize);
}
