/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#include <string>
#include <algorithm>

#include "OptionSelectionUnit.h"
#include "../../../config/SpecialKeys.h"
#include "../../../utility/Enumerator.h"
#include "../../../config/Delimiters.h"
#include "../../engine/InactiveProcessor.h"
#include "../../../utility/String.h"

OT::OptionSelectionUnit::Processor::Processor(const MultipleChoiceQuestion::OptionGroup& optionGroup, const std::vector<std::string>& correctOptions) :

    /* We just copy the option group and correct options */
    m_optionGroup(optionGroup),
    m_correctOptions(correctOptions)
{}

void OT::OptionSelectionUnit::Processor::process(MultipleChoiceQuestion & question) const
{
    /* We add the option group */
    question.optionGroups.push_back(m_optionGroup);

    /*
    * And we add the correct options as correct answers. If there is no correct
    * answer yet, we create one and fill it with the correct options.
    */
    if (question.correctAnswers.empty())
    {
        Answer correctAnswer;
        correctAnswer.elements = m_correctOptions;
        question.correctAnswers.push_back(correctAnswer);
    }

    /* Otherwise, we add all correct options to each existing correct answer. */
    else
        for (auto& correctAnswer : question.correctAnswers)
            for (const auto& correctOption : m_correctOptions)
                correctAnswer.elements.push_back(correctOption);
}

OT::OptionSelectionUnit::OptionSelectionUnit()
{
    /*
    * We initialize the keys. Concretely, it will simply register the null key as
    * the only valid key since the unit is empty for now.
    */
    updateKeys();
}

std::set<std::string> OT::OptionSelectionUnit::getKeys() const
{
    return m_keys;
}

size_t OT::OptionSelectionUnit::getNumKeys() const
{
    return m_keys.size();
}

std::unique_ptr<OT::Pipeline<OT::MultipleChoiceQuestion>::Processor> OT::OptionSelectionUnit::generate(const std::string& key) const
{
    /*
    * If we receive the null key, we generate an inactive processor so that
    * questions will be left untouched.
    */
    if (key == OPENTESTING_NULL_KEY)
        return std::make_unique<InactiveProcessor<OT::MultipleChoiceQuestion>>();

    /* Otherwise, we parse the key */
    std::vector<std::string> parts = String::split(key, OPENTESTING_DELIMITER_PERMUTATION_KEY);
    std::vector<std::string> bucketKeys = String::split(parts[0], OPENTESTING_DELIMITER_BUCKET_KEYS);
    std::string permutationKey = parts[1];

    /* Then we select options according to the key */
    std::vector<std::string> options;
    std::vector<std::string> correctOptions = m_correctOptions.generate(bucketKeys[0]);
    std::vector<std::string> incorrectOptions = m_incorrectOptions.generate(bucketKeys[1]);
    for (const auto& option : correctOptions)
        options.push_back(option);
    for (const auto& option : incorrectOptions)
        options.push_back(option);

    /*
    * And we create an OptionGroup which we populate with the title and the options
    * after applying the permutation specified by the key.
    */
    MultipleChoiceQuestion::OptionGroup optionGroup;
    optionGroup.title = m_title;
    for (const auto& index : String::split(permutationKey, OPENTESTING_DELIMITER_BUCKET_KEY))
        optionGroup.options.push_back(options[std::stoi(index)]);

    /*
    * Finally, we create and return the corresponding OptionSelectionUnit::Processor
    */
    return std::make_unique<Processor>(optionGroup, correctOptions);
}

const std::string& OT::OptionSelectionUnit::getTitle() const
{
    return m_title;
}

size_t OT::OptionSelectionUnit::getCorrectSelectionSize() const
{
    return m_correctOptions.getSelectionSize();
}

size_t OT::OptionSelectionUnit::getIncorrectSelectionSize() const
{
    return m_incorrectOptions.getSelectionSize();
}

size_t OT::OptionSelectionUnit::getTotalSelectionSize() const
{
    return m_correctOptions.getSelectionSize() + m_incorrectOptions.getSelectionSize();
}

void OT::OptionSelectionUnit::setTitle(const std::string& title)
{
    m_title = title;
}

void OT::OptionSelectionUnit::appendCorrectOption(const std::string& option)
{
    m_correctOptions.append(option);
    updateKeys();
}

void OT::OptionSelectionUnit::appendIncorrectOption(const std::string& option)
{
    m_incorrectOptions.append(option);
    updateKeys();
}

void OT::OptionSelectionUnit::removeCorrectOption(const std::string& option)
{
    m_correctOptions.remove(option);
}

void OT::OptionSelectionUnit::removeIncorrectOption(const std::string& option)
{
    m_incorrectOptions.remove(option);
}

void OT::OptionSelectionUnit::clearCorrectOptions()
{
    m_correctOptions.clear();
    updateKeys();
}

void OT::OptionSelectionUnit::clearIncorrectOptions()
{
    m_incorrectOptions.clear();
    updateKeys();
}

void OT::OptionSelectionUnit::setCorrectSelectionSize(size_t selectionSize)
{
    m_correctOptions.setSelectionSize(selectionSize);
    updateKeys();
}

void OT::OptionSelectionUnit::setIncorrectSelectionSize(size_t selectionSize)
{
    m_incorrectOptions.setSelectionSize(selectionSize);
    updateKeys();
}

void OT::OptionSelectionUnit::serialize(Writer& writer) const
{
    writer.write("type", std::string("OptionSelectionUnit"));
    writer.write("title", m_title);
    writer.write("correctOptions", m_correctOptions);
    writer.write("incorrectOptions", m_incorrectOptions);
}

void OT::OptionSelectionUnit::deserialize(const Reader& reader)
{
    /*
    * We first deserialize each member variable  as it was serialized and then we
    * update the keys. This two-step process enables to only update the keys once
    * and not each time a bucket is modified.
    */

    /* We deserialize each member variable */
    m_title = reader.read<std::string>("title");
    m_correctOptions = reader.read<Bucket<std::string>>("correctOptions");
    m_incorrectOptions = reader.read<Bucket<std::string>>("incorrectOptions");

    /* And then we update the keys */
    updateKeys();
}

void OT::OptionSelectionUnit::updateKeys()
{
    /*
    * We retrieve the keys supported by each bucket. If any bucket does not contain
    * enough options to choose from, then it only supports the null key. In this
    * case the unit is not usable, so the only key it supports is the null key as
    * well.
    */
    std::set<std::string> correctKeys = m_correctOptions.getKeys();
    std::set<std::string> incorrectKeys = m_incorrectOptions.getKeys();
    if (correctKeys == std::set<std::string>({ OPENTESTING_NULL_KEY }) || incorrectKeys == std::set<std::string>({ OPENTESTING_NULL_KEY }))
        m_keys = { OPENTESTING_NULL_KEY };

    /*
    * Otherwise, we enumerate all possible combinations of options by computing the
    * Cartesian product of the keys we just retrieved and the set of all possible
    * permutations.
    */

    /* We first compute all possible permutation keys */
    std::vector<std::string> indices(getTotalSelectionSize());
    for (int i = 0; i < getTotalSelectionSize(); i++)
        indices[i] = std::to_string(i);
    std::set<std::string> permutationKeys;
    for (const auto& permutation : Enumerator::permutations(indices))
        permutationKeys.insert(String::join(permutation, OPENTESTING_DELIMITER_BUCKET_KEY));

    /*
    * And then we compute the Cartesian product of the bucket keys with the
    * permutation keys.
    */
    std::vector<std::set<std::string>> individualKeys = { correctKeys, incorrectKeys, permutationKeys };
    auto combinations = Enumerator::cartesianProduct<std::set<std::string>, std::vector<std::string>>(individualKeys);

    /*
    * Finally, we turn these combinations into keys using some character delimiters.
    */
    m_keys.clear();
    for (const auto& combination : combinations)
        m_keys.insert(combination[0] + OPENTESTING_DELIMITER_BUCKET_KEYS + combination[1] + OPENTESTING_DELIMITER_PERMUTATION_KEY + combination[2]);
}
