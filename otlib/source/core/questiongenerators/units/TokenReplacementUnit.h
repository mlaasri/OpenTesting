/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <memory>

#include "../questions/MultipleChoiceQuestion.h"
#include "../../engine/Factory.h"
#include "../../engine/Bucket.h"

namespace OT
{
    /**
    * \class TokenReplacementUnit TokenReplacementUnit.h
    * A Factory::Unit that uses a token replacement mechanism to complete the
    * components of a question. The unit can be configured to complete a question's
    * prompt, its explanation field, or both.
    * 
    * The unit relies on a set of tokens and a Bucket of replacement strings. The
    * unit uses its input key to choose a replacement string and then replaces any
    * occurrence of any of the tokens with this replacement string by the
    * intermediate of a TokenReplacementUnit::Processor.
    */
    class TokenReplacementUnit :
        public Factory<Question>::Unit
    {
    public:

        /**
        * \class Processor TokenReplacementUnit.h
        * A Pipeline::Processor object that fills the prompt and explanation fields
        * of a question by replacing some tokens with a replacement string.
        */
        class Processor :
            public Pipeline<Question>::Processor
        {
        public:

            /**
            * Creates a TokenReplacementUnit::Processor that will replace any
            * occurrence of the given tokens by the replacement string.
            * @param[in] tokens The tokens to replace.
            * @param[in] replacementString The string to replace the tokens with.
            * @param[in] replaceInPrompt Whether to replace tokens in a question's
            *   prompt.
            * @param[in] replaceInExplanation Whether to replace tokens in a
            *   question's explanation field.
            */
            Processor(const std::vector<std::string>& tokens, const std::string& replacementString, bool replaceInPrompt, bool replaceInExplanation);

            /**
            * Replaces any occurrence of the supported tokens with the replacement
            * string inside the question's prompt and explanation fields.
            * @param[in] question The question to perform the replacement on.
            */
            void process(Question& question) const override;

        private:

            /** The tokens to replace. */
            std::vector<std::string> m_tokens;

            /** The string to replace the tokens with. */
            std::string m_replacementString;

            /** Whether to replace the tokens in a question's prompt */
            bool m_replaceInPrompt;

            /** Whether to replace the tokens in a question's explanation field */
            bool m_replaceInExplanation;
        };

        /**
        * Creates an empty unit with no tokens nor replacement strings and
        * configured to modify both the prompt and explanation fields of a question.
        */
        TokenReplacementUnit();

        /**
        * Returns the set of keys supported by the unit.
        *
        * If the unit does not contain any replacement string or has no registered
        * token, then it is not usable, so the only key it supports is the null key
        * OPENTESTING_NULL_KEY ("N").
        * 
        * On the other hand, if the unit contains at least one replacement string
        * and one token to replace, then the keys it supports are all the strings
        * representing a valid index between 0 and getSize() - 1 included, i.e. "0",
        * "1", "2", etc.
        */
        std::set<std::string> getKeys() const override;

        /**
        * Returns the number of keys supported by the unit.
        */
        size_t getNumKeys() const override;

        /**
        * Picks a replacement string and generates a TokenReplacementUnit::Processor
        * that replaces all registered tokens with this string.
        * @param[in] key The key to use to pick the replacement string. If the unit
        *   does not contain any replacement string or has no registered token, then
        *   it is not usable, so the key must be equal to the null key
        *   OPENTESTING_NULL_KEY ("N"), in which case the unit will generate an
        *   InactiveProcessor that does not perform any operation. Otherwise, it
        *   must be a string representing a valid index between 0 and getSize() - 1
        *   included, e.g. "0", "1", "2", etc., in which case the unit will return
        *   an appropriate TokenReplacementUnit::Processor that uses this string.
        */
        std::unique_ptr<Pipeline<Question>::Processor> generate(const std::string& key) const override;

        /**
        * Returns all the tokens handled by the unit.
        */
        const std::vector<std::string>& getTokens() const;

        /**
        * Returns the replacement strings contained in the unit.
        */
        const std::vector<std::string>& getReplacementStrings() const;

        /**
        * Returns the number of replacement strings in the unit.
        */
        size_t getSize() const;

        /**
        * Returns true if the unit replaces tokens in prompts and false otherwise.
        */
        bool isReplacementInPromptEnabled() const;

        /**
        * Returns true if the unit replaces tokens in explanation fields and false
        * otherwise.
        */
        bool isReplacementInExplanationEnabled() const;

        /**
        * Adds a token to be used for replacement by the unit.
        * @param[in] token The token to add.
        */
        void addToken(const std::string& token);

        /**
        * Removes a token from the unit so the latter no longer handles it. If the
        * token given in argument is not currently supported by the unit, an invalid
        * argument exception is thrown.
        * @param[in] token The token to remove.
        */
        void removeToken(const std::string& token);

        /**
        * Removes all tokens from the unit.
        */
        void clearTokens();

        /**
        * Adds a replacement string to the unit.
        * @param[in] stringToAdd The string to add.
        */
        void addReplacementString(const std::string& stringToAdd);

        /**
        * Removes a replacement string from the unit. If the string given in
        * argument is not currently a replacement string in the unit, an invalid
        * argument exception is thrown.
        * @param[in] stringToRemove The string to remove.
        */
        void removeReplacementString(const std::string& stringToRemove);

        /**
        * Removes all replacement strings from the unit.
        */
        void clearReplacementStrings();

        /**
        * Enables the replacement of tokens in prompts.
        */
        void enableReplacementInPrompt();

        /**
        * Disables the replacement of tokens in prompts.
        */
        void disableReplacementInPrompt();

        /**
        * Enables the replacement of tokens in explanation fields.
        */
        void enableReplacementInExplanation();

        /**
        * Disables the replacement of tokens in explanation fields.
        */
        void disableReplacementInExplanation();

    protected:

        /**
        * Makes sure that no token appear in no replacement string, since otherwise
        * the TokenReplacementUnit::Processor could enter an infinite loop while
        * trying to replace the token with this replacement string. If at least one
        * token is found in at least one of the replacement strings, an invalid
        * argument exception is thrown.
        */
        void checkForInfiniteLoop() const;

    private:

        /** The tokens registered for the unit. */
        std::vector<std::string> m_tokens;

        /** The bucket containing all possible replacement strings. */
        Bucket<std::string> m_bucket;

        /** Whether to replace the tokens in a question's prompt */
        bool m_replaceInPrompt;

        /** Whether to replace the tokens in a question's explanation field */
        bool m_replaceInExplanation;
    };
}