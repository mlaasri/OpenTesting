/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#include <algorithm>
#include <stdexcept>

#include "TokenReplacementUnit.h"
#include "../../../utility/String.h"
#include "InactiveProcessor.h"

OT::TokenReplacementUnit::Processor::Processor(const std::vector<std::string>& tokens, const std::string& replacementString) :

    /* We just copy the tokens and the replacement string */
    m_tokens(tokens),
    m_replacementString(replacementString)
{}

void OT::TokenReplacementUnit::Processor::process(MultipleChoiceQuestion & question) const
{
    /* We loop over every token to replace */
    for (const auto& token : m_tokens)
    {
        /*
        * We replace any occurrence of the token with the replacement string in both
        * the question's prompt and its explanation field.
        */
        String::replaceAll(question.prompt, token, m_replacementString);
        String::replaceAll(question.explanation, token, m_replacementString);
    }
}

std::set<std::string> OT::TokenReplacementUnit::getKeys() const
{
    /*
    * If the unit has no registered token, then it is not usable, so the only key it
    * supports is the null key.
    */
    if (m_tokens.empty())
        return { OPENTESTING_NULL_KEY };

    /*
    * Otherwise, we return the keys supported by the bucket, which can still consist
    * of the null key only if the bucket is empty.
    */
    return m_bucket.getKeys();
}

size_t OT::TokenReplacementUnit::getNumKeys() const
{
    return m_bucket.getNumKeys();
}

std::unique_ptr<OT::Pipeline<OT::MultipleChoiceQuestion>::Processor> OT::TokenReplacementUnit::generate(const std::string& key) const
{
    /*
    * If we receive the null key, we generate an inactive processor so that
    * questions will be left untouched.
    */
    if (key == OPENTESTING_NULL_KEY)
        return std::make_unique<InactiveProcessor<OT::MultipleChoiceQuestion>>();

    /*
    * Otherwise, we pick a replacement string from the bucket and return a
    * TokenReplacementUnit::Processor for it
    */
    std::string replacementString = m_bucket.generate(key).front();
    return std::make_unique<Processor>(m_tokens, replacementString);
}

const std::vector<std::string>& OT::TokenReplacementUnit::getTokens() const
{
    return m_tokens;
}

const std::vector<std::string>& OT::TokenReplacementUnit::getReplacementStrings() const
{
    return m_bucket.getObjects();
}

size_t OT::TokenReplacementUnit::getSize() const
{
    return m_bucket.getSize();
}

void OT::TokenReplacementUnit::addToken(const std::string& token)
{
    m_tokens.push_back(token);
    checkForInfiniteLoop();

    /*
    * The only way that a change in the token list can affect the keys supported by
    * the unit is if this list gets empty and the null key becomes the only valid
    * key. This cannot happen if we add a token, so there is no need to update the
    * keys here.
    */
}

void OT::TokenReplacementUnit::removeToken(const std::string& token)
{
    /* We search for the token */
    auto it = std::find(m_tokens.cbegin(), m_tokens.cend(), token);

    /* If we cannot find it, we throw an exception */
    if (it == m_tokens.cend())
        throw std::invalid_argument("Token '" + token + "' is not registered in the unit and cannot be removed.");

    /* Otherwise, we remove it from the vector */
    m_tokens.erase(it);
}

void OT::TokenReplacementUnit::clearTokens()
{
    m_tokens.clear();
}

void OT::TokenReplacementUnit::addReplacementString(const std::string& stringToAdd)
{
    m_bucket.append(stringToAdd);
}

void OT::TokenReplacementUnit::removeReplacementString(const std::string& stringToRemove)
{
    m_bucket.remove(stringToRemove);
}

void OT::TokenReplacementUnit::clearReplacementStrings()
{
    m_bucket.clear();
}

void OT::TokenReplacementUnit::checkForInfiniteLoop() const
{
    /*
    * We make sure that no token appear in no replacement string, since otherwise
    * the TokenReplacementUnit::Processor could enter an infinite loop while trying
    * to replace the token with this replacement string. If we find one token in at
    * least one of the replacement strings, we throw an exception.
    */
    for (const auto& token : m_tokens)
        for (const auto& replacementString : m_bucket.getObjects())
            if (String::contains(replacementString, token))
                throw std::invalid_argument("Replacement string '" + replacementString + "' cannot contain token '" + token + "'.");
}
