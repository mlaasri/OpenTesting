/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#include <algorithm>
#include <stdexcept>

#include "TokenReplacementUnit.h"
#include "../../../utility/String.h"
#include "InactiveProcessor.h"

#define OPENTESTING_TOKEN_REPLACEMENT_UNIT_NULL_KEY "N"

OT::TokenReplacementUnit::ReplacementProcessor::ReplacementProcessor(const std::vector<std::string>& tokens, const std::string& replacementString) :

    /* We just copy the tokens and the replacement string */
    m_tokens(tokens),
    m_replacementString(replacementString)
{}

void OT::TokenReplacementUnit::ReplacementProcessor::process(MultipleChoiceQuestion & question) const
{
    /* We loop over every token to replace */
    for (const auto& token : m_tokens)
    {
        /*
        * We replace any occurrence of the token with the replacement string in both
        * the question's prompt and its explanation field.
        */
        String::replaceAll(question.prompt, token, m_replacementString);
        String::replaceAll(question.explanation, token, m_replacementString);
    }
}

std::set<std::string> OT::TokenReplacementUnit::getKeys() const
{
    return m_keys;
}

size_t OT::TokenReplacementUnit::getNumKeys() const
{
    return m_keys.size();
}

std::unique_ptr<OT::Pipeline<OT::MultipleChoiceQuestion>::Processor> OT::TokenReplacementUnit::generate(const std::string& key) const
{
    /*
    * If we receive the null key, we generate an inactive processor so that
    * questions will be left untouched.
    */
    if (key == OPENTESTING_TOKEN_REPLACEMENT_UNIT_NULL_KEY)
        return std::make_unique<InactiveProcessor<OT::MultipleChoiceQuestion>>();

    /*
    * Otherwise, we decode the key as the index of the replacement string to pick
    * and return a ReplacementProcessor for it
    */
    std::string replacementString = m_strings[std::stoi(key)];
    return std::make_unique<ReplacementProcessor>(m_tokens, replacementString);
}

const std::vector<std::string>& OT::TokenReplacementUnit::getTokens() const
{
    return m_tokens;
}

const std::vector<std::string>& OT::TokenReplacementUnit::getStrings() const
{
    return m_strings;
}

size_t OT::TokenReplacementUnit::getSize() const
{
    return m_strings.size();
}

void OT::TokenReplacementUnit::addToken(const std::string& token)
{
    m_tokens.push_back(token);
    checkForInfiniteLoop();

    /*
    * The only way that a change in the token list can affect the keys supported by
    * the unit is if this list gets empty and the null key becomes the only valid
    * key. This cannot happen if we add a token, so there is no need to update the
    * keys here.
    */
}

void OT::TokenReplacementUnit::removeToken(const std::string& token)
{
    /* We search for the token */
    auto it = std::find(m_tokens.cbegin(), m_tokens.cend(), token);

    /* If we cannot find it, we throw an exception */
    if (it == m_tokens.cend())
        throw std::invalid_argument("Token '" + token + "' is not listed in the unit and cannot be removed.");

    /* Otherwise, we remove it from the vector */
    m_tokens.erase(it);

    /*
    * And we update the keys in case we have no more tokens in store and the null
    * key becomes the only valid key supported by the unit.
    */
    updateKeys();
}

void OT::TokenReplacementUnit::clearTokens()
{
    m_tokens.clear();
    updateKeys();
}

void OT::TokenReplacementUnit::addString(const std::string& stringToAdd)
{
    m_strings.push_back(stringToAdd);
    updateKeys();
}

void OT::TokenReplacementUnit::removeString(const std::string& stringToRemove)
{
    /* We search for the string */
    auto it = std::find(m_strings.cbegin(), m_strings.cend(), stringToRemove);

    /* If we cannot find it, we throw an exception */
    if (it == m_strings.cend())
        throw std::invalid_argument("String '" + stringToRemove + "' is not listed in the unit and cannot be removed.");

    /* Otherwise, we remove it from the vector */
    m_strings.erase(it);

    /* And we update the keys */
    updateKeys();
}

void OT::TokenReplacementUnit::clearStrings()
{
    m_strings.clear();
    updateKeys();
}

void OT::TokenReplacementUnit::updateKeys()
{
    /*
    * If the unit has no registered token or does not contain any replacement
    * string, then it is not usable, so the only key it supports is the null key
    * "N".
    */
    if (m_tokens.empty() || m_strings.empty())
        m_keys = { OPENTESTING_TOKEN_REPLACEMENT_UNIT_NULL_KEY };

    /*
    * Otherwise, the keys it supports are all the strings representing a valid index
    * between 0 and getSize() - 1 included, i.e. "0", "1", "2", etc.
    */
    else
    {
        m_keys.clear();
        for (int i = 0; i < m_strings.size(); i++)
            m_keys.insert(std::to_string(i));
    }
}

void OT::TokenReplacementUnit::checkForInfiniteLoop() const
{
    /*
    * We make sure that no token appear in no replacement string, since otherwise
    * the ReplacementProcessor could enter an infinite loop while trying to replace
    * the token with this replacement string. If we find one token in at least one
    * of the replacement strings, we throw an exception.
    */
    for (const auto& token : m_tokens)
        for (const auto& replacementString : m_strings)
            if (String::contains(replacementString, token))
                throw std::invalid_argument("Replacement string '" + replacementString + "' cannot contain token '" + token + "'.");
}
