/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#include <algorithm>
#include <stdexcept>

#include "TokenReplacementUnit.h"
#include "../../../utility/String.h"
#include "../../engine/InactiveProcessor.h"

OT::TokenReplacementUnit::Processor::Processor(const std::vector<std::string>& tokens, const std::string& replacementString, bool replaceInPrompt, bool replaceInExplanation) :

    /*
    * We copy the tokens, the replacement string, and the flags indicating whether
    * we should modify prompts and explanation fields.
    */
    m_tokens(tokens),
    m_replacementString(replacementString),
    m_replaceInPrompt(replaceInPrompt),
    m_replaceInExplanation(replaceInExplanation)
{}

void OT::TokenReplacementUnit::Processor::process(Question & question) const
{
    /* We loop over every token to replace */
    for (const auto& token : m_tokens)
    {
        /*
        * We replace any occurrence of the token with the replacement string in the
        * question's prompt and its explanation field depending on the processor's
        * boolean flags.
        */
        if (m_replaceInPrompt)
            String::replaceAll(question.prompt, token, m_replacementString);
        if (m_replaceInExplanation)
            String::replaceAll(question.explanation, token, m_replacementString);
    }
}

OT::TokenReplacementUnit::TokenReplacementUnit()
{
    /*
    * By default, a TokenReplacementUnit replaces tokens in both prompts and
    * explanation fields.
    */
    enableReplacementInPrompt();
    enableReplacementInExplanation();
}

OT::TokenReplacementUnit::KeyContainerType OT::TokenReplacementUnit::getKeys() const
{
    /*
    * If the unit has no registered token, then it is not usable, so the only key it
    * supports is the null key.
    */
    if (m_tokens.empty())
        return { OPENTESTING_NULL_KEY };

    /*
    * Otherwise, we return the keys supported by the bucket, which can still consist
    * of the null key only if the bucket is empty.
    */
    return m_bucket.getKeys();
}

size_t OT::TokenReplacementUnit::getNumKeys() const
{
    return m_bucket.getNumKeys();
}

std::unique_ptr<OT::Pipeline<OT::Question>::Processor> OT::TokenReplacementUnit::generate(const std::string& key) const
{
    /*
    * If we receive the null key, we generate an inactive processor so that
    * questions will be left untouched.
    */
    if (key == OPENTESTING_NULL_KEY)
        return std::make_unique<InactiveProcessor<OT::Question>>();

    /*
    * Otherwise, we pick a replacement string from the bucket and return a
    * TokenReplacementUnit::Processor for it
    */
    std::string replacementString = m_bucket.generate(key).front();
    return std::make_unique<Processor>(m_tokens, replacementString, m_replaceInPrompt, m_replaceInExplanation);
}

const std::vector<std::string>& OT::TokenReplacementUnit::getTokens() const
{
    return m_tokens;
}

const std::vector<std::string>& OT::TokenReplacementUnit::getReplacementStrings() const
{
    return m_bucket.getObjects();
}

size_t OT::TokenReplacementUnit::getSize() const
{
    return m_bucket.getSize();
}

bool OT::TokenReplacementUnit::isReplacementInPromptEnabled() const
{
    return m_replaceInPrompt;
}

bool OT::TokenReplacementUnit::isReplacementInExplanationEnabled() const
{
    return m_replaceInExplanation;
}

void OT::TokenReplacementUnit::addToken(const std::string& token)
{
    m_tokens.push_back(token);
    checkForInfiniteLoop();
}

void OT::TokenReplacementUnit::removeToken(const std::string& token)
{
    /* We search for the token */
    auto it = std::find(m_tokens.cbegin(), m_tokens.cend(), token);

    /* If we cannot find it, we throw an exception */
    if (it == m_tokens.cend())
        throw std::invalid_argument("Token '" + token + "' is not registered in the unit and cannot be removed.");

    /* Otherwise, we remove it from the vector */
    m_tokens.erase(it);
}

void OT::TokenReplacementUnit::clearTokens()
{
    m_tokens.clear();
}

void OT::TokenReplacementUnit::addReplacementString(const std::string& stringToAdd)
{
    m_bucket.append(stringToAdd);
}

void OT::TokenReplacementUnit::removeReplacementString(const std::string& stringToRemove)
{
    m_bucket.remove(stringToRemove);
}

void OT::TokenReplacementUnit::clearReplacementStrings()
{
    m_bucket.clear();
}

void OT::TokenReplacementUnit::enableReplacementInPrompt()
{
    m_replaceInPrompt = true;
}

void OT::TokenReplacementUnit::disableReplacementInPrompt()
{
    m_replaceInPrompt = false;
}

void OT::TokenReplacementUnit::enableReplacementInExplanation()
{
    m_replaceInExplanation = true;
}

void OT::TokenReplacementUnit::disableReplacementInExplanation()
{
    m_replaceInExplanation = false;
}

void OT::TokenReplacementUnit::serialize(Writer& writer) const
{
    writer.write("type", std::string("TokenReplacementUnit"));
    writer.write("tokens", m_tokens);
    writer.write("bucket", m_bucket);
    writer.write("replaceInPrompt", m_replaceInPrompt);
    writer.write("replaceInExplanation", m_replaceInExplanation);
}

void OT::TokenReplacementUnit::deserialize(const Reader& reader)
{
    /* We deserialize each member variable as it was serialized */
    m_tokens = reader.read<std::vector<std::string>>("tokens");
    m_bucket = reader.read<Bucket<std::string>>("bucket");
    m_replaceInPrompt = reader.read<bool>("replaceInPrompt");
    m_replaceInExplanation = reader.read<bool>("replaceInExplanation");
}

void OT::TokenReplacementUnit::checkForInfiniteLoop() const
{
    /*
    * We make sure that no token appear in no replacement string, since otherwise
    * the TokenReplacementUnit::Processor could enter an infinite loop while trying
    * to replace the token with this replacement string. If we find one token in at
    * least one of the replacement strings, we throw an exception.
    */
    for (const auto& token : m_tokens)
        for (const auto& replacementString : m_bucket.getObjects())
            if (String::contains(replacementString, token))
                throw std::invalid_argument("Replacement string '" + replacementString + "' cannot contain token '" + token + "'.");
}
