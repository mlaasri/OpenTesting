/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <string>
#include <vector>

#include "GenericQuestionGenerator.h"
#include "../../../utility/serialization/Serializable.h"
#include "../questions/question/Question.h"
#include "../../engine/KeyDelimitedFactory.h"
#include "../../../config/Delimiters.h"
#include "../../../utility/String.h"
#include "../../../utility/Enumerator.h"

namespace OT
{
    /**
    * \class QuestionGenerator QuestionGenerator.h
    * A GenericQuestionGenerator specialized in generating a particular type of
    * Question.
    */
    template<class QuestionType>
    class QuestionGenerator :
        public GenericQuestionGenerator,
        public Serializable
    {
    public:

        /** A shorthand for the type of Factory used in the QuestionGenerator */
        typedef KeyDelimitedFactory<QuestionType> Factory;

        /**
        * \struct Table QuestionGenerator.h
        * A vector of factories for a QuestionGenerator to choose from for
        * generating a question. The QuestionGenerator will only pick one factory
        * per Table.
        */
        struct Table :
            public Serializable
        {
            /** The factories contained in the Table */
            std::vector<Factory> factories;

            /**
            * Returns the factories contained in the Table as a const reference. To
            * get a non-const reference, use the public member variable
            * Table::factories directly instead.
            *
            * Since the returned vector is a const reference, it does not allow
            * factories to be directly modified through it, i.e. no factory can be
            * added or removed and no unit can be added to or removed from any
            * factory using it. However, existing units inside the current factories
            * can still be accessed and modified through it.
            */
            const std::vector<Factory>& getFactories() const;

            /** Returns the number of factories contained in the Table. */
            size_t getNumFactories() const;

            /**
            * Creates a new, empty factory, inserts it at the end of the Table, and
            * returns a reference to it.
            *
            * Note that since the factory is added at the end, its index within the
            * Table will be equal to getNumFactories() - 1.
            */
            Factory& appendNewFactory();

            /**
            * Removes and destroys all factories and their content from the Table.
            */
            void clear();

            /**
            * Serializes the Table with the given Writer.
            * @param[out] writer The writer to use to serialize the Table.
            */
            void serialize(Writer& writer) const override;

            /**
            * Deserializes the Table with the given Reader.
            * @param[in] reader The reader to use to deserialize the Table.
            */
            void deserialize(const Reader& reader) override;
        };

        /**
        * Returns all the keys supported by the QuestionGenerator. The keys are
        * obtained by computing the Cartesian product of all possible factory keys
        * and then concatenating each Factory's identifier with each of its keys
        * with a character delimiter.
        * 
        * Note that, as a result, if any factory in the QuestionGenerator has a unit
        * that does not support any key, then the whole factory will not either, and
        * so the factory will be ignored and skipped when generating the keys.
        */
        typename QuestionGenerator<QuestionType>::KeyContainerType getKeys() const override;

        /**
        * Returns the number of keys supported by the QuestionGenerator. This number
        * is obtained by first summing for each Table the number of keys supported
        * by its factories, and then multiplying these numbers together.
        * 
        * Note that, as a result, if any factory in the QuestionGenerator has a unit
        * that does not support any key, then the whole factory will not either, and
        * so the factory will be ignored and not accounted for in the total number
        * of keys.
        */
        size_t getNumKeys() const;

        /**
        * Generates a Question based on the given key and returns a pointer to it.
        * 
        * To generate a Question, the QuestionGenerator will first initialize a
        * Question object of the appropriate type using the initializeQuestion()
        * method, then pick one single factory per Table based on the given key, and
        * use these factories to generate pipelines that will process and complete
        * the Question object.
        * 
        * The returned pointer points to a Question of type Question, but the object
        * itself is an instance of the template type QuestionType. It can be casted
        * to the appropriate type later, or with the generateAndCast() method
        * directly. Note that casting requires to turn the pointer into a shared
        * pointer, since the casting operation does not support ownership
        * exclusivity.
        * @param[in] key The key to use for generating the Question.
        */
        std::unique_ptr<Question> generate(const std::string& key) const override;

        /**
        * Returns the tables contained in the QuestionGenerator as a const
        * reference. To get a non-const reference, use the public member variable
        * QuestionGenerator::tables directly instead.
        * 
        * Since the returned vector is a const reference, it does not allow tables
        * to be directly modified through it, i.e. no table can be added or removed
        * and no factory can be added to or removed from any table using it.
        * However, existing units inside existing factories can still be accessed
        * and modified through it.
        */
        const std::vector<Table>& getTables() const;

        /** Returns the number of tables contained in the QuestionGenerator. */
        size_t getNumTables() const;

        /**
        * Creates a new, empty Table, inserts it at the end of the
        * QuestionGenerator's Table vector, and returns a reference to it.
        * 
        * Note that since the Table is added at the end, its index within the
        * QuestionGenerator will be equal to getNumTables() - 1.
        */
        Table& appendNewTable();

        /**
        * Removes and destroys all tables and their content from the
        * QuestionGenerator.
        */
        void clear();

        /**
        * Serializes the QuestionGenerator with the given Writer.
        * @param[out] writer The writer to use to serialize the QuestionGenerator.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the QuestionGenerator with the given Reader.
        * @param[in] reader The reader to use to deserialize the QuestionGenerator.
        */
        void deserialize(const Reader& reader) override;

        /** The factory tables to pick from when generating the Question */
        std::vector<Table> tables;

    protected:

        /**
        * Initializes a Question object of the appropriate type.
        * 
        * This method is the first method called for generating a Question. The
        * returned object is then passed to a series of pipelines that modifies it,
        * one step at a time.
        * 
        * This method is virtual so it can be overriden in derived classes. By
        * default, it just calls the default constructor of the appropriate Question
        * class.
        */
        virtual std::unique_ptr<QuestionType> initializeQuestion() const;
    };

    template<class QuestionType>
    inline const std::vector<typename QuestionGenerator<QuestionType>::Factory>& QuestionGenerator<QuestionType>::Table::getFactories() const
    {
        return factories;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::Table::getNumFactories() const
    {
        return factories.size();
    }

    template<class QuestionType>
    inline typename QuestionGenerator<QuestionType>::Factory& QuestionGenerator<QuestionType>::Table::appendNewFactory()
    {
        factories.push_back({});
        return factories.back();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::Table::clear()
    {
        factories.clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::Table::serialize(Writer& writer) const
    {
        writer.write("type", std::string("Table"));
        writer.write("factories", factories);
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::Table::deserialize(const Reader& reader)
    {
        factories = reader.read<std::vector<Factory>>("factories");
    }

    template<class QuestionType>
    inline typename QuestionGenerator<QuestionType>::KeyContainerType QuestionGenerator<QuestionType>::getKeys() const
    {
        std::vector<typename QuestionGenerator<QuestionType>::KeyContainerType> keysPerTable;
        for (const auto& table : tables)
        {
            /*
            * We retrieve the keys of each factory and add the factory's index at
            * the beginning of each key as a factory identifier
            */
            typename QuestionGenerator<QuestionType>::KeyContainerType tableKeys;
            for (int f = 0; f < table.getNumFactories(); f++)
                for (const auto& key : table.factories[f].getKeys())
                    tableKeys.insert(tableKeys.end(), String::join({ std::to_string(f), key }, OPENTESTING_DELIMITER_FACTORY_KEY));

            keysPerTable.push_back(tableKeys);
        }

        /* We enumerate all possible combinations of table keys */
        std::vector<std::vector<std::string>> combinations = Enumerator::cartesianProduct<typename QuestionGenerator<QuestionType>::KeyContainerType, std::vector<std::string>>(keysPerTable);

        /* We then create the keys by joining the combinations */
        typename QuestionGenerator<QuestionType>::KeyContainerType keys;
        for (const auto& combination : combinations)
            keys.insert(keys.end(), String::join(combination, OPENTESTING_DELIMITER_TABLE_KEY));

        /* We return the result */
        return keys;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::getNumKeys() const
    {
        /* If the generator has no tables, we return 0 */
        if (tables.empty())
            return 0;

        /*
        * Otherwise, we multiply together the number of keys supported by each
        * table, which can be obtained by summing the number of keys supported by
        * each factory in the table.
        */
        size_t numKeys = 1;
        for (const auto& table : tables)
        {
            size_t numKeysPerTable = 0;
            for (const auto& factory : table.factories)
                numKeysPerTable += factory.getNumKeys();
            numKeys *= numKeysPerTable;
        }
        return numKeys;
    }

    template<class QuestionType>
    inline std::unique_ptr<Question> QuestionGenerator<QuestionType>::generate(const std::string& key) const
    {
        /* We start by initializing a question of the appropriate type */
        std::unique_ptr<QuestionType> question = initializeQuestion();

        /* We then split the key into table keys */
        std::vector<std::string> tableKeys = String::split(key, OPENTESTING_DELIMITER_TABLE_KEY);

        for (int t = 0; t < tableKeys.size(); t++)
        {
            /* We first separate the factory's identifier from its key */
            std::vector<std::string> parts = OT::String::split(tableKeys[t], OPENTESTING_DELIMITER_FACTORY_KEY);
            int factoryID = std::stoi(parts[0]);
            std::string factoryKey = parts[1];

            /* We then generate a pipeline... */
            const Pipeline<QuestionType> pipeline = tables[t].factories[factoryID].generate(factoryKey);

            /* ... And then use it to process the question */
            pipeline.process(*question);
        }
        
        /* Once the question has been processed by all factories, we return it */
        return question;
    }

    template<class QuestionType>
    inline const std::vector<typename QuestionGenerator<QuestionType>::Table>& QuestionGenerator<QuestionType>::getTables() const
    {
        return tables;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::getNumTables() const
    {
        return tables.size();
    }

    template<class QuestionType>
    inline typename QuestionGenerator<QuestionType>::Table& QuestionGenerator<QuestionType>::appendNewTable()
    {
        tables.push_back({});
        return tables.back();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clear()
    {
        tables.clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::serialize(Writer& writer) const
    {
        writer.write("type", std::string("QuestionGenerator"));
        writer.write("tables", tables);
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::deserialize(const Reader& reader)
    {
        tables = reader.read<std::vector<Table>>("tables");
    }

    template<class QuestionType>
    inline std::unique_ptr<QuestionType> QuestionGenerator<QuestionType>::initializeQuestion() const
    {
        return std::make_unique<QuestionType>();
    }
}