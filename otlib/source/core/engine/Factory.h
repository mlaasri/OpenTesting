/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <string>
#include <vector>
#include <typeinfo>
#include <stdexcept>

#include "Pipeline.h"
#include "Generator.h"
#include "../../utility/serialization/Serializable.h"
#include "../../utility/Enumerator.h"
#include "../../utility/serialization/Instantiator.h"

namespace OT
{
    /**
    * \class Factory Factory.h
    * A generator of Pipeline objects for processing other objects.
    * 
    * Derived classes must implement the Pipeline generation mechanism. The easiest
    * way to do so is to use a fundamental tool that is built in the Factory class:
    * the Unit subclass. Note that one can always implement a custom mechanism if
    * preferred, and ignore the Unit-related attributes and methods in this class.
    * 
    * A Unit is an elementary block of a Factory that can generate a
    * Pipeline::Processor object, i.e. the elementary block of a Pipeline. In that
    * sense, Unit-based factories and pipelines work hand in hand, the elements of
    * one generating the elements of the other. One can therefore derive from the
    * Unit class and just implement the generation of each single Processor, with
    * the Factory class taking care of chaining all the processors together into a
    * Pipeline.
    *
    * Units work with their individual keys, which are called "unit keys". Derived
    * classes can implement a way to split a factory key into multiple unit keys to
    * generate a Pipeline and its elements, or simply pass the same factory key to
    * all units and implement their parsing as best fits. The former version is more
    * common in OpenTesting. For example, a simple delimiting character mechanism is
    * used in the KeyDelimitedFactory derived class to split an initial key into
    * multiple unit keys.
    */
    template<class ObjectType>
    class Factory :
        public Generator<Pipeline<ObjectType>>,
        public Serializable
    {
    public:

        /** A handy accessor to the Factory's object type */
        typedef ObjectType ObjectType;

        /** A shorthand for Pipeline::Processor */
        typedef typename Pipeline<ObjectType>::Processor Processor;

        /**
        * \class Unit Factory.h
        * A Pipeline::Processor Generator.
        */
        class Unit :
            public Generator<std::unique_ptr<Processor>>,
            public Serializable
        {
        public:

            /** A handy accessor to the Unit's object type */
            typedef ObjectType ObjectType;
        };

        /**
        * Returns the internal units of the Factory.
        */
        const std::vector<std::unique_ptr<Unit>>& getUnits() const;

        /**
        * Returns the sets of keys that is supported by each Unit. The returned
        * object is a vector where one element correspond to the set of keys
        * supported by the Unit at the same position in the Factory.
        */
        std::vector<typename Factory<ObjectType>::KeyContainerType> getKeysPerUnit() const;

        /**
        * Returns all the possible combinations of individual unit keys that can be
        * sent the Factory's units to generate a Pipeline. These combinations are
        * computed using a simple Cartesian product. For example, if the Factory
        * contains two units with one supporting the keys "K1" and "K2" and one
        * supporting "KA" and "KB", then this method will return the 4 combinations
        * ("K1", "KA"), ("K1", "KB"), ("K2", "KA"), and ("K2", "KB").
        *
        * This method can be used to compute the set of all possible keys that can
        * be sent to the Factory itself. If the Factory just splits its own key into
        * unit keys based on a delimiter for example, which is a typical mechanism
        * implemented in the KeyDelimitedFactory class, then joining each set of
        * unit keys as returned by this method would lead to the set of all valid
        * keys supported by the Factory. If '-' was used as a delimiter in the
        * example above for instance, then the Factory's valid keys would be
        * "K1-KA", "K1-KB", "K2-K1", and "K2-KB".
        */
        std::vector<std::vector<std::string>> getAllUnitKeysCombinations() const;

        /**
        * Adds a Unit at the end of the Factory.
        *
        * Note that the pointer given in argument will be moved to the Factory's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the Factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void append(std::unique_ptr<Unit> unit);

        /**
        * Removes and destroys all units from the Factory.
        */
        void clear();

        /**
        * Dispatches each key to its corresponding Unit so they all generate one
        * Pipeline::Processor each, and chains all resulting processors into a
        * Pipeline. Note that each key is sent to the Unit at the same position in
        * the Factory as the key in the vector argument, i.e. the first key in the
        * vector passed in argument will be sent to the first Unit, and so on.
        * @param[in] unitKeys The individual keys to send to each Unit. The size of
        *   this vector must match exactly the number of units in the Factory, and
        *   each key must be valid for its target Unit.
        */
        Pipeline<ObjectType> generateFromUnits(const std::vector<std::string>& unitKeys) const;

        /**
        * Serializes the factory with the given Writer.
        * @param[out] writer The writer to use to serialize the factory.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the factory with the given Reader.
        * 
        * The Reader must contain the serialized data of a "valid" factory, i.e. a
        * factory (1) whose units are all direct instances of an OpenTesting
        * Factory::Unit type and (2) which does not contain any empty WrapperUnit.
        * If either of this constraint is violated, an invalid argument or runtime
        * error exception will be thrown.
        * @param[in] reader The reader to use to deserialize the factory. The
        *   serialized data it contains must correspond to a valid factory, as
        *   defined in the documentation of this method.
        */
        void deserialize(const Reader& reader) override;

    private:

        /** The Factory's units */
        std::vector<std::unique_ptr<Unit>> m_units;
    };

    template<class ObjectType>
    inline const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& Factory<ObjectType>::getUnits() const
    {
        return m_units;
    }

    template<class ObjectType>
    inline std::vector<typename Factory<ObjectType>::KeyContainerType> Factory<ObjectType>::getKeysPerUnit() const
    {
        /* We list and add all the keys for each unit */
        std::vector<typename Factory<ObjectType>::KeyContainerType> unitKeys;
        for (const auto& unit : m_units)
            unitKeys.push_back(unit->getKeys());
        return unitKeys;
    }

    template<class ObjectType>
    inline std::vector<std::vector<std::string>> Factory<ObjectType>::getAllUnitKeysCombinations() const
    {
        /* We compute the Cartesian product across all possible unit keys. */
        return Enumerator::cartesianProduct<typename Factory<ObjectType>::KeyContainerType, std::vector<std::string>>(getKeysPerUnit());
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::append(std::unique_ptr<Unit> unit)
    {
        /* We move the pointer into the Factory's internal storage */
        m_units.push_back(std::move(unit));
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::clear()
    {
        m_units.clear();
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> Factory<ObjectType>::generateFromUnits(const std::vector<std::string>& unitKeys) const
    {
        /* We start with an empty pipeline */
        Pipeline<ObjectType> pipeline;

        for (int i = 0; i < unitKeys.size(); i++)
        {
            /* We generate a processor... */
            std::unique_ptr<Processor> processor = m_units[i]->generate(unitKeys[i]);

            /* ... And add it to the pipeline */
            pipeline.append(std::move(processor));
        }

        /* We return the finished pipeline */
        return pipeline;
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::serialize(Writer& writer) const
    {
        /*
        * We write the type of the factory as simply "Factory" without its template
        * arguments, as this information can be retrieved from context.
        */
        writer.write("type", std::string("Factory"));
        writer.write("units", m_units);
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::deserialize(const Reader& reader)
    {
        /* We initialize a vector for storing deserialized units */
        std::vector<std::unique_ptr<Unit>> units;

        /* Then we create a reader for each unit to deserialize */
        std::vector<OT::Reader> unitReaders = reader.createReadersFor("units");

        /* And we loop through each unit and deserialize it */
        for (const auto& unitReader : unitReaders)
        {
            /* We retrieve the unit type */
            std::string unitType = unitReader.read<std::string>("type");

            /*
            * We initialize a null pointer for the unit. The pointer will be
            * overriden in the following if statement.
            */
            std::unique_ptr<Serializable> unit = nullptr;

            /*
            * If the unit is a WrapperUnit, we need to collect some information on
            * its internal unit before instantiating it.
            */
            if (unitType == "WrapperUnit")
            {
                /*
                * We first determine whether the WrapperUnit has an internal unit
                * with the "hasInternalUnit" boolean flag. If it does, then we have
                * enough information to instantiate the WrapperUnit, so we proceed
                * and create a new, empty WrapperUnit using the Instantiator utility
                * class.
                */
                if (unitReader.read<bool>("hasInternalUnit"))
                {
                    /* We retrieve the type of the internal unit */
                    Reader internalUnitReader = unitReader.createReaderFor("internalUnit");
                    std::string internalUnitType = internalUnitReader.read<std::string>("type");

                    /* And instantiate an appropriate WrapperUnit for it */
                    unit = Instantiator::instantiateWrapperUnit(internalUnitType, typeid(ObjectType));
                }

                /*
                * Otherwise, we do not have enough information to deserialize the
                * WrapperUnit, so we throw a runtime error exception.
                */
                else
                    throw std::runtime_error("Empty WrapperUnit: could not deserialize the factory since at least one unit is an empty WrapperUnit.");
            }

            /*
            * If the unit is not a WrapperUnit, we just instantiate it from its type
            * using the Instantiator utility class.
            */
            else
                unit = Instantiator::instantiateUnit(unitType);

            /*
            * We test if the unit is compatible with the factory's internal Unit
            * type. It will always be the case when the top reader reads from a
            * valid Serialized object obtained from the serialization of a valid
            * factory. However, if the Serialized object was obtained from another
            * source that can be modified at runtime (e.g. a file), then this
            * guarantee might no longer hold, which justifies the test.
            * 
            * To test if the unit is of a compatible type, we simply attempt to
            * convert the underlying object to the factory's internal Unit type with
            * dynamic casting. If we succeed, then we know the unit is compatible,
            * so we add it to the factory. Otherwise, the unit is not compatible and
            * cannot be added to the factory, so we throw a runtime error exception.
            */
            if (auto maybeUnit = dynamic_cast<Unit*>(unit.get()))
            {
                /*
                * If the unit is compatible, we add it to the factory. We have to
                * use raw pointers for this and manually pass the object into its
                * target unique pointer since dynamic casting is not compatible with
                * exclusive ownership.
                *
                * Although this procedure is necessary for maintaining flexibility
                * with types during deseralization, it entails releasing the unique
                * pointer 'maybeUnit' for a brief moment, which introduces a risk of
                * memory leak. To mitigate this risk, we only release the pointer at
                * the very last moment, i.e. right before passing its target to the
                * casted pointer.
                */
                std::unique_ptr<Unit> castedUnit(nullptr);
                unit.release();
                castedUnit.reset(maybeUnit);

                /* Then we deserialize data into the casted unit */
                castedUnit->deserialize(unitReader);

                /* Finally, we add the unit to the result vector */
                units.push_back(std::move(castedUnit));
            }

            /*
            * If the unit is not compatible, we stop here and throw a runtime error
            * exception.
            */
            else
                throw std::runtime_error("Incompatible unit: could not deserialize the factory since at least one unit is not compatible.");
        }

        /*
        * Finally, once all units are deserialized, we replace the factory's
        * internal vector of units with the new one.
        */
        m_units = std::move(units);
    }
}