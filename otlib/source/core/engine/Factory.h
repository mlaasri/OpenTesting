/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <string>
#include <vector>

#include "Pipeline.h"
#include "Generator.h"
#include "../../utility/Enumerator.h"
#include "../../utility/serialization/Serializable.h"

namespace OT
{
    /**
    * \class Factory Factory.h
    * A generator of Pipeline objects for processing other objects.
    * 
    * Derived classes must implement the Pipeline generation mechanism. The easiest
    * way to do so is to use a fundamental tool that is built in the Factory class:
    * the Unit subclass. Note that one can always implement a custom mechanism if
    * preferred, and ignore the Unit-related attributes and methods in this class.
    * 
    * A Unit is an elementary block of a Factory that can generate a
    * Pipeline::Processor object, i.e. the elementary block of a Pipeline. In that
    * sense, Unit-based factories and pipelines work hand in hand, the elements of
    * one generating the elements of the other. One can therefore derive from the
    * Unit class and just implement the generation of each single Processor, with
    * the Factory class taking care of chaining all the processors together into a
    * Pipeline.
    *
    * Units work with their individual keys, which are called "unit keys". Derived
    * classes can implement a way to split a factory key into multiple unit keys to
    * generate a Pipeline and its elements, or simply pass the same factory key to
    * all units and implement their parsing as best fits. The former version is more
    * common in OpenTesting. For example, a simple delimiting character mechanism is
    * used in the KeyDelimitedFactory derived class to split an initial key into
    * multiple unit keys.
    */
    template<class ObjectType>
    class Factory :
        public Generator<Pipeline<ObjectType>>
    {
    public:

        /** A shorthand for Pipeline::Processor */
        typedef typename Pipeline<ObjectType>::Processor Processor;

        /**
        * \class Factory Factory.h
        * A Processor Generator.
        */
        class Unit :
            public Generator<std::unique_ptr<Processor>>,
            public Serializable
        {};

        /**
        * Returns the internal units of the Factory.
        */
        const std::vector<std::unique_ptr<Unit>>& getUnits() const;

        /**
        * Returns the sets of keys that is supported by each Unit. The returned
        * object is a vector where one element correspond to the set of keys
        * supported by the Unit at the same position in the Factory.
        */
        std::vector<std::set<std::string>> getKeysPerUnit() const;

        /**
        * Returns all the possible combinations of individual unit keys that can be
        * sent the Factory's units to generate a Pipeline. These combinations are
        * computed using a simple Cartesian product. For example, if the Factory
        * contains two units with one supporting the keys "K1" and "K2" and one
        * supporting "KA" and "KB", then this method will return the 4 combinations
        * ("K1", "KA"), ("K1", "KB"), ("K2", "KA"), and ("K2", "KB").
        *
        * This method can be used to compute the set of all possible keys that can
        * be sent to the Factory itself. If the Factory just splits its own key into
        * unit keys based on a delimiter for example, which is a typical mechanism
        * implemented in the KeyDelimitedFactory class, then joining each set of
        * unit keys as returned by this method would lead to the set of all valid
        * keys supported by the Factory. If '-' was used as a delimiter in the
        * example above for instance, then the Factory's valid keys would be
        * "K1-KA", "K1-KB", "K2-K1", and "K2-KB".
        */
        std::vector<std::vector<std::string>> getAllUnitKeysCombinations() const;

        /**
        * Adds a Unit at the end of the Factory.
        *
        * Note that the pointer given in argument will be moved to the Factory's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the Factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void append(std::unique_ptr<Unit> unit);

        /**
        * Removes and destroys all units from the Factory.
        */
        void clear();

        /**
        * Dispatches each key to its corresponding Unit so they all generate one
        * Pipeline::Processor each, and chains all resulting processors into a
        * Pipeline. Note that each key is sent to the Unit at the same position in
        * the Factory as the key in the vector argument, i.e. the first key in the
        * vector passed in argument will be sent to the first Unit, and so on.
        * @param[in] unitKeys The individual keys to send to each Unit. The size of
        *   this vector must match exactly the number of units in the Factory, and
        *   each key must be valid for its target Unit.
        */
        Pipeline<ObjectType> generateFromUnits(const std::vector<std::string>& unitKeys) const;

    private:

        /** The Factory's units */
        std::vector<std::unique_ptr<Unit>> m_units;
    };

    template<class ObjectType>
    inline const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& Factory<ObjectType>::getUnits() const
    {
        return m_units;
    }

    template<class ObjectType>
    inline std::vector<std::set<std::string>> Factory<ObjectType>::getKeysPerUnit() const
    {
        /* We list and add all the keys for each unit */
        std::vector<std::set<std::string>> unitKeys;
        for (const auto& unit : m_units)
            unitKeys.push_back(unit->getKeys());
        return unitKeys;
    }

    template<class ObjectType>
    inline std::vector<std::vector<std::string>> Factory<ObjectType>::getAllUnitKeysCombinations() const
    {
        /* We compute the Cartesian product across all possible unit keys. */
        return Enumerator::cartesianProduct<std::set<std::string>, std::vector<std::string>>(getKeysPerUnit());
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::append(std::unique_ptr<Unit> unit)
    {
        /* We move the pointer into the Factory's internal storage */
        m_units.push_back(std::move(unit));
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::clear()
    {
        m_units.clear();
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> Factory<ObjectType>::generateFromUnits(const std::vector<std::string>& unitKeys) const
    {
        /* We start with an empty pipeline */
        Pipeline<ObjectType> pipeline;

        for (int i = 0; i < unitKeys.size(); i++)
        {
            /* We generate a processor... */
            std::unique_ptr<Processor> processor = m_units[i]->generate(unitKeys[i]);

            /* ... And add it to the pipeline */
            pipeline.append(std::move(processor));
        }

        /* We return the finished pipeline */
        return pipeline;
    }
}