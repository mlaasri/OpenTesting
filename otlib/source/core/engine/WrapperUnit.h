/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>

#include "Factory.h"
#include "../../utility/serialization/Instantiator.h"

namespace OT
{
    /**
    * \class WrapperUnit WrapperUnit.h
    * A Factory::Unit that wraps another unit of a different type inside so that the
    * latter can be used in factories with the same object type as the WrapperUnit.
    * The object type of the WrapperUnit must be a descendant of that of its
    * internal unit. If it does not, the code will not compile.
    * 
    * The WrapperUnit class addresses the following scenario: a unit whose object
    * type is A cannot be natively used in a factory whose object type is B, even if
    * B derives from A. By wrapping the unit into a WrapperUnit whose object type is
    * B, it becomes possible to add it to the factory. In that way, the WrapperUnit
    * class provides downward compatibility (from A down to B) so units can be used
    * across object types, provided the object types are compatible (i.e. one is an
    * ancestor of the other).
    * 
    * The WrapperUnit owns its internal unit and defers every function call to it.
    * The WrapperUnit::Processor that the unit generates also owns an internal
    * processor and defers its calls to it. The overhead that the WrapperUnit class
    * adds to its internal unit consists of these two layers of indirection only.
    */
    template<class BaseObjectType, class DerivedObjectType>
    class WrapperUnit :
        public Factory<DerivedObjectType>::Unit
    {
    public:

        /**
        * \class Processor WrapperUnit.h
        * A Pipeline::Processor object that wraps another processor of a different
        * type inside so the latter can be used in factories with the same object
        * type as the WrapperUnit::Processor. The WrapperUnit::Processor simply
        * defers its calls to its internal processor.
        */
        class Processor :
            public Pipeline<DerivedObjectType>::Processor
        {
        public:

            /**
            * Creates a WrapperUnit::Processor that wraps the processor given
            * in argument.
            * 
            * The WrapperUnit::Processor will take ownership of the latter, i.e. the
            * pointer to the processor given in argument will be moved to the
            * WrapperUnit::Processor's internal storage, so it should not be
            * accessed anymore after the WrapperUnit::Processor is created.
            * @param[in] processor A pointer to the processor to wrap. The pointer
            *   will be moved inside the WrapperUnit::Processor by this method, so
            *   it should not be accessed anymore after this method is called.
            */
            Processor(std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> processor);

            /**
            * Calls the internal processor on the given object.
            * @param[out] object The object to process. Its class must derive from
            *   the object type of the internal processor.
            */
            void process(DerivedObjectType& object) const;

        private:

            /** The internal processor wrapped in the WrapperUnit::Processor */
            std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> m_internalProcessor;
        };

        /**
        * Creates a WrapperUnit that wraps the unit given in argument.
        *
        * The WrapperUnit will take ownership of the latter, i.e. the pointer to the
        * unit given in argument will be moved to the WrapperUnit's internal
        * storage, so it should not be accessed anymore after the WrapperUnit is
        * created.
        * @param[in] unit A pointer to the unit to wrap. The pointer will be moved
        *   inside the WrapperUnit by this constructor, so it should not be accessed
        *   anymore after this constructor is called.
        */
        WrapperUnit(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit);

        /**
        * Returns the set of keys supported by the unit, which is exactly the same
        * as the set of keys supported by the internal unit.
        */
        std::set<std::string> getKeys() const override;

        /**
        * Returns the number of keys supported by the unit, which is exactly the
        * same as the number of keys supported by the internal unit.
        */
        size_t getNumKeys() const override;

        /**
        * Returns true if the key given in argument is a valid key for the unit and
        * false otherwise, i.e. if it is a valid key for the internal unit.
        *
        * This method just defers its call to the method of the same name from the
        * internal unit.
        * @param[in] key The key to check the validity of.
        */
        bool isValidKey(const std::string& key) const override;

        /**
        * Calls the internal unit with the given key to generate a processor, wraps
        * the generated processor into a WrapperUnit::Processor, and returns the
        * latter.
        *
        * The key is transferred directly to the internal unit, so it must respect
        * the format defined in the documentation of the internal unit's getKeys()
        * method. If it does not, this method is likely to throw an exception.
        * @param[in] key The key to transfer to the internal unit. It must respect
        *   the format defined in the documentation of the internal unit's
        *   getKeys() method.
        */
        std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> generate(const std::string& key) const override;

        /**
        * Retrieves all possible keys for the internal unit and uses the one at the
        * given index to generate a new WrapperUnit::Processor.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as returned
        *   by the getKeys() method.
        */
        std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> generateFromIndex(int keyIndex) const override;

        /** Returns a pointer reference to the internal unit. */
        std::unique_ptr<typename Factory<BaseObjectType>::Unit>& getInternalUnit();

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    private:

        /**
        * Forward declaration of Reader as a friend class so readers can access the
        * private, default constructor of the WrapperUnit class.
        */
        friend class Reader;

        /**
        * Creates an empty WrapperUnit with no internal unit.
        * 
        * The sole purpose of this constructor is for the Reader to initialize an
        * empty WrapperUnit before populating its content (Reader objects require
        * Serializable objects to be default-constructible). It is not publicly
        * accessible because the empty unit it constructs in unsuable in itself and
        * needs to be populated.
        */
        WrapperUnit();

        /** The internal unit wrapped in the WrapperUnit */
        std::unique_ptr<typename Factory<BaseObjectType>::Unit> m_internalUnit;
    };

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::Processor::Processor(std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> processor) :

        /*
        * The WrapperUnit::Processor takes ownership of the processor and moves the
        * pointer inside its storage.
        */
        m_internalProcessor(std::move(processor))
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::Processor::process(DerivedObjectType & object) const
    {
        /*
        * We just transfer the call to the internal processor. This is where it is
        * necessary that the WrapperUnit's object type derives from the internal
        * unit's object type: the processor that the latter generates must be able
        * to process the derived object type.
        */
        m_internalProcessor->process(object);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::WrapperUnit(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit) :

        /*
        * The WrapperUnit takes ownership of the unit and moves the pointer inside
        * its storage.
        */
        m_internalUnit(std::move(unit))
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline std::set<std::string> WrapperUnit<BaseObjectType, DerivedObjectType>::getKeys() const
    {
        /* We just transfer the call to the internal unit. */
        return m_internalUnit->getKeys();
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline size_t WrapperUnit<BaseObjectType, DerivedObjectType>::getNumKeys() const
    {
        /* We just transfer the call to the internal unit. */
        return m_internalUnit->getNumKeys();
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline bool WrapperUnit<BaseObjectType, DerivedObjectType>::isValidKey(const std::string& key) const
    {
        /* We just transfer the call to the internal unit. */
        return m_internalUnit->isValidKey(key);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> WrapperUnit<BaseObjectType, DerivedObjectType>::generate(const std::string& key) const
    {
        /* We generate a processor with the internal unit and wrap it */
        auto processor = m_internalUnit->generate(key);
        return std::make_unique<Processor>(std::move(processor));
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> WrapperUnit<BaseObjectType, DerivedObjectType>::generateFromIndex(int keyIndex) const
    {
        /* We generate a processor with the internal unit and wrap it */
        auto processor = m_internalUnit->generateFromIndex(keyIndex);
        return std::make_unique<Processor>(std::move(processor));
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Factory<BaseObjectType>::Unit>& WrapperUnit<BaseObjectType, DerivedObjectType>::getInternalUnit()
    {
        return m_internalUnit;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::serialize(Writer& writer) const
    {
        writer.write("type", std::string("WrapperUnit"));
        writer.write("internalUnit", *m_internalUnit);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::deserialize(const Reader& reader)
    {
        /* We start by creating a subreader for the internal unit */
        Reader subreader = reader.createReaderFor("internalUnit");

        /*
        * Then we initialize the internal unit to a default object using the
        * Instantiator utility class.
        */
        std::string internalUnitType = subreader.read<std::string>("type");
        std::unique_ptr<Serializable> unit = Instantiator::instantiate(internalUnitType);

        /* Finally, we deserialize data into it */
        unit->deserialize(subreader);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::WrapperUnit() :
        m_internalUnit(nullptr)
    {}
}