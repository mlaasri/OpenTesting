/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>

#include "Factory.h"
#include "../../config/SpecialKeys.h"
#include "InactiveProcessor.h"
#include "../../utility/serialization/Instantiator.h"

namespace OT
{
    /**
    * \class WrapperUnit WrapperUnit.h
    * A Factory::Unit that wraps another unit of a different type inside so that the
    * latter can be used in factories with the same object type as the WrapperUnit.
    * The object type of the WrapperUnit must be a descendant of that of its
    * internal unit. If it does not, the code will not compile.
    * 
    * The WrapperUnit class addresses the following scenario: a unit whose object
    * type is A cannot be natively used in a factory whose object type is B, even if
    * B derives from A. By wrapping the unit into a WrapperUnit whose object type is
    * B, it becomes possible to add it to the factory. In that way, the WrapperUnit
    * class provides downward compatibility (from A down to B) so units can be used
    * across object types, provided the object types are compatible (i.e. one is an
    * ancestor of the other).
    * 
    * The WrapperUnit owns its internal unit and defers every function call to it.
    * The WrapperUnit::Processor that the unit generates also owns an internal
    * processor and defers its calls to it. The overhead that the WrapperUnit class
    * adds to its internal unit consists of these two layers of indirection only.
    */
    template<class BaseObjectType, class DerivedObjectType>
    class WrapperUnit :
        public Factory<DerivedObjectType>::Unit
    {
    public:

        /**
        * \class Processor WrapperUnit.h
        * A Pipeline::Processor object that wraps another processor of a different
        * type inside so the latter can be used in factories with the same object
        * type as the WrapperUnit::Processor. The WrapperUnit::Processor simply
        * defers its calls to its internal processor.
        */
        class Processor :
            public Pipeline<DerivedObjectType>::Processor
        {
        public:

            /**
            * Creates a WrapperUnit::Processor that wraps the processor given
            * in argument.
            * 
            * The WrapperUnit::Processor will take ownership of the latter, i.e. the
            * pointer to the processor given in argument will be moved to the
            * WrapperUnit::Processor's internal storage, so it should not be
            * accessed anymore after the WrapperUnit::Processor is created.
            * @param[in] processor A pointer to the processor to wrap. The pointer
            *   will be moved inside the WrapperUnit::Processor by this method, so
            *   it should not be accessed anymore after this method is called.
            */
            Processor(std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> processor);

            /**
            * Calls the internal processor on the given object.
            * @param[out] object The object to process. Its class must derive from
            *   the object type of the internal processor.
            */
            void process(DerivedObjectType& object) const;

        private:

            /** The internal processor wrapped in the WrapperUnit::Processor */
            std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> m_internalProcessor;
        };

        /**
        * Creates an empty WrapperUnit with no internal unit.
        * 
        * Until provided with an internal unit through its wrap() method, the
        * WrapperUnit will have no effect and always generate an InactiveProcessor.
        */
        WrapperUnit();

        /**
        * Creates a WrapperUnit that wraps the unit given in argument.
        *
        * The WrapperUnit will take ownership of the latter, i.e. the pointer to the
        * unit given in argument will be moved to the WrapperUnit's internal
        * storage, so it should not be accessed anymore after the WrapperUnit is
        * created.
        * @param[in] unit A pointer to the unit to wrap. The pointer will be moved
        *   inside the WrapperUnit by this constructor, so it should not be accessed
        *   anymore after this constructor is called.
        */
        WrapperUnit(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit);

        /**
        * Returns the set of keys supported by the unit.
        * 
        * If the WrapperUnit contains an internal unit, then the keys it supports
        * are exactly the same as those of that unit. Otherwise, if the WrapperUnit
        * is empty (e.g. if it was created from its default constructor), then the
        * only key it supports is the null key.
        */
        std::set<std::string> getKeys() const override;

        /** Returns the number of keys supported by the unit. */
        size_t getNumKeys() const override;

        /**
        * Returns true if the key given in argument is a valid key for the unit and
        * false otherwise.
        * @param[in] key The key to check the validity of.
        */
        bool isValidKey(const std::string& key) const override;

        /**
        * If it exists, calls the internal unit with the given key to generate a
        * processor, wraps the generated processor into a WrapperUnit::Processor,
        * and returns the latter. In this case, the key is transferred directly to
        * the internal unit, so it must respect the format defined in the
        * documentation of the internal unit's getKeys() method. If it does not,
        * this method is likely to throw an exception.
        * 
        * If the WrapperUnit is empty and contains no internal unit (e.g. if it was
        * created from its default constructor), then this method simply returns an
        * InactiveProcessor that does not perform any operation.
        * @param[in] key The key to transfer to the internal unit, if it exists. In
        *   this case, it must respect the format defined in the documentation of
        *   the internal unit's getKeys() method. If the WrapperUnit does not
        *   contain any internal unit (e.g. if it was created from its default
        *   constructor), then it must be equal to the null key
        *   OPENTESTING_NULL_KEY, in which case the unit will generate an
        *   InactiveProcessor that does not perform any operation.
        */
        std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> generate(const std::string& key) const override;

        /**
        * Retrieves all keys supported by the unit as defined by the getKeys()
        * method and uses the one at the given index to generate a new
        * WrapperUnit::Processor.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as returned
        *   by the getKeys() method.
        */
        std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> generateFromIndex(int keyIndex) const override;

        /** Returns a pointer reference to the internal unit. */
        std::unique_ptr<typename Factory<BaseObjectType>::Unit>& getInternalUnit();

        /**
        * Wraps the given unit inside the WrapperUnit. If a unit was already wrapped
        * inside, it will be destroyed and replaced by the new one.
        *
        * The WrapperUnit will take ownership of the latter, i.e. the pointer to the
        * unit given in argument will be moved to the WrapperUnit's internal
        * storage, so it should not be accessed anymore after the WrapperUnit is
        * created.
        * @param[in] unit A pointer to the unit to wrap. The pointer will be moved
        *   inside the WrapperUnit, so it should not be accessed anymore after this
        *   method is called.
        */
        void wrap(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit);

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    private:

        /** The internal unit wrapped in the WrapperUnit */
        std::unique_ptr<typename Factory<BaseObjectType>::Unit> m_internalUnit;
    };

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::Processor::Processor(std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> processor) :

        /*
        * The WrapperUnit::Processor takes ownership of the processor and moves the
        * pointer inside its storage.
        */
        m_internalProcessor(std::move(processor))
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::Processor::process(DerivedObjectType & object) const
    {
        /*
        * We just transfer the call to the internal processor. This is where it is
        * necessary that the WrapperUnit's object type derives from the internal
        * unit's object type: the processor that the latter generates must be able
        * to process the derived object type.
        */
        m_internalProcessor->process(object);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::WrapperUnit() :
        m_internalUnit(nullptr)
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::WrapperUnit(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit) :

        /*
        * The WrapperUnit takes ownership of the unit and moves the pointer inside
        * its storage.
        */
        m_internalUnit(std::move(unit))
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline std::set<std::string> WrapperUnit<BaseObjectType, DerivedObjectType>::getKeys() const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)

            /* ... We simply transfer the call to it. */
            return m_internalUnit->getKeys();

        /* Otherwise, we return the null key */
        return { OPENTESTING_NULL_KEY };
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline size_t WrapperUnit<BaseObjectType, DerivedObjectType>::getNumKeys() const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)

            /* ... We simply transfer the call to it. */
            return m_internalUnit->getNumKeys();

        /* Otherwise, we return 1 since the unit only supports the null key */
        return 1;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline bool WrapperUnit<BaseObjectType, DerivedObjectType>::isValidKey(const std::string& key) const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)

            /* ... We simply transfer the call to it. */
            return m_internalUnit->isValidKey(key);

        /*
        * Otherwise, we compare the key with the null key, which is the only key
        * supported by the unit in this case.
        */
        return key == OPENTESTING_NULL_KEY;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> WrapperUnit<BaseObjectType, DerivedObjectType>::generate(const std::string& key) const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)
        {
            /* ... We generate a processor with the internal unit and wrap it */
            auto processor = m_internalUnit->generate(key);
            return std::make_unique<Processor>(std::move(processor));
        }

        /*
        * Otherwise, we generate an inactive processor so that questions will be
        * left untouched.
        */
        return std::make_unique<InactiveProcessor<DerivedObjectType>>();
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> WrapperUnit<BaseObjectType, DerivedObjectType>::generateFromIndex(int keyIndex) const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)
        {
            /* ... We generate a processor with the internal unit and wrap it */
            auto processor = m_internalUnit->generateFromIndex(keyIndex);
            return std::make_unique<Processor>(std::move(processor));
        }

        /*
        * Otherwise, we generate an inactive processor so that questions will be
        * left untouched.
        */
        return std::make_unique<InactiveProcessor<DerivedObjectType>>();
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Factory<BaseObjectType>::Unit>& WrapperUnit<BaseObjectType, DerivedObjectType>::getInternalUnit()
    {
        return m_internalUnit;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::wrap(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit)
    {
        m_internalUnit = std::move(unit);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::serialize(Writer& writer) const
    {
        /*
        * We write the type of the WrapperUnit as simply "WrapperUnit" without its
        * template arguments, as this information can be retrieved from context.
        */
        writer.write("type", std::string("WrapperUnit"));

        /*
        * To be able to serialize and deserialize the WrapperUnit even if it does
        * not have an internal unit, we store an additional boolean flag
        * "hasInternalUnit" indicating whether the internal unit pointer is null. If
        * it is, then we simply do not pursue with its serialization.
        */
        if (m_internalUnit)
        {
            writer.write("hasInternalUnit", true);
            writer.write("internalUnit", *m_internalUnit);

            /*
            * To facilitate the deserialization process, we store the type of the
            * internal unit at the top level of the Serialized object inside an
            * additional field named "internalUnitType".
            * 
            * A quick and easy way to retrieve this type information is to dump the
            * Serialized object in its current state into a string since it already
            * contains the result of the serialization of the internal unit. This
            * operation adds an extra computing cost to the serialization of the
            * WrapperUnit itself, but it greatly facilitates the design of its
            * serialization process. The next block of lines performs this operation
            * and retrieves the type of the internal unit as a string.
            */
            std::string serializedWithoutType = writer.toString();
            Reader internalUnitReader = Reader(serializedWithoutType).createReaderFor("internalUnit");
            std::string internalUnitType = internalUnitReader.read<std::string>("type");

            /*
            * We can now write the type of the internal unit into its dedicated
            * field, which concludes the serialization.
            */
            writer.write("internalUnitType", internalUnitType);
        }
        else
            writer.write("hasInternalUnit", false);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::deserialize(const Reader& reader)
    {
        /*
        * We first retrieve the information on whether the WrapperUnit has an
        * internal unit with the "hasInternalUnit" boolean flag. If it does, then we
        * deserialize the internal unit.
        */
        if (reader.read<bool>("hasInternalUnit"))
        {
            /* We start by creating a subreader for the internal unit */
            Reader subreader = reader.createReaderFor("internalUnit");

            /*
            * Then we initialize the internal unit to a default object using the
            * Instantiator utility class.
            */
            std::string internalUnitType = subreader.read<std::string>("type");
            std::unique_ptr<Serializable> unit = Instantiator::instantiate(internalUnitType);

            /* Then we deserialize data into it */
            unit->deserialize(subreader);

            /*
            * Finally, we move the unit into the WrapperUnit. We have to use raw
            * pointers for this and manually pass it to the internal pointer since
            * dynamic casting is not compatible with exclusive ownership.
            * 
            * Although this procedure is necessary for maintaining flexibility with
            * types during deseralization, it entails releasing the unique pointer
            * 'unit' for a brief moment, which introduces a risk of memory leak. To
            * mitigate this risk, we only release the pointer at the very last
            * moment, i.e. right before passing its target to the internal pointer.
            */
            auto castedUnit = dynamic_cast<typename Factory<BaseObjectType>::Unit*>(unit.get());
            unit.release();
            m_internalUnit.reset(castedUnit);
        }

        /*
        * Otherwise, we return immediately and leave the WrapperUnit in its default
        * state, which corresponds exactly to a WrapperUnit with no internal unit.
        */
    }
}