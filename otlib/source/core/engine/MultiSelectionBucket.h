/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <vector>
#include <algorithm>
#include <stdexcept>

#include "Generator.h"
#include "../../config/SpecialKeys.h"
#include "../../config/Delimiters.h"
#include "../../utility/String.h"
#include "../../utility/Enumerator.h"

namespace OT
{
    /**
    * \class MultiSelectionBucket MultiSelectionBucket.h
    * A MultiSelectionBucket is a Generator that is similar to a Bucket, except it
    * returns multiple objects instead of just one. A MultiSelectionBucket always
    * generates the same number of elements, which is called its "selection size".
    *
    * If a MultiSelectionBucket contains fewer objects than its selection size, the
    * only key it supports is the null key, which is a string defined by the macro
    * OPENTESTING_NULL_KEY (which currently evaluates to "N"). Otherwise, it
    * supports any character-delimited string representing a set of valid indices
    * sorted in increasing order as a key to generate a vector of objects. The
    * objects returned will then simply be copies of the objects located at the
    * given indices.
    */
    template<class ObjectType>
    class MultiSelectionBucket :
        public Generator<std::vector<ObjectType>>
    {
    public:

        /** Creates an empty multi-selection bucket. */
        MultiSelectionBucket();

        /**
        * Returns the set of keys supported by the multi-selection bucket.
        *
        * If the bucket does not contain enough objects for a selection to be made,
        * i.e. it contains fewer objects than its selection size, then the only key
        * it supports is the null key OPENTESTING_NULL_KEY ("N"). On the other hand,
        * if the bucket contains enough objects, then the keys it supports are all
        * the strings representing a set of valid indices delimited by the
        * OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY (".") character. The
        * indices must be sorted in increasing order to avoid having multiple keys
        * representing the same set.
        * 
        * For example, if a multi-selection bucket with a selection size of 2
        * contains 3 elements, then it only supports the following keys: "0.1" (the
        * first and second elements are selected), "0.2" (the first and third
        * elements are selected), and "1.2" (the second and third elements are
        * selected). It does not support the key "2.1" because its indices are not
        * in increasing order. This selection (second and third elements) is already
        * accounted for in the key "1.2".
        */
        std::set<std::string> getKeys() const override;

        /** Returns the number of keys supported by the multi-selection bucket. */
        size_t getNumKeys() const override;

        /**
        * Selects multiple objects from the MultiSelectionBucket based on the given
        * key and returns a copy of each. The selection is made without replacement,
        * so the same object cannot be selected twice, except if it is present in
        * multiple copies inside the bucket.
        * 
        * If the bucket does not contain enough objects for a selection to be made,
        * this method will return an empty vector.
        * @param[in] key The key to use to select the objects. If the
        *   multi-selection bucket contains fewer objects than its selection size,
        *   the key must be equal to the null key OPENTESTING_NULL_KEY, in which
        *   case the bucket will return an empty vector. Otherwise, it must be a
        *   string representing a set of valid indices delimited by
        *   OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY and sorted in increasing
        *   increasing order, in which case the bucket will return a vector
        *   containing copies of the objects located at the corresponding indices.
        */
        std::vector<ObjectType> generate(const std::string& key) const override;

        /**
        * Returns the selection size of the multi-selection bucket, i.e. the number
        * of objects to select from the bucket on each generation.
        */
        size_t getSelectionSize() const;

        /** Returns all the objects contained in the multi-selection bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the multi-selection bucket. */
        size_t getSize() const;

        /**
        * Returns true if the multi-selection bucket is empty and false otherwise.
        */
        bool isEmpty() const;

        /**
        * Defines the selection size of the multi-selection bucket, i.e. the number
        * of objects to select from the bucket on each generation.
        * 
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of objects contained in the bucket. Otherwise, the bucket will
        * only generate empty vectors.
        * @param[in] selectionSize The number of objects to select on each
        *   generation.
        */
        void setSelectionSize(size_t selectionSize);

        /**
        * Adds an object to the multi-selection bucket.
        * @param[in] object The object to add.
        */
        void add(const ObjectType& object);

        /**
        * Removes an object from the multi-selection bucket. If the object given in
        * argument is not currently in the bucket, an invalid argument exception is
        * thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the multi-selection bucket. */
        void clear();

    protected:

        /**
        * Regenerates the keys based on the objects contained in the multi-selection
        * bucket.
        */
        void updateKeys();

    private:

        /**
        * The number of objects to select from the multi-selection bucket on each
        * generation.
        */
        size_t m_selectionSize;

        /** The objects contained in the multi-selection bucket. */
        std::vector<ObjectType> m_objects;

        /**
        * The keys supported by the multi-selection bucket in its current state.
        */
        std::set<std::string> m_keys;
    };

    template<class ObjectType>
    inline MultiSelectionBucket<ObjectType>::MultiSelectionBucket() :

        /* By default, we only select one object, just like a regular bucket */
        m_selectionSize(1)
    {
        /*
        * We initialize the keys. This will simply register the null key as the only
        * valid key since the multi-selection bucket is empty for now.
        */
        updateKeys();
    }

    template<class ObjectType>
    inline std::set<std::string> MultiSelectionBucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t MultiSelectionBucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline std::vector<ObjectType> MultiSelectionBucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate an empty vector. */
        if (key == OPENTESTING_NULL_KEY)
            return {};

        /* We initialize a result vector */
        std::vector<ObjectType> result;

        /* We copy each object from the given indices */
        std::vector<std::string> indices = String::split(key, OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY);
        for (const auto& index : indices)
            result.push_back(m_objects[std::stoi(index)]);

        /* We return the result vector */
        return result;
    }

    template<class ObjectType>
    inline size_t MultiSelectionBucket<ObjectType>::getSelectionSize() const
    {
        return m_selectionSize;
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& MultiSelectionBucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t MultiSelectionBucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool MultiSelectionBucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::setSelectionSize(size_t selectionSize)
    {
        /* We make sure the selection size is at least 1 */
        if (selectionSize == 0)
            throw std::invalid_argument("Cannot set the selection size of a multi-selection bucket to 0. It must be at least 1.");

        /* If so, we set the new selection size and update the keys */
        m_selectionSize = selectionSize;
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::add(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the multi-selection bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::updateKeys()
    {
        /*
        * If the bucket does not contain enough objects for a selection to be made
        * (which includes the case of an empty bucket since the selection size is
        * always at least 1), then the only key it supports is the null key.
        */
        if (m_selectionSize > m_objects.size())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports are all the strings representing a valid
        * selection of objects from the bucket.
        */
        else
        {
            /* We list all valid indices for the bucket */
            std::vector<std::string> indicesAsString;
            for (int i = 0; i < m_objects.size(); i++)
                indicesAsString.push_back(std::to_string(i));

            /* Then we enumerate all choices among these indices */
            auto choices = Enumerator::choices<std::vector<std::string>>(indicesAsString, m_selectionSize);

            /*
            * And finally we concatenate each choice with a delimiter to obtain the
            * final keys
            */
            m_keys.clear();
            for (const auto& choice : choices)
                m_keys.insert(String::join(choice, OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY));
        }
    }
}