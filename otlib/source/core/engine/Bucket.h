/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <vector>
#include <algorithm>
#include <stdexcept>
#include <numeric>
#include <random>

#include "Generator.h"
#include "../../config/SpecialKeys.h"
#include "../../config/Delimiters.h"
#include "../../utility/String.h"
#include "../../utility/serialization/Writer.h"
#include "../../utility/Hash.h"

namespace OT
{
    /**
    * \class Bucket Bucket.h
    * A Bucket is a container-based Generator that contains a copy of all the
    * objects it can possibly generate and selects some of them without replacement
    * based on a set of indices passed as a string key. Unless unable to do so, a
    * Bucket always generates the same number of objects, which is called its
    * "selection size". The selection size of a Bucket defaults to 1, but it can be
    * changed at runtime to generate different numbers of objects depending on the
    * context. The selection size must always be at least 1.
    * 
    * For example, a Bucket of strings containing the 5 letters ["A", "B", "C", "D",
    * "E"] and having a selection size of 2 will generate pairs of different letters
    * like "A"-"B", "A"-"C", "B"-"C", etc. The keys to generate these pairs will
    * look like this:
    * - "0.1", which selects the objects at indices 0 and 1, will generate the pair
    *   "A"-"B";
    * - "0.2", which selects the objects at indices 0 and 2, will generate the pair
    *   "A"-"C";
    * - "1.2", which selects the objects at indices 1 and 2, will generate the pair
    *   "B"-"C";
    * - etc.
    * 
    * Note that the selection by the Bucket is entirely index-based, so even though
    * the selection is performed without replacement on the indices, an object can
    * still be selected multiple times if it is present in multiple copies inside
    * the Bucket.
    * 
    * In theory, the total number of possible selections that a Bucket can make is
    * N-choose-S, where N is the number of objects in the Bucket and S its selection
    * size. This quantity also corresponds to the total number of keys the Bucket
    * has to support. Unfortunately, this number grows as O(N^S) when N gets large,
    * which quickly makes key management intractable in practice where many buckets
    * are used simultaneously. Therefore, a Bucket never really supports all
    * possible selections of objects and instead supports a pseudo-random subset of
    * exactly N of these selections. That way, the number of keys the Bucket has to
    * support grows linearly as O(N).
    * 
    * This pseudo-random subset of selections is generated with an internal sampling
    * algorithm that provides two important guarantees:
    * 1. Each object in the Bucket is guaranteed to appear exactly S times in the
    *   subset, i.e. each object has the exact same probability of being selected
    *   (S/N); therefore, despite the decrease in output variability, the overall
    *   distribution of the Bucket's output maintains good stastistical properties;
    * 2. The sampling algorithm uses a seeded pseudo-random number generator, which
    *   ensures the result is always deterministic and only depends on the state of
    *   the Bucket.
    * 
    * In the example above, the Bucket has 10 ways to choose S = 2 letters among the
    * N = 5 without replacement, so in theory, it should support 10 keys. Instead,
    * the sampling algorithm restricts the key space to N = 5 keys only, which
    * halves the number of combinations to consider in and out of the Bucket. As an
    * example, a possible pseudo-random subset of selections that the Bucket could
    * support could be: "A"-"B", "B"-"C", "C"-"D", "D-E", and "E-A", which trivially
    * scans through all adjacent letters in the Bucket as if it was a circular
    * buffer. Note that each letter appears exactly twice in the subset, so the
    * probability of any letter being selected is effectively the same as any other
    * letter (S/N = 2/5), as guaranteed by the sampling algorithm.
    * 
    * Although the sampling algorithm provides clear benefits in reducing the size
    * of the key space, it comes with a small design cost. Behind the scenes, the
    * algorithm requires the objects contained in the Bucket to be serializable with
    * a Writer object. In other words, any template argument used with the Bucket
    * class must be a type that can be serialized with one of the Writer::write()
    * methods. This constraint should not be too limiting, as it allows for types
    * like booleans, integers, strings, vectors of strings, Serializable objects,
    * vectors of Serializable objects, and even the Bucket class itself. See the
    * documentation of the Writer class for an exhaustive list of acceptable types.
    * 
    * For more details on the sampling algorithm, see the documentation of the
    * getKeys() method.
    * 
    * Note that, for greater flexibility and to ensure backward compatibility, a
    * Bucket will actually accept all possible keys from the entire set of valid
    * index-based keys (even those with duplicated indices that instruct to select
    * the same object multiple times, like "0.0") and generate the corresponding
    * output if instructed to. However, its getKeys() method will only return the
    * keys that are part of the pseudo-random subset, and it is recommended to only
    * use those.
    */
    template<class ObjectType>
    class Bucket :
        public Generator<std::vector<ObjectType>>
    {
    public:

        /** Creates an empty bucket with a selection size of 1 by default. */
        Bucket();

        /** Creates an empty bucket with the given selection size. */
        Bucket(size_t selectionSize);

        /**
        * Returns the set of keys supported by the bucket.
        *
        * If a Bucket is empty or it contains fewer objects than its selection size,
        * the only key it supports is the null key, which is a string defined by the
        * macro OPENTESTING_NULL_KEY (which currently evaluates to "N"). Otherwise,
        * the Bucket supports a pseudo-random subset of keys that all respect the
        * following format:
        * - Each key consists of numbers delimited by the
        *   OPENTESTING_DELIMITER_BUCKET_KEY ('.') character;
        * - Each number represents a valid index between 0 and getSize() - 1
        *   included, i.e. "0", "1", "2", etc.;
        * - Each number is unique (so the selection is made without replacement);
        * - The numbers in each key are sorted in increasing order (this constraint
        *   guarantees the unicity of the selections supported by the Bucket; 
        *   without it, permutated keys like "1.2" and "2.1" could be incorrectly
        *   returned as separate keys despite technically representing the exact
        *   same selection);
        * - There are as many numbers in each key as the selection size.
        * 
        * This pseudo-random subset is generated as follows:
        * 1. First, the Bucket is serialized and hashed into an integer that is then
        *   used as a pseudo-random seed; note that the entire Bucket, including its
        *   selection size, have an influence on this seed since the hash is
        *   computed from the Bucket's complete serialization string;
        * 2. Second, the indices of the objects in the Bucket are pseudo-randomly
        *   shuffled with this seed; for example, a Bucket with 4 objects and whose
        *   indices are [0, 1, 2, 3] could produce a shuffled index vector like [2,
        *   0, 3, 1];
        * 3. Finally, a selection window is slided throughout the shuffled index
        *   vector to create the selections and their corresponding keys; the
        *   sliding window has the same size as the selection size S and is slided
        *   as many times as the number of objects N in the Bucket, with the index
        *   vector being treated as a circular buffer at its edges; for example,
        *   sliding a selection window of size S = 2 on the shuffled index vector
        *   [2, 0, 3, 1] would generate the N = 4 index pairs (2, 0), (0, 3),
        *   (3, 1), and (1, 2), which would in turn produce the following 4 keys
        *   after formatting: "0.2", "0.3", "1.3", and "1.2".
        */
        typename Bucket<ObjectType>::KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the bucket. */
        size_t getNumKeys() const override;

        /**
        * Selects objects from the bucket based on the given key and returns a copy
        * of each.
        *
        * The key must respect the format defined in the documentation of the
        * getKeys() method. If it does not, it is likely that an exception will be
        * thrown by this method.
        * @param[in] key The key to use to select the objects. If the bucket is
        *   empty or contains fewer objects than its selection size, the key must be
        *   equal to the null key OPENTESTING_NULL_KEY, in which case the bucket
        *   will return an empty vector. Otherwise, it must be a string respecting
        *   the format defined in the documentation of the getKeys() method, in
        *   which case the bucket will return a vector containing copies of the
        *   objects located at the corresponding indices.
        */
        std::vector<ObjectType> generate(const std::string& key) const override;

        /**
        * Returns the selection size of the bucket, i.e. the number of objects to
        * select from the bucket on each generation.
        */
        size_t getSelectionSize() const;

        /** Returns all the objects contained in the bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the bucket. */
        size_t getSize() const;

        /** Returns true if the bucket is empty and false otherwise. */
        bool isEmpty() const;

        /**
        * Defines the selection size of the bucket, i.e. the number of objects to
        * select from the bucket on each generation.
        * 
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of objects contained in the bucket. Otherwise, the bucket will
        * only generate empty vectors.
        * @param[in] selectionSize The number of objects to select on each
        *   generation. It must be at least 1.
        */
        void setSelectionSize(size_t selectionSize);

        /**
        * Adds an object to the bucket and places it at the end, so the object will
        * be associated with the highest index.
        * @param[in] object The object to add.
        */
        void append(const ObjectType& object);

        /**
        * Removes an object from the bucket. If the object given in argument is not
        * currently in the bucket, an invalid argument exception is thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the bucket. */
        void clear();

    protected:

        /** Regenerates the keys based on the objects contained in the bucket. */
        void updateKeys();

    private:

        /** The number of objects to select from the bucket on each generation. */
        size_t m_selectionSize;

        /** The objects contained in the bucket. */
        std::vector<ObjectType> m_objects;

        /** The keys supported by the bucket in its current state. */
        typename Bucket<ObjectType>::KeyContainerType m_keys;
    };

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket() :

        /* By default, we only select one object */
        Bucket(1)
    {}

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket(size_t selectionSize)
    {
        /*
        * We set the selection size. Note that this call will also initialize the
        * keys. Concretely, it will simply register the null key as the only valid
        * key since the bucket is empty for now.
        */
        setSelectionSize(selectionSize);
    }

    template<class ObjectType>
    inline typename Bucket<ObjectType>::KeyContainerType Bucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline std::vector<ObjectType> Bucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate an empty vector. */
        if (key == OPENTESTING_NULL_KEY)
            return {};

        /* Otherwise, we start parsing the key by splitting it into indices */
        std::vector<std::string> indices = String::split(key, OPENTESTING_DELIMITER_BUCKET_KEY);

        /*
        * We enforce the constraint that the number of indices should match the
        * selection size.
        */
        if (indices.size() != m_selectionSize)
            throw std::invalid_argument("Invalid bucket key: found " + std::to_string(indices.size()) + " indices for a selection size of " + std::to_string(m_selectionSize));

        /* We initialize a result vector */
        std::vector<ObjectType> result;

        /* We copy each object from the given indices */
        for (const auto& index : indices)
            result.push_back(m_objects[std::stoi(index)]);

        /* We return the result vector */
        return result;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSelectionSize() const
    {
        return m_selectionSize;
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& Bucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool Bucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::setSelectionSize(size_t selectionSize)
    {
        /* We make sure the selection size is at least 1 */
        if (selectionSize == 0)
            throw std::invalid_argument("The selection size of a bucket must be at least 1 and cannot be set to 0.");

        /* If so, we set the new selection size and update the keys */
        m_selectionSize = selectionSize;
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::append(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::updateKeys()
    {
        /*
        * If the bucket does not contain enough objects for a selection to be made
        * (which includes the case of an empty bucket since the selection size is
        * always at least 1), then the only key it supports is the null key.
        */
        if (m_selectionSize > m_objects.size())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports form a pseudo-random subset of all the
        * strings representing a valid selection of objects from the bucket.
        */
        else
        {
            /*
            * We begin with an edge case: if the selection size S is equal to N,
            * then the set of all possible keys reduces to one single element: the
            * key that selects all objects in the bucket. In this case, we simply
            * register this key as the unique key for the bucket.
            */
            if (m_selectionSize == m_objects.size())
            {
                std::vector<std::string> allIndicesAsString;
                for (int i = 0; i < m_objects.size(); i++)
                    allIndicesAsString.push_back(std::to_string(i));
                m_keys = { String::join(allIndicesAsString, OPENTESTING_DELIMITER_BUCKET_KEY) };
            }

            /*
            * For any other value S < N, we know the set of all possible keys
            * contains at least N elements, so we can pseudo-randomly sample N keys
            * from it.
            */
            else
            {
                /*
                * We serialize and hash the bucket to generate a pseudo-random seed.
                * Since we only use the hash as a seed, we do not need to use a
                * sophisticated hashing function, so we use DJBX33A which is simple
                * and very fast to compute.
                */
                Writer writer;
                writer.write("selectionSize", m_selectionSize);
                writer.write("objects", m_objects);
                size_t seed = Hash::DJBX33A(writer.toString());

                /* We list all valid indices for the bucket */
                std::vector<size_t> indices(m_objects.size());
                std::iota(indices.begin(), indices.end(), 0);

                /* We pseudo-randomly shuffle the indices using the seed */
                std::shuffle(indices.begin(), indices.end(), std::default_random_engine(seed));

                /*
                * And then we slide a window across the index vector to construct
                * the keys.
                */
                m_keys.clear();
                for (int s = 0; s < m_objects.size(); s++)
                {
                    /* We collect all the indices to add to the given key */
                    std::vector<size_t> indicesInKey(m_selectionSize);
                    for (int i = 0; i < m_selectionSize; i++)
                        indicesInKey[i] = indices[(s + i) % m_objects.size()];

                    /*
                    * Then we sort the indices. Note that we sort them as integers
                    * and not as strings to avoid errors related to comparisons of
                    * indices with different numbers of digits like "1" and "10".
                    */
                    std::sort(indicesInKey.begin(), indicesInKey.end());

                    /*
                    * Finally, we convert the indices as strings and construct the
                    * key.
                    */
                    std::vector<std::string> indicesAsString(m_selectionSize);
                    for (int i = 0; i < m_selectionSize; i++)
                        indicesAsString[i] = std::to_string(indicesInKey[i]);
                    m_keys.insert(m_keys.end(), String::join(indicesAsString, OPENTESTING_DELIMITER_BUCKET_KEY));
                }
            }
        }
    }
}