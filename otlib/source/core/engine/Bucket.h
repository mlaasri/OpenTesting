/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <vector>
#include <algorithm>
#include <stdexcept>

#include "Generator.h"
#include "../../config/SpecialKeys.h"
#include "../../config/Delimiters.h"
#include "../../utility/String.h"
#include "../../utility/Enumerator.h"

namespace OT
{
    /**
    * \class Bucket Bucket.h
    * A Bucket is a container-based Generator that contains a copy of all the
    * objects it can possibly generate and returns a selection of objects based on
    * a set of indices passed as a string key. Unless unable to do so, a Bucket
    * always generates the same number of objects, which is called its "selection
    * size". The selection size of a Bucket defaults to 1, but it can be changed at
    * runtime to generate different numbers of objects depending on the context. The
    * selection size must always be at least 1.
    * 
    * Note that the selection is made without replacement, so the same object cannot
    * be selected twice, except if it is present in multiple copies inside the
    * bucket.
    * 
    * If a Bucket is empty or it contains fewer objects than its selection size, the
    * only key it supports is the null key, which is a string defined by the macro
    * OPENTESTING_NULL_KEY (which currently evaluates to "N"). In this case, the
    * Bucket will always return an empty vector. Otherwise, if a Bucket is not empty
    * and contains enough objects for a selection to be made, then the keys it
    * supports are all the strings respecting the following format:
    * - The key must consist of numbers delimited by the
    *   OPENTESTING_DELIMITER_BUCKET_KEY ('.') character;
    * - Each number must represent a valid index between 0 and getSize() - 1
    *   included, i.e. "0", "1", "2", etc.;
    * - Each number must be unique;
    * - The numbers must be sorted in increasing order;
    * - There must be as many numbers as the selection size.
    * 
    * In this case, the Bucket will simply return copies of the objects located at
    * the given indices. This implies that the size of the returned vector is always
    * guaranteed to be equal to the selection size in this situation.
    * 
    * For example, if a bucket contains 3 objects and has a selection size of 2,
    * then it supports exactly the following keys:
    * - "0.1"(selects the first and second objects)
    * - "0.2" (selects the first and third objects),
    * - and "1.2" (selects the second and third objects).
    * 
    * Notice that the bucket does not support the key "2.1" because its indices are
    * not in increasing order. This selection (second and third objects) is already
    * accounted for by the key "1.2".
    */
    template<class ObjectType>
    class Bucket :
        public Generator<std::vector<ObjectType>>
    {
    public:

        /** Creates an empty bucket with a selection size of 1 by default. */
        Bucket();

        /** Creates an empty bucket with the given selection size. */
        Bucket(size_t selectionSize);

        /**
        * Returns the set of keys supported by the bucket.
        *
        * If a Bucket is empty or it contains fewer objects than its selection size,
        * the only key it supports is the null key, which is a string defined by the
        * macro OPENTESTING_NULL_KEY (which currently evaluates to "N"). Otherwise,
        * the keys it supports are all the strings respecting the following format:
        * - The key must consist of numbers delimited by the
        *   OPENTESTING_DELIMITER_BUCKET_KEY ('.') character;
        * - Each number must represent a valid index between 0 and getSize() - 1
        *   included, i.e. "0", "1", "2", etc.;
        * - Each number must be unique;
        * - The numbers must be sorted in increasing order;
        * - There must be as many numbers as the selection size.
        * 
        * For example, if a Bucket contains 3 objects and has a selection size of 2,
        * then it supports exactly the following keys:
        * - "0.1"(selects the first and second objects)
        * - "0.2" (selects the first and third objects),
        * - and "1.2" (selects the second and third objects).
        * 
        * Notice that the bucket does not support the key "2.1" because its indices are
        * not in increasing order. This selection (second and third objects) is already
        * accounted for by the key "1.2".
        */
        std::set<std::string> getKeys() const override;

        /** Returns the number of keys supported by the bucket. */
        size_t getNumKeys() const override;

        /**
        * Selects objects from the bucket based on the given key and returns a copy
        * of each. The selection is made without replacement, so the same object
        * cannot be selected twice, except if it is present in multiple copies
        * inside the bucket.
        *
        * The key must respect the format defined in the documentation of the
        * getKeys() method. If it does not, it is likely that an exception will be
        * thrown by this method.
        * @param[in] key The key to use to select the objects. If the bucket is
        *   empty or contains fewer objects than its selection size, the key must be
        *   equal to the null key OPENTESTING_NULL_KEY, in which case the bucket
        *   will return an empty vector. Otherwise, it must be a string respecting
        *   the format constraints defined in the documentation of the getKeys()
        *   method, in which case the bucket will return a vector containing copies
        *   of the objects located at the corresponding indices.
        */
        std::vector<ObjectType> generate(const std::string& key) const override;

        /**
        * Returns the selection size of the bucket, i.e. the number of objects to
        * select from the bucket on each generation.
        */
        size_t getSelectionSize() const;

        /** Returns all the objects contained in the bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the bucket. */
        size_t getSize() const;

        /** Returns true if the bucket is empty and false otherwise. */
        bool isEmpty() const;

        /**
        * Defines the selection size of the bucket, i.e. the number of objects to
        * select from the bucket on each generation.
        * 
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of objects contained in the bucket. Otherwise, the bucket will
        * only generate empty vectors.
        * @param[in] selectionSize The number of objects to select on each
        *   generation. It must be at least 1.
        */
        void setSelectionSize(size_t selectionSize);

        /**
        * Adds an object to the bucket and places it at the end, so the object will
        * be associated with the highest index.
        * @param[in] object The object to add.
        */
        void append(const ObjectType& object);

        /**
        * Removes an object from the bucket. If the object given in argument is not
        * currently in the bucket, an invalid argument exception is thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the bucket. */
        void clear();

    protected:

        /** Regenerates the keys based on the objects contained in the bucket. */
        void updateKeys();

    private:

        /** The number of objects to select from the bucket on each generation. */
        size_t m_selectionSize;

        /** The objects contained in the bucket. */
        std::vector<ObjectType> m_objects;

        /** The keys supported by the bucket in its current state. */
        std::set<std::string> m_keys;
    };

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket() :

        /* By default, we only select one object */
        Bucket(1)
    {}

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket(size_t selectionSize)
    {
        /*
        * We set the selection size. Note that this call will also initialize the
        * keys. Concretely, it will simply register the null key as the only valid
        * key since the bucket is empty for now.
        */
        setSelectionSize(selectionSize);
    }

    template<class ObjectType>
    inline std::set<std::string> Bucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline std::vector<ObjectType> Bucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate an empty vector. */
        if (key == OPENTESTING_NULL_KEY)
            return {};

        /* Otherwise, we start parsing the key by splitting it into indices */
        std::vector<std::string> indices = String::split(key, OPENTESTING_DELIMITER_BUCKET_KEY);

        /*
        * We enforce the constraint that the number of indices should match the
        * selection size.
        */
        if (indices.size() != m_selectionSize)
            throw std::invalid_argument("Invalid bucket key: found " + std::to_string(indices.size()) + " indices for a selection size of " + std::to_string(m_selectionSize));

        /* We initialize a result vector */
        std::vector<ObjectType> result;

        /* We copy each object from the given indices */
        for (const auto& index : indices)
            result.push_back(m_objects[std::stoi(index)]);

        /* We return the result vector */
        return result;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSelectionSize() const
    {
        return m_selectionSize;
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& Bucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool Bucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::setSelectionSize(size_t selectionSize)
    {
        /* We make sure the selection size is at least 1 */
        if (selectionSize == 0)
            throw std::invalid_argument("The selection size of a bucket must be at least 1 and cannot be set to 0.");

        /* If so, we set the new selection size and update the keys */
        m_selectionSize = selectionSize;
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::append(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::updateKeys()
    {
        /*
        * If the bucket does not contain enough objects for a selection to be made
        * (which includes the case of an empty bucket since the selection size is
        * always at least 1), then the only key it supports is the null key.
        */
        if (m_selectionSize > m_objects.size())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports are all the strings representing a valid
        * selection of objects from the bucket.
        */
        else
        {
            /* We list all valid indices for the bucket */
            std::vector<std::string> indicesAsString;
            for (int i = 0; i < m_objects.size(); i++)
                indicesAsString.push_back(std::to_string(i));

            /* Then we enumerate all choices among these indices */
            auto choices = Enumerator::choices<std::vector<std::string>>(indicesAsString, m_selectionSize);

            /*
            * And finally we concatenate each choice with a delimiter to obtain the
            * final keys
            */
            m_keys.clear();
            for (const auto& choice : choices)
                m_keys.insert(String::join(choice, OPENTESTING_DELIMITER_BUCKET_KEY));
        }
    }
}