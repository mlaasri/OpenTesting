/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <vector>
#include <algorithm>
#include <stdexcept>

#include "Generator.h"
#include "../../config/SpecialKeys.h"

namespace OT
{
    /**
    * \class Bucket Bucket.h
    * A Bucket is a container-based Generator that contains a copy of all the
    * objects it can possibly generate and returns the appropriate one based on an
    * index passed as a string key.
    * 
    * If a Bucket is empty, the only key it supports is the null key, which is a
    * string defined by the macro OPENTESTING_NULL_KEY (which currently evaluates to
    * "N"). If a Bucket is not empty, then it supports any string representing a
    * valid index as a key to generate an object. The object returned will then
    * simply be a copy of the object located at the given index.
    */
    template<class ObjectType>
    class Bucket :
        public Generator<ObjectType>
    {
    public:

        /** Creates an empty bucket. */
        Bucket();

        /**
        * Returns the set of keys supported by the bucket.
        *
        * If the bucket does not contain any object, then the only key it supports
        * is the null key OPENTESTING_NULL_KEY ("N"). On the other hand, if the
        * bucket contains at least one object, then the keys it supports are all the
        * strings representing a valid index between 0 and getSize() - 1 included,
        * i.e. "0", "1", "2", etc.
        */
        std::set<std::string> getKeys() const override;

        /** Returns the number of keys supported by the bucket. */
        size_t getNumKeys() const override;

        /**
        * Picks an object from the Bucket based on the given key and returns a copy
        * of it. If the bucket is empty, this method will call generateNull()
        * instead and return the result of this call.
        * @param[in] key The key to use to pick the object. If the bucket is empty,
        *   the key must be equal to the null key OPENTESTING_NULL_KEY, in which
        *   case the bucket will call generateNull() and return the result of this
        *   call. Otherwise, it must be a string representing a valid index between
        *   0 and getSize() - 1 included, e.g. "0", "1", "2", etc., in which case
        *   the bucket will return a copy of the object located at the corresponding
        *   index.
        */
        ObjectType generate(const std::string& key) const override;


        /** Returns all the objects contained in the bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the bucket. */
        size_t getSize() const;

        /** Returns true if the bucket is empty and false otherwise */
        bool isEmpty() const;

        /**
        * Adds an object to the bucket.
        * @param[in] object The object to add.
        */
        void add(const ObjectType& object);

        /**
        * Removes an object from the bucket. If the object given in argument is not
        * currently in the bucket, an invalid argument exception is thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the bucket. */
        void clear();

    protected:

        /**
        * Generates a null object when the bucket is empty. By default, this method
        * just calls the default constructor of the appropriate object type, but the
        * method is virtual so it can be overriden in derived classes.
        */
        virtual ObjectType generateNull() const;

        /** Regenerates the keys based on the objects contained in the bucket. */
        void updateKeys();

    private:

        /** The objects contained in the bucket. */
        std::vector<ObjectType> m_objects;

        /** The keys supported by the bucket in its current state. */
        std::set<std::string> m_keys;
    };

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket()
    {
        /*
        * We initialize the keys. This will simply register the null key as the only
        * valid key since the bucket is empty for now.
        */
        updateKeys();
    }

    template<class ObjectType>
    inline std::set<std::string> Bucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline ObjectType Bucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate a null object. */
        if (key == OPENTESTING_NULL_KEY)
            return generateNull();

        /*
        * Otherwise, we decode the key as the index of the object to pick and return
        * a copy of
        */
        return m_objects[std::stoi(key)];
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& Bucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool Bucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::add(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline ObjectType Bucket<ObjectType>::generateNull() const
    {
        return ObjectType();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::updateKeys()
    {
        /* If the bucket is empty, then the only key it supports is the null key. */
        if (m_objects.empty())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports are all the strings representing a valid
        * index between 0 and getSize() - 1 included, i.e. "0", "1", "2", etc.
        */
        else
        {
            m_keys.clear();
            for (int i = 0; i < m_objects.size(); i++)
                m_keys.insert(std::to_string(i));
        }
    }
}