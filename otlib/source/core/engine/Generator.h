/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <algorithm>
#include <iterator>

namespace OT
{
    /**
    * \class Generator Generator.h
    * An object that can generate another object based on a key provided as a
    * string.
    */
    template<class GeneratedType, typename KeyContainerType = std::vector<std::string>>
    class Generator
    {
    public:

        /** A handy accessor to the Generator's generated object type */
        typedef GeneratedType GeneratedType;

        /** A handy accessor to the Generator's key container type */
        typedef KeyContainerType KeyContainerType;

        /**
        * Returns the set of keys supported by the generator.
        */
        virtual KeyContainerType getKeys() const = 0;

        /**
        * Returns the number of keys supported by this generator.
        * 
        * By default, this method generates all possible keys and counts them. If
        * there exists a faster way to compute this result, the method can be
        * overriden in derived classes to use a faster implementation (it is
        * virtual for that purpose).
        */
        virtual size_t getNumKeys() const;

        /**
        * Returns true if the key given in argument is a valid key for this
        * generator and false otherwise.
        * 
        * By default, this method generates all possible keys and checks if the
        * given key appears in the list. If there exists a faster way to compute
        * this result, the method can be overriden in derived classes to use a
        * faster implementation (it is virtual for that purpose).
        * @param[in] key The key to check the validity of.
        */
        virtual bool isValidKey(const std::string& key) const;

        /**
        * Generates an object based on the given key. This method must be
        * implemented in derived classes, with the constraint that the same key must
        * generate the same object.
        * @param[in] key The key to use to generate the object. The key must be
        *   valid (see the getKeys() method for a list of valid keys).
        */
        virtual GeneratedType generate(const std::string& key) const = 0;

        /**
        * Retrieves all possible keys for this generator and uses the one at the
        * given index to generate a new object.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as
        *   returned by the getKeys() method.
        */
        virtual GeneratedType generateFromIndex(int keyIndex) const;
    };

    template<class GeneratedType, typename KeyContainerType>
    inline size_t Generator<GeneratedType, KeyContainerType>::getNumKeys() const
    {
        return getKeys().size();
    }

    template<class GeneratedType, typename KeyContainerType>
    inline bool Generator<GeneratedType, KeyContainerType>::isValidKey(const std::string& key) const
    {
        KeyContainerType validKeys = getKeys();
        return std::find(validKeys.cbegin(), validKeys.cend(), key) != validKeys.cend();
    }

    template<class GeneratedType, typename KeyContainerType>
    inline GeneratedType Generator<GeneratedType, KeyContainerType>::generateFromIndex(int keyIndex) const
    {
        KeyContainerType validKeys = getKeys();
        return generate(*std::next(validKeys.cbegin(), keyIndex));
    }
}