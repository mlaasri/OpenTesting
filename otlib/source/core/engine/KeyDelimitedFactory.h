/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <vector>
#include <algorithm>

#include "Factory.h"
#include "../../config/Delimiters.h"
#include "../../utility/String.h"

namespace OT
{
    /**
    * \class KeyDelimitedFactory KeyDelimitedFactory.h
    * A Factory that uses a character delimiter to retrieve the keys for its units.
    */
    template<class ObjectType>
    class KeyDelimitedFactory :
        public Factory<ObjectType>
    {
    public:

        /**
        * Returns all the keys supported by the KeyDelimitedFactory. The keys are
        * obtained by computing the Least Common Product of all possible unit keys
        * and then concatenating them with a character delimiter (for more
        * information on the Least Common Product, see the documentation of the
        * Enumerator::leastCommonProduct() method).
        * 
        * Note that, as a result, if the KeyDelimitedFactory is empty or contains at
        * least one unit that does not support any key, then the whole factory will
        * not either, and this method will return an empty vector.
        */
        typename KeyDelimitedFactory<ObjectType>::KeyContainerTypeValue getKeys() const override;

        /**
        * Returns the number of keys supported by the KeyDelimitedFactory.
        * 
        * In the general case, the result is equal to the Least Common Multiple of
        * the number of keys supported by each unit inside the factory. However, if
        * the factory is empty or contains at least one unit that does not support
        * any key, then the whole factory will not either, and this method will
        * return 0.
        */
        size_t getNumKeys() const;

        /**
        * Generates a Pipeline for the proper object type.
        * @param[in] key The factory key to use for generating the pipeline.
        */
        Pipeline<ObjectType> generate(const std::string& key) const override;
    };

    template<class ObjectType>
    inline typename KeyDelimitedFactory<ObjectType>::KeyContainerTypeValue KeyDelimitedFactory<ObjectType>::getKeys() const
    {
        /*
        * To generate all the factory keys, we join each unit key combination with a
        * delimiter:
        */
        std::vector<std::vector<std::string>> combinations = Factory<ObjectType>::getUnitKeysCombinations();
        typename KeyDelimitedFactory<ObjectType>::KeyContainerTypeValue keys;
        for (const auto& combination : combinations)
            keys.insert(keys.end(), OT::String::join(combination, OPENTESTING_DELIMITER_UNIT_KEYS));
        return keys;
    }

    template<class ObjectType>
    inline size_t KeyDelimitedFactory<ObjectType>::getNumKeys() const
    {
        /* We retrieve the factory's units */
        const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& units = Factory<ObjectType>::getUnits();

        /* If the factory does not contain any unit, we return 0 */
        if (units.empty())
            return 0;

        /* If at least one of the unit has no keys, we return 0 */
        for (const auto& unit : units)
            if (unit->getNumKeys() == 0)
                return 0;

        /*
        * Otherwise, we compute the Least Common Multiple of the number of keys
        * supported by each unit. To do so, we use a simple algorithm that
        * increments the largest of these numbers until a number that is divisible
        * by all is found.
        */

        /* We first count the number of keys per unit. */
        std::vector<size_t> numKeysPerUnit(units.size());
        std::transform(units.cbegin(), units.cend(), numKeysPerUnit.begin(), [](const std::unique_ptr<typename Factory<ObjectType>::Unit>& unit) { return unit->getNumKeys(); });

        /* Then we retrieve the maximum of these numbers */
        size_t maxNumKeys = *std::max_element(numKeysPerUnit.cbegin(), numKeysPerUnit.cend());

        /*
        * And we increment it by itself until we obtain a number that is divisible
        * by all key counts. At this point, this number will be the Least Common
        * Multiple of these counts.
        */
        size_t numKeys = maxNumKeys;
        while (std::any_of(numKeysPerUnit.cbegin(), numKeysPerUnit.cend(), [numKeys](const size_t& k) { return numKeys % k != 0; }))
            numKeys += maxNumKeys;

        /* Finally, we return the result */
        return numKeys;
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> KeyDelimitedFactory<ObjectType>::generate(const std::string& key) const
    {
        /*
        * We split the factory into unit keys and send each one to its corresponding
        * unit:
        */
        std::vector<std::string> unitKeys = OT::String::split(key, OPENTESTING_DELIMITER_UNIT_KEYS);
        return Factory<ObjectType>::generateFromUnits(unitKeys);
    }
}