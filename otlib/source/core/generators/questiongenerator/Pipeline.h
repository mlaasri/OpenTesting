/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <vector>

#include "../generator/Generator.h"

namespace OT
{
    /**
    * \class Pipeline Pipeline.h
    * A generation Pipeline that builds a Question object by processing it one step
    * at a time.
    * 
    * A Pipeline consists of a sequence of processors that each completes or
    * modifies a Question object. For example, a Processor can replace tokens in a
    * Question's prompt by some text, or add some options to a
    * MultipleChoiceQuestion. Once a Question traverses a Pipeline, it ends up in
    * its final state and is be ready to presented to the examinee.
    */
    template<class QuestionType>
    class Pipeline
    {
    public:

        /**
        * \struct Processor Pipeline.h
        * A processing unit that is part of a generation Pipeline and that aims at
        * completing or modifying an existing Question object.
        */
        struct Processor
        {
            /**
            * Processes the question given in argument. This method must be
            * implemented in all classes derived from Processor.
            * @param[in] question The Question to process. This object is meant to
            *   be modified by this method.
            */
            virtual void process(QuestionType& question) const = 0;
        };

        /**
        * Adds a Processor at the end of the Pipeline.
        * 
        * Note that the pointer given in argument will be moved to the Pipeline's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] processor A pointer to the Processor to add. The pointer will
        *   be moved inside the Pipeline by this method, so it should not be
        *   accessed anymore after this method is called.
        */
        void append(std::unique_ptr<Processor> processor);

        /**
        * Passes the question given in argument throughout the whole pipeline,
        * calling one Processor at a time in the order in which they were inserted
        * with the append() method.
        * @param[in] question The Question to process. This object is meant to be
        *   modified by this method.
        */
        void process(QuestionType& question) const;

    private:

        /** The sequence of processors constituting the Pipeline */
        std::vector<std::unique_ptr<Processor>> m_processors;
    };

    template<class QuestionType>
    inline void Pipeline<QuestionType>::append(std::unique_ptr<Processor> processor)
    {
        /* We move the pointer into the Pipeline's internal storage */
        m_processors.push_back(std::move(processor));
    }

    template<class QuestionType>
    inline void Pipeline<QuestionType>::process(QuestionType& question) const
    {
        /* We pass the question throughout the processing pipeline */
        for (const auto& processor : m_processors)
            processor->process(question);
    }
}