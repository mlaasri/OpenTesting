/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <string>
#include <vector>

#include "QuestionGenerator.h"
#include "../../questions/question/Question.h"
#include "Factory.h"
#include "../../../config/Delimiters.h"
#include "../../../utility/String.h"

namespace OT
{
    /**
    * \class SpecializedQuestionGenerator SpecializedQuestionGenerator.h
    * A QuestionGenerator specialized in generating a particular type of Question.
    */
    template<class QuestionType>
    class SpecializedQuestionGenerator :
        public QuestionGenerator
    {
    public:

        /**
        * \class SpecializedFactory SpecializedQuestionGenerator.h
        * A Factory that uses a character delimiter to retrieve the keys for its
        * units.
        */
        class SpecializedFactory :
            public Factory<QuestionType>
        {
        public:

            /**
            * Returns all the keys supported by the SpecializedFactory. The keys
            * are obtained by computing the Cartesian product of all possible unit
            * keys and then concatenating each result with a character delimiter.
            */
            std::vector<std::string> getKeys() const override;

            /**
            * Generates a Pipeline for the proper Question type.
            * @param[in] key The factory key to use for generating the pipeline.
            */
            Pipeline<QuestionType> generate(const std::string& key) const override;
        };

        /** A shorthand for the type of Unit supported by the SpecializedFactory */
        typedef typename SpecializedFactory::Unit FactoryUnit;

        /** A shorthand for the type of objects generated by each Factory Unit */
        typedef typename SpecializedFactory::Processor Processor;

        /**
        * Returns all the keys supported by the SpecializedQuestionGenerator. The
        * keys are obtained by computing the Cartesian product of all possible 
        * factory keys and then concatenating each Factory's identifier with each of
        * its keys with a character delimiter.
        */
        std::vector<std::string> getKeys() const override;

        /**
        * Generates a Question based on the given key and returns a pointer to it.
        * 
        * To generate a Question, the SpecializedQuestionGenerator will first
        * initialize a Question object of the appropriate type, then pick one single
        * SpecializedFactory based on the given key, and use this factory to
        * generate a Pipeline that will process and complete this Question object.
        * 
        * The returned pointer points to a Question of type Question, but the object
        * itself is an instance of the template type QuestionType. It can be casted
        * to the appropriate type later, or with the generateAndCast() method
        * directly. Note that casting requires to turn the pointer into a shared
        * pointer, since the casting operation does not support ownership
        * exclusivity.
        * @param[in] key The key to use for generating the Question.
        */
        std::unique_ptr<Question> generate(const std::string& key) const override;

    private:

        /** The factories to pick from when generating the Question */
        std::vector<SpecializedFactory> m_factories;
    };

    template<class QuestionType>
    inline std::vector<std::string> SpecializedQuestionGenerator<QuestionType>::SpecializedFactory::getKeys() const
    {
        /*
        * To generate all the factory keys, we join each unit key combination with a
        * delimiter:
        */
        std::vector<std::vector<std::string>> combinations = SpecializedFactory::getAllUnitKeysCombinations();
        std::vector<std::string> keys;
        for (const auto& combination : combinations)
            keys.push_back(OT::String::join(combination, OPENTESTING_DELIMITER_UNIT_KEYS));
        return keys;
    }

    template<class QuestionType>
    inline Pipeline<QuestionType> SpecializedQuestionGenerator<QuestionType>::SpecializedFactory::generate(const std::string& key) const
    {
        /*
        * We split the factory into unit keys and send each one to its corresponding
        * unit:
        */
        std::vector<std::string> unitKeys = OT::String::split(key, OPENTESTING_DELIMITER_UNIT_KEYS);
        return SpecializedFactory::generateFromUnits(unitKeys);
    }

    template<class QuestionType>
    inline std::vector<std::string> SpecializedQuestionGenerator<QuestionType>::getKeys() const
    {
        /* We start with an empty set of keys */
        std::vector<std::string> keys;

        /*
        * We retrieve the keys of each factory and adds the factory's index at the
        * beginning of each key as a factory identifier
        */
        for (int i = 0; i < m_factories.size(); i++)
            for (const auto& key : m_factories[i].getKeys())
                keys.push_back(String::join({ std::to_string(i), key }, OPENTESTING_DELIMITER_FACTORY));

        /* We return the result */
        return keys;
    }

    template<class QuestionType>
    inline std::unique_ptr<Question> SpecializedQuestionGenerator<QuestionType>::generate(const std::string& key) const
    {
        /* We first separate the factory's identifier from its key */
        std::vector<std::string> keys = OT::String::split(key, OPENTESTING_DELIMITER_FACTORY);
        int factoryID = std::stoi(keys[0]);
        std::string factoryKey = keys[1];

        /* We then generate a pipeline */
        const Pipeline<QuestionType> pipeline = m_factories[factoryID].generate(factoryKey);

        /* And then create and process a question object */
        std::unique_ptr<QuestionType> question = std::make_unique<QuestionType>();
        pipeline.process(*question);
        
        /* Once the question has been processed, we return it */
        return question;
    }
}