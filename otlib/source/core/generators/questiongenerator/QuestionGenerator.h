/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2022, mlaasri
**
***********************************************************************/

#pragma once

#include <memory>
#include <string>
#include <vector>

#include "GenericQuestionGenerator.h"
#include "../../questions/question/Question.h"
#include "KeyDelimitedFactory.h"
#include "../../../config/Delimiters.h"
#include "../../../utility/String.h"
#include "../../../utility/Enumerator.h"

namespace OT
{
    /**
    * \class QuestionGenerator QuestionGenerator.h
    * A QuestionGenerator specialized in generating a particular type of Question.
    */
    template<class QuestionType>
    class QuestionGenerator :
        public GenericQuestionGenerator
    {
    public:

        /** A shorthand for the type of Factory used in the QuestionGenerator */
        typedef KeyDelimitedFactory<QuestionType> QuestionFactory;

        /** A shorthand for the type of Unit supported by the KeyDelimitedFactory */
        typedef typename QuestionFactory::Unit FactoryUnit;

        /** A shorthand for the type of objects generated by each Factory Unit */
        typedef typename QuestionFactory::Processor Processor;

        /** Defining a Table as a vector of factories */
        typedef std::vector<QuestionFactory> Table;

        /**
        * Returns all the keys supported by the QuestionGenerator. The keys are
        * obtained by computing the Cartesian product of all possible factory keys
        * and then concatenating each Factory's identifier with each of its keys
        * with a character delimiter.
        */
        std::vector<std::string> getKeys() const override;

        /**
        * Generates a Question based on the given key and returns a pointer to it.
        * 
        * To generate a Question, the QuestionGenerator will first initialize a
        * Question object of the appropriate type using the initializeQuestion()
        * method, then pick one single QuestionFactory per Table based on the given
        * key, and use these factories to generate pipelines that will process and
        * complete the Question object.
        * 
        * The returned pointer points to a Question of type Question, but the object
        * itself is an instance of the template type QuestionType. It can be casted
        * to the appropriate type later, or with the generateAndCast() method
        * directly. Note that casting requires to turn the pointer into a shared
        * pointer, since the casting operation does not support ownership
        * exclusivity.
        * @param[in] key The key to use for generating the Question.
        */
        std::unique_ptr<Question> generate(const std::string& key) const override;

        /**
        * Creates a new, empty Table and inserts it at the end of the
        * QuestionGenerator's Table container.
        */
        void appendTable();

        /**
        * Creates a new, empty QuestionFactory and inserts it at the end of the
        * given Table.
        * @param[in] tableIdentifier The index of the Table to add the
        *   QuestionFactory to. It must be in bound, i.e. non negative and less than
        *   the number of tables in the QuestionGenerator.
        */
        void appendFactory(int tableIdentifier);

        /**
        * Adds the given FactoryUnit at the end of the desired QuestionFactory.
        *
        * Note that the pointer to the unit given in argument will be moved to the
        * factory's internal storage, so it should not be accessed anymore after
        * this method is called.
        * @param[in] tableIdentifier The index of the Table containing the
        *   QuestionFactory where to make the insertion. It must be in bound, i.e.
        *   non negative and less than the number of tables in the
        *   QuestionGenerator.
        * @param[in] factoryIdentifier The index of the desired QuestionFactory
        *   to add the unit to within the Table. It must be in bound, i.e. non
        *   negative and less than the number of factories in the Table.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void appendFactoryUnit(int tableIdentifier, int factoryIdentifier, std::unique_ptr<FactoryUnit> unit);

        /**
        * Removes and destroys all units from the given QuestionFactory.
        * @param[in] tableIdentifier The index of the Table containing the
        *   QuestionFactory to clear. It must be in bound, i.e. non negative and
        *   less than the number of tables in the QuestionGenerator.
        * @param[in] factoryIdentifier The index of the desired QuestionFactory
        *   to clear within the Table. It must be in bound, i.e. non negative and
        *   less than the number of factories in the Table.
        */
        void clearFactory(int tableIdentifier, int factoryIdentifier);

        /**
        * Removes and destroys all factories and their units from the given Table.
        * @param[in] tableIdentifier The index of the Table to clear. It must be in
        *   bound, i.e. non negative and less than the number of tables in the
        *   QuestionGenerator.
        */
        void clearTable(int tableIdentifier);

        /**
        * Removes and destroys all tables and their content from the
        * QuestionGenerator.
        */
        void clear();

    protected:

        /**
        * Initializes a Question object of the appropriate type.
        * 
        * This method is the first method called for generating a Question. The
        * returned object is then passed to a series of pipelines that modifies it,
        * one step at a time.
        * 
        * This method is virtual so it can be overriden in derived classes. By
        * default, it just calls the default constructor of the appropriate Question
        * class.
        */
        virtual std::unique_ptr<QuestionType> initializeQuestion() const;

    private:

        /** The factory tables to pick from when generating the Question */
        std::vector<Table> m_tables;
    };

    template<class QuestionType>
    inline std::vector<std::string> QuestionGenerator<QuestionType>::getKeys() const
    {
        std::vector<std::vector<std::string>> keysPerTable;
        for (int t = 0; t < m_tables.size(); t++)
        {
            /*
            * We retrieve the keys of each factory and adds the factory's index at the
            * beginning of each key as a factory identifier
            */
            std::vector<std::string> tableKeys;
            for (int f = 0; f < m_tables[t].size(); f++)
                for (const auto& key : m_tables[t][f].getKeys())
                    tableKeys.push_back(String::join({ std::to_string(f), key }, OPENTESTING_DELIMITER_FACTORY_KEY));

            keysPerTable.push_back(tableKeys);
        }

        /* We enumerate all possible combinations of table keys */
        std::vector<std::vector<std::string>> combinations = Enumerator::cartesianProduct(keysPerTable);

        /* We then create the keys by joining the combinations */
        std::vector<std::string> keys;
        for (const auto& combination : combinations)
            keys.push_back(String::join(combination, OPENTESTING_DELIMITER_TABLE_KEY));

        /* We return the result */
        return keys;
    }

    template<class QuestionType>
    inline std::unique_ptr<Question> QuestionGenerator<QuestionType>::generate(const std::string& key) const
    {
        /* We start by initializing a question of the appropriate type */
        std::unique_ptr<QuestionType> question = initializeQuestion();

        /* We then split the key into table keys */
        std::vector<std::string> tableKeys = String::split(key, OPENTESTING_DELIMITER_TABLE_KEY);

        for (int t = 0; t < tableKeys.size(); t++)
        {
            /* We first separate the factory's identifier from its key */
            std::vector<std::string> parts = OT::String::split(tableKeys[t], OPENTESTING_DELIMITER_FACTORY_KEY);
            int factoryID = std::stoi(parts[0]);
            std::string factoryKey = parts[1];

            /* We then generate a pipeline... */
            const Pipeline<QuestionType> pipeline = m_tables[t][factoryID].generate(factoryKey);

            /* ... And then use it to process the question */
            pipeline.process(*question);
        }
        
        /* Once the question has been processed by all factories, we return it */
        return question;
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::appendTable()
    {
        m_tables.push_back({});
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::appendFactory(int tableIdentifier)
    {
        m_tables[tableIdentifier].push_back({});
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::appendFactoryUnit(int tableIdentifier, int factoryIdentifier, std::unique_ptr<FactoryUnit> unit)
    {
        m_tables[tableIdentifier][factoryIdentifier].append(std::move(unit));
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clearFactory(int tableIdentifier, int factoryIdentifier)
    {
        m_tables[tableIdentifier][factoryIdentifier].clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clearTable(int tableIdentifier)
    {
        m_tables[tableIdentifier].clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clear()
    {
        m_tables.clear();
    }

    template<class QuestionType>
    inline std::unique_ptr<QuestionType> QuestionGenerator<QuestionType>::initializeQuestion() const
    {
        return std::make_unique<QuestionType>();
    }
}