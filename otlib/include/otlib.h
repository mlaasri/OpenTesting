/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <vector>
#include <iterator>
#include <algorithm>
#include <set>
#include <stdexcept>
#include <memory>

namespace OT
{
    /*
    =================================================
    General Configuration
    =================================================
    */

    /* Delimiters */

    /** The character delimiting individual Table keys */
    #define OPENTESTING_DELIMITER_TABLE_KEY ';'

    /** The character delimiting a Factory's identifier from its key */
    #define OPENTESTING_DELIMITER_FACTORY_KEY '>'

    /** The character delimiting unit keys within a Factory key */
    #define OPENTESTING_DELIMITER_UNIT_KEYS '-'

    /** The character delimiting chosen indices in a MultiSelectionBucket key */
    #define OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY '.'

    /* Special Keys */

    /** The key returned by a Generator to indicate it cannot generate an object */
    #define OPENTESTING_NULL_KEY "N"



    /*
    =================================================
    Utility
    =================================================
    */

    /**
    * \class String String.h
    * A utility class for manipulating strings.
    */
    class String
    {
    public:

        /**
        * The String class has no constructor since all its methods are static and
        * meant to be used without a String object.
        */
        String() = delete;

        /**
        * Splits the given string at any occurrence of the given delimiter.
        * @param[in] string The string to split.
        * @param[in] delimiter The delimiter.
        */
        static std::vector<std::string> split(const std::string& string, char delimiter);

        /**
        * Joins the strings given in argument with a delimiter in between each
        * string.
        * @param[in] strings The strings to join together.
        * @param[in] delimiter The delimiter to insert in between each string.
        */
        static std::string join(const std::vector<std::string>& strings, char delimiter);

        /**
        * Replaces all occurrences of a substring with another.
        * @param[in] string The string to make the replacement in.
        * @param[in] from The substring to replace.
        * @param[in] to The substring to make the replacement with.
        */
        static std::string& replaceAll(std::string& string, const std::string& from, const std::string& to);

        /**
        * Removes all occurrences of the given character in the given string.
        * @param[in] string The string to remove the character from.
        * @param[in] character The character to remove.
        */
        static std::string& removeAll(std::string& string, char character);

        /**
        * Removes any space at the beginning or end of the given string.
        *
        * The following characters are considered a space: the usual space
        * character, the tabulation character, the newline character, the vertical
        * tabulation character, the form feed character, and the carriage return
        * character.
        * @param[in] string The string to trim.
        */
        static std::string& trim(std::string& string);

        /**
        * Removes any space at the beginning of the given string.
        *
        * The following characters are considered a space: the usual space
        * character, the tabulation character, the newline character, the vertical
        * tabulation character, the form feed character, and the carriage return
        * character.
        * @param[in] string The string to trim.
        */
        static std::string& trimLeft(std::string& string);

        /**
        * Removes any space at the end of the given string.
        *
        * The following characters are considered a space: the usual space
        * character, the tabulation character, the newline character, the vertical
        * tabulation character, the form feed character, and the carriage return
        * character.
        * @param[in] string The string to trim.
        */
        static std::string& trimRight(std::string& string);

        /**
        * Returns true if the given string starts with the given substring and false
        * otherwise.
        * @param[in] string The string where to look for the substring.
        * @param[in] substring The string to look for.
        */
        static bool startsWith(const std::string& string, const std::string& substring);

        /**
        * Returns true if the given string ends with the given substring and false
        * otherwise.
        * @param[in] string The string where to look for the substring.
        * @param[in] substring The string to look for.
        */
        static bool endsWith(const std::string& string, const std::string& substring);

        /**
        * Returns true if the given string contains the given substring and false
        * otherwise.
        * @param[in] string The string where to look for the substring.
        * @param[in] substring The string to look for.
        */
        static bool contains(const std::string& string, const std::string& substring);

        /**
        * Returns true if the given string contains the given character and false
        * otherwise.
        * @param[in] string The string where to look for the character.
        * @param[in] character The character to look for.
        */
        static bool contains(const std::string& string, char character);
    };
    
    /**
    * \class Enumerator Enumerator.h
    * A utility class for enumerating combinations on sets of elements.
    */
    class Enumerator
    {
    public:

        /**
        * The Enumerator class has no constructor since all its methods are static
        * and meant to be used without an Enumerator object.
        */
        Enumerator() = delete;

        /**
        * Computes the Cartesian product of different sets of elements. This method
        * uses a recursive algorithm, and is compatible with all STL containers
        * relevant for OpenTesting.
        *
        * If the vector passed in argument is empty or contains any empty set
        * inside, then this method will return an empty vector, as per the
        * definition of a Cartesian product.
        * @param[in] sets The sets of elements, stored in a vector. If empty or if
        *   it contains an empty set inside, the method will return an empty vector.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> cartesianProduct(const std::vector<InputContainerType>& sets);

        /**
        * Enumerates all possibles choices of a fixed number of objects from the
        * given STL container. Choices are made without replacement, so the same
        * object cannot be selected twice, except if it is present in multiple
        * copies in the input container.
        *
        * If K denotes the number of objects to choose and N the number of objects
        * available in the input container, then this method will return a vector
        * containing exactly N choose K elements, provided K is not greater than N.
        * If this is not the case, then this method will return an empty vector.
        *
        * Note that a choice represents a set of objects in which the order does not
        * matter (objects can be selected in any order). By convention, this method
        * will return objects in the order in which they appear in the input
        * container.
        * @param[in] objects The objects to choose from, stored in an STL container.
        *   If empty or if it contains fewer elements than the number of objects to
        *   choose, the method will return an empty vector.
        * @param[in] numObjectsToChoose The number of objects to choose from the
        *   container. It must be less than or equal to the number of objects in the
        *   container.
        */
        template<typename InputContainerType, typename OutputContainerType = InputContainerType>
        static std::vector<OutputContainerType> choices(const InputContainerType& objects, size_t numObjectsToChoose);

    private:

        /**
        * The recursive method called by cartesianProduct() to compute the Cartesian
        * product of the given sets.
        * @param[in] sets The sets of elements, stored in a vector.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> cartesianProductRecursive(const std::vector<InputContainerType>& sets);
    };

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::cartesianProduct(const std::vector<InputContainerType>& sets)
    {
        /* If the vector of sets is empty, we return an empty set. */
        if (sets.empty())
            return {};

        /* If at least one of the sets is empty, we return an empty set. */
        for (const auto& set : sets)
            if (set.empty())
                return {};

        /* Otherwise, we launch the recursion */
        return cartesianProductRecursive<InputContainerType, OutputContainerType>(sets);
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::cartesianProductRecursive(const std::vector<InputContainerType>& sets)
    {
        /*
        * If the vector of sets is empty, we return a singleton containing only
        * the empty set for the recursion to work.
        */
        if (sets.empty())
            return { OutputContainerType() };

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /* We grab the head and tail of the sets... */
        const InputContainerType& head = *sets.cbegin();
        std::vector<InputContainerType> tail = sets;
        tail.erase(tail.begin());

        /* ... And we recursively call the cartesianProduct method */
        std::vector<OutputContainerType> tailProduct = cartesianProductRecursive<InputContainerType, OutputContainerType>(tail);
        for (const auto& h : head)
            for (const auto& tailElement : tailProduct)
            {
                OutputContainerType element;
                element.insert(element.end(), h);
                for (const auto& x : tailElement)
                    element.insert(element.end(), x);
                result.insert(result.end(), std::move(element));
            }

        /* Finally, we return the result */
        return result;
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::choices(const InputContainerType& objects, size_t numObjectsToChoose)
    {
        /*
        * If there are not enough objects to choose from, we return an empty vector.
        */
        if (numObjectsToChoose > objects.size())
            return {};

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /*
        * We introduce a selection mask that determines whether an object should be
        * chosen or not. The enumeration of all possible choices then boils down to
        * the enumeration of all possible permutations of the selection mask.
        */
        std::vector<bool> selectionMask(numObjectsToChoose, true);
        selectionMask.resize(objects.size(), false);
        do
        {
            OutputContainerType choice;
            for (int i = 0; i < objects.size(); i++)
                if (selectionMask[i])
                    choice.insert(choice.end(), *std::next(objects.cbegin(), i));
            result.insert(result.end(), choice);
        } while (std::prev_permutation(selectionMask.begin(), selectionMask.end()));

        /* We return the result */
        return result;
    }



    /*
    =================================================
    Engine
    =================================================
    */

    /**
    * \class Generator Generator.h
    * An object that can generate another object based on a key provided as a
    * string.
    */
    template<class GeneratedType, typename KeyContainerType = std::set<std::string>>
    class Generator
    {
    public:

        /**
        * Returns the set of keys supported by the generator.
        */
        virtual KeyContainerType getKeys() const = 0;

        /**
        * Returns the number of keys supported by this generator.
        *
        * By default, this method generates all possible keys and counts them. If
        * there exists a faster way to compute this result, the method can be
        * overriden in derived classes to use a faster implementation (it is
        * virtual for that purpose).
        */
        virtual size_t getNumKeys() const;

        /**
        * Returns true if the key given in argument is a valid key for this
        * generator and false otherwise.
        *
        * By default, this method generates all possible keys and checks if the
        * given key appears in the list. If there exists a faster way to compute
        * this result, the method can be overriden in derived classes to use a
        * faster implementation (it is virtual for that purpose).
        * @param[in] key The key to check the validity of.
        */
        virtual bool isValidKey(const std::string& key) const;

        /**
        * Generates an object based on the given key. This method must be
        * implemented in derived classes, with the constraint that the same key must
        * generate the same object.
        * @param[in] key The key to use to generate the object. The key must be
        *   valid (see the getKeys() method for a list of valid keys).
        */
        virtual GeneratedType generate(const std::string& key) const = 0;

        /**
        * Retrieves all possible keys for this generator and uses the one at the
        * given index to generate a new object.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as
        *   returned by the getKeys() method.
        */
        virtual GeneratedType generateFromIndex(int keyIndex) const;
    };

    template<class GeneratedType, typename KeyContainerType>
    inline size_t Generator<GeneratedType, KeyContainerType>::getNumKeys() const
    {
        return getKeys().size();
    }

    template<class GeneratedType, typename KeyContainerType>
    inline bool Generator<GeneratedType, KeyContainerType>::isValidKey(const std::string& key) const
    {
        KeyContainerType validKeys = getKeys();
        return std::find(validKeys.cbegin(), validKeys.cend(), key) != validKeys.cend();
    }

    template<class GeneratedType, typename KeyContainerType>
    inline GeneratedType Generator<GeneratedType, KeyContainerType>::generateFromIndex(int keyIndex) const
    {
        KeyContainerType validKeys = getKeys();
        return generate(*std::next(validKeys.cbegin(), keyIndex));
    }

    /**
    * \class Bucket Bucket.h
    * A Bucket is a container-based Generator that contains a copy of all the
    * objects it can possibly generate and returns the appropriate one based on an
    * index passed as a string key.
    *
    * If a Bucket is empty, the only key it supports is the null key, which is a
    * string defined by the macro OPENTESTING_NULL_KEY (which currently evaluates to
    * "N"). If a Bucket is not empty, then it supports any string representing a
    * valid index as a key to generate an object. The object returned will then
    * simply be a copy of the object located at the given index.
    */
    template<class ObjectType>
    class Bucket :
        public Generator<ObjectType>
    {
    public:

        /** Creates an empty bucket. */
        Bucket();

        /**
        * Returns the set of keys supported by the bucket.
        *
        * If the bucket does not contain any object, then the only key it supports
        * is the null key OPENTESTING_NULL_KEY ("N"). On the other hand, if the
        * bucket contains at least one object, then the keys it supports are all the
        * strings representing a valid index between 0 and getSize() - 1 included,
        * i.e. "0", "1", "2", etc.
        */
        std::set<std::string> getKeys() const override;

        /** Returns the number of keys supported by the bucket. */
        size_t getNumKeys() const override;

        /**
        * Picks an object from the Bucket based on the given key and returns a copy
        * of it. If the bucket is empty, this method will call generateNull()
        * instead and return the result of this call.
        * @param[in] key The key to use to pick the object. If the bucket is empty,
        *   the key must be equal to the null key OPENTESTING_NULL_KEY, in which
        *   case the bucket will call generateNull() and return the result of this
        *   call. Otherwise, it must be a string representing a valid index between
        *   0 and getSize() - 1 included, e.g. "0", "1", "2", etc., in which case
        *   the bucket will return a copy of the object located at the corresponding
        *   index.
        */
        ObjectType generate(const std::string& key) const override;


        /** Returns all the objects contained in the bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the bucket. */
        size_t getSize() const;

        /** Returns true if the bucket is empty and false otherwise */
        bool isEmpty() const;

        /**
        * Adds an object to the bucket.
        * @param[in] object The object to add.
        */
        void add(const ObjectType& object);

        /**
        * Removes an object from the bucket. If the object given in argument is not
        * currently in the bucket, an invalid argument exception is thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the bucket. */
        void clear();

    protected:

        /**
        * Generates a null object when the bucket is empty. By default, this method
        * just calls the default constructor of the appropriate object type, but the
        * method is virtual so it can be overriden in derived classes.
        */
        virtual ObjectType generateNull() const;

        /** Regenerates the keys based on the objects contained in the bucket. */
        void updateKeys();

    private:

        /** The objects contained in the bucket. */
        std::vector<ObjectType> m_objects;

        /** The keys supported by the bucket in its current state. */
        std::set<std::string> m_keys;
    };

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket()
    {
        /*
        * We initialize the keys. This will simply register the null key as the only
        * valid key since the bucket is empty for now.
        */
        updateKeys();
    }

    template<class ObjectType>
    inline std::set<std::string> Bucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline ObjectType Bucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate a null object. */
        if (key == OPENTESTING_NULL_KEY)
            return generateNull();

        /*
        * Otherwise, we decode the key as the index of the object to pick and return
        * a copy of
        */
        return m_objects[std::stoi(key)];
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& Bucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool Bucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::add(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline ObjectType Bucket<ObjectType>::generateNull() const
    {
        return ObjectType();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::updateKeys()
    {
        /* If the bucket is empty, then the only key it supports is the null key. */
        if (m_objects.empty())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports are all the strings representing a valid
        * index between 0 and getSize() - 1 included, i.e. "0", "1", "2", etc.
        */
        else
        {
            m_keys.clear();
            for (int i = 0; i < m_objects.size(); i++)
                m_keys.insert(std::to_string(i));
        }
    }

    /**
    * \class MultiSelectionBucket MultiSelectionBucket.h
    * A MultiSelectionBucket is a Generator that is similar to a Bucket, except it
    * returns multiple objects instead of just one. A MultiSelectionBucket always
    * generates the same number of elements, which is called its "selection size".
    *
    * If a MultiSelectionBucket contains fewer objects than its selection size, the
    * only key it supports is the null key, which is a string defined by the macro
    * OPENTESTING_NULL_KEY (which currently evaluates to "N"). Otherwise, it
    * supports any character-delimited string representing a set of valid indices
    * sorted in increasing order as a key to generate a vector of objects. The
    * objects returned will then simply be copies of the objects located at the
    * given indices.
    */
    template<class ObjectType>
    class MultiSelectionBucket :
        public Generator<std::vector<ObjectType>>
    {
    public:

        /** Creates an empty multi-selection bucket. */
        MultiSelectionBucket();

        /**
        * Returns the set of keys supported by the multi-selection bucket.
        *
        * If the bucket does not contain enough objects for a selection to be made,
        * i.e. it contains fewer objects than its selection size, then the only key
        * it supports is the null key OPENTESTING_NULL_KEY ("N"). On the other hand,
        * if the bucket contains enough objects, then the keys it supports are all
        * the strings representing a set of valid indices delimited by the
        * OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY (".") character. The
        * indices must be sorted in increasing order to avoid having multiple keys
        * representing the same set.
        *
        * For example, if a multi-selection bucket with a selection size of 2
        * contains 3 elements, then it only supports the following keys: "0.1" (the
        * first and second elements are selected), "0.2" (the first and third
        * elements are selected), and "1.2" (the second and third elements are
        * selected). It does not support the key "2.1" because its indices are not
        * in increasing order. This selection (second and third elements) is already
        * accounted for in the key "1.2".
        */
        std::set<std::string> getKeys() const override;

        /** Returns the number of keys supported by the multi-selection bucket. */
        size_t getNumKeys() const override;

        /**
        * Selects multiple objects from the MultiSelectionBucket based on the given
        * key and returns a copy of each. The selection is made without replacement,
        * so the same object cannot be selected twice, except if it is present in
        * multiple copies inside the bucket.
        *
        * If the bucket does not contain enough objects for a selection to be made,
        * this method will return an empty vector.
        * @param[in] key The key to use to select the objects. If the
        *   multi-selection bucket contains fewer objects than its selection size,
        *   the key must be equal to the null key OPENTESTING_NULL_KEY, in which
        *   case the bucket will return an empty vector. Otherwise, it must be a
        *   string representing a set of valid indices delimited by
        *   OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY and sorted in increasing
        *   increasing order, in which case the bucket will return a vector
        *   containing copies of the objects located at the corresponding indices.
        */
        std::vector<ObjectType> generate(const std::string& key) const override;

        /**
        * Returns the selection size of the multi-selection bucket, i.e. the number
        * of objects to select from the bucket on each generation.
        */
        size_t getSelectionSize() const;

        /** Returns all the objects contained in the multi-selection bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the multi-selection bucket. */
        size_t getSize() const;

        /**
        * Returns true if the multi-selection bucket is empty and false otherwise.
        */
        bool isEmpty() const;

        /**
        * Defines the selection size of the multi-selection bucket, i.e. the number
        * of objects to select from the bucket on each generation.
        *
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of objects contained in the bucket. Otherwise, the bucket will
        * only generate empty vectors.
        * @param[in] selectionSize The number of objects to select on each
        *   generation.
        */
        void setSelectionSize(size_t selectionSize);

        /**
        * Adds an object to the multi-selection bucket.
        * @param[in] object The object to add.
        */
        void add(const ObjectType& object);

        /**
        * Removes an object from the multi-selection bucket. If the object given in
        * argument is not currently in the bucket, an invalid argument exception is
        * thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the multi-selection bucket. */
        void clear();

    protected:

        /**
        * Regenerates the keys based on the objects contained in the multi-selection
        * bucket.
        */
        void updateKeys();

    private:

        /**
        * The number of objects to select from the multi-selection bucket on each
        * generation.
        */
        size_t m_selectionSize;

        /** The objects contained in the multi-selection bucket. */
        std::vector<ObjectType> m_objects;

        /**
        * The keys supported by the multi-selection bucket in its current state.
        */
        std::set<std::string> m_keys;
    };

    template<class ObjectType>
    inline MultiSelectionBucket<ObjectType>::MultiSelectionBucket() :

        /* By default, we only select one object, just like a regular bucket */
        m_selectionSize(1)
    {
        /*
        * We initialize the keys. This will simply register the null key as the only
        * valid key since the multi-selection bucket is empty for now.
        */
        updateKeys();
    }

    template<class ObjectType>
    inline std::set<std::string> MultiSelectionBucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t MultiSelectionBucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline std::vector<ObjectType> MultiSelectionBucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate an empty vector. */
        if (key == OPENTESTING_NULL_KEY)
            return {};

        /* We initialize a result vector */
        std::vector<ObjectType> result;

        /* We copy each object from the given indices */
        std::vector<std::string> indices = String::split(key, OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY);
        for (const auto& index : indices)
            result.push_back(m_objects[std::stoi(index)]);

        /* We return the result vector */
        return result;
    }

    template<class ObjectType>
    inline size_t MultiSelectionBucket<ObjectType>::getSelectionSize() const
    {
        return m_selectionSize;
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& MultiSelectionBucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t MultiSelectionBucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool MultiSelectionBucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::setSelectionSize(size_t selectionSize)
    {
        /* We make sure the selection size is at least 1 */
        if (selectionSize == 0)
            throw std::invalid_argument("Cannot set the selection size of a multi-selection bucket to 0. It must be at least 1.");

        /* If so, we set the new selection size and update the keys */
        m_selectionSize = selectionSize;
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::add(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the multi-selection bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline void MultiSelectionBucket<ObjectType>::updateKeys()
    {
        /*
        * If the bucket does not contain enough objects for a selection to be made
        * (which includes the case of an empty bucket since the selection size is
        * always at least 1), then the only key it supports is the null key.
        */
        if (m_selectionSize > m_objects.size())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports are all the strings representing a valid
        * selection of objects from the bucket.
        */
        else
        {
            /* We list all valid indices for the bucket */
            std::vector<std::string> indicesAsString;
            for (int i = 0; i < m_objects.size(); i++)
                indicesAsString.push_back(std::to_string(i));

            /* Then we enumerate all choices among these indices */
            auto choices = Enumerator::choices<std::vector<std::string>>(indicesAsString, m_selectionSize);

            /*
            * And finally we concatenate each choice with a delimiter to obtain the
            * final keys
            */
            m_keys.clear();
            for (const auto& choice : choices)
                m_keys.insert(String::join(choice, OPENTESTING_DELIMITER_MULTI_SELECTION_BUCKET_KEY));
        }
    }

    /**
    * \class Pipeline Pipeline.h
    * A generation Pipeline that builds an object by processing it one step at a
    * time.
    *
    * A Pipeline consists of a sequence of processors that each completes or
    * modifies an object. For example, if the object is a type of Question, then a
    * Processor could replace tokens in its prompt by some text, or add some options
    * if it is a MultipleChoiceQuestion. Once an object traverses a Pipeline, it
    * ends up in its final state and is ready to be used.
    */
    template<class ObjectType>
    class Pipeline
    {
    public:

        /**
        * \struct Processor Pipeline.h
        * A processing unit that is part of a generation Pipeline and that aims at
        * completing or modifying an existing object.
        */
        struct Processor
        {
            /**
            * Processes the object given in argument. This method must be
            * implemented in all classes derived from Processor.
            * @param[in] object The object to process. This object is meant to be
            *   modified by this method.
            */
            virtual void process(ObjectType& object) const = 0;
        };

        /**
        * Adds a Processor at the end of the Pipeline.
        *
        * Note that the pointer given in argument will be moved to the Pipeline's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] processor A pointer to the Processor to add. The pointer will
        *   be moved inside the Pipeline by this method, so it should not be
        *   accessed anymore after this method is called.
        */
        void append(std::unique_ptr<Processor> processor);

        /**
        * Passes the object given in argument throughout the whole pipeline, calling
        * one Processor at a time in the order in which they were inserted with the
        * append() method.
        * @param[in] object The object to process. This object is meant to be
        *   modified by this method.
        */
        void process(ObjectType& object) const;

    private:

        /** The sequence of processors constituting the Pipeline */
        std::vector<std::unique_ptr<Processor>> m_processors;
    };

    template<class ObjectType>
    inline void Pipeline<ObjectType>::append(std::unique_ptr<Processor> processor)
    {
        /* We move the pointer into the Pipeline's internal storage */
        m_processors.push_back(std::move(processor));
    }

    template<class ObjectType>
    inline void Pipeline<ObjectType>::process(ObjectType& object) const
    {
        /* We pass the object throughout the processing pipeline */
        for (const auto& processor : m_processors)
            processor->process(object);
    }

    /**
    * \class Factory Factory.h
    * A generator of Pipeline objects for processing other objects.
    *
    * Derived classes must implement the Pipeline generation mechanism. The easiest
    * way to do so is to use a fundamental tool that is built in the Factory class:
    * the Unit subclass. Note that one can always implement a custom mechanism if
    * preferred, and ignore the Unit-related attributes and methods in this class.
    *
    * A Unit is an elementary block of a Factory that can generate a
    * Pipeline::Processor object, i.e. the elementary block of a Pipeline. In that
    * sense, Unit-based factories and pipelines work hand in hand, the elements of
    * one generating the elements of the other. One can therefore derive from the
    * Unit class and just implement the generation of each single Processor, with
    * the Factory class taking care of chaining all the processors together into a
    * Pipeline.
    *
    * Units work with their individual keys, which are called "unit keys". Derived
    * classes can implement a way to split a factory key into multiple unit keys to
    * generate a Pipeline and its elements, or simply pass the same factory key to
    * all units and implement their parsing as best fits. The former version is more
    * common in OpenTesting. For example, a simple delimiting character mechanism is
    * used in the KeyDelimitedFactory derived class to split an initial key into
    * multiple unit keys.
    */
    template<class ObjectType>
    class Factory :
        public Generator<Pipeline<ObjectType>>
    {
    public:

        /** A shorthand for Pipeline::Processor */
        typedef typename Pipeline<ObjectType>::Processor Processor;

        /** Definition of the Unit subclass as a Processor Generator */
        typedef Generator<std::unique_ptr<Processor>> Unit;

        /**
        * Adds a Unit at the end of the Factory.
        *
        * Note that the pointer given in argument will be moved to the Factory's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the Factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void append(std::unique_ptr<Unit> unit);

        /**
        * Removes and destroys all units from the Factory.
        */
        void clear();

        /**
        * Returns the internal units of the Factory.
        */
        const std::vector<std::unique_ptr<Unit>>& getUnits() const;

        /**
        * Returns the sets of keys that is supported by each Unit. The returned
        * object is a vector where one element correspond to the set of keys
        * supported by the Unit at the same position in the Factory.
        */
        std::vector<std::set<std::string>> getKeysPerUnit() const;

        /**
        * Returns all the possible combinations of individual unit keys that can be
        * sent the Factory's units to generate a Pipeline. These combinations are
        * computed using a simple Cartesian product. For example, if the Factory
        * contains two units with one supporting the keys "K1" and "K2" and one
        * supporting "KA" and "KB", then this method will return the 4 combinations
        * ("K1", "KA"), ("K1", "KB"), ("K2", "KA"), and ("K2", "KB").
        *
        * This method can be used to compute the set of all possible keys that can
        * be sent to the Factory itself. If the Factory just splits its own key into
        * unit keys based on a delimiter for example, which is a typical mechanism
        * implemented in the KeyDelimitedFactory class, then joining each set of
        * unit keys as returned by this method would lead to the set of all valid
        * keys supported by the Factory. If '-' was used as a delimiter in the
        * example above for instance, then the Factory's valid keys would be
        * "K1-KA", "K1-KB", "K2-K1", and "K2-KB".
        */
        std::vector<std::vector<std::string>> getAllUnitKeysCombinations() const;

        /**
        * Dispatches each key to its corresponding Unit so they all generate one
        * Pipeline::Processor each, and chains all resulting processors into a
        * Pipeline. Note that each key is sent to the Unit at the same position in
        * the Factory as the key in the vector argument, i.e. the first key in the
        * vector passed in argument will be sent to the first Unit, and so on.
        * @param[in] unitKeys The individual keys to send to each Unit. The size of
        *   this vector must match exactly the number of units in the Factory, and
        *   each key must be valid for its target Unit.
        */
        Pipeline<ObjectType> generateFromUnits(const std::vector<std::string>& unitKeys) const;

    private:

        /** The Factory's units */
        std::vector<std::unique_ptr<Unit>> m_units;
    };

    template<class ObjectType>
    inline void Factory<ObjectType>::append(std::unique_ptr<Unit> unit)
    {
        /* We move the pointer into the Factory's internal storage */
        m_units.push_back(std::move(unit));
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::clear()
    {
        m_units.clear();
    }

    template<class ObjectType>
    inline const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& Factory<ObjectType>::getUnits() const
    {
        return m_units;
    }

    template<class ObjectType>
    inline std::vector<std::set<std::string>> Factory<ObjectType>::getKeysPerUnit() const
    {
        /* We list and add all the keys for each unit */
        std::vector<std::set<std::string>> unitKeys;
        for (const auto& unit : m_units)
            unitKeys.push_back(unit->getKeys());
        return unitKeys;
    }

    template<class ObjectType>
    inline std::vector<std::vector<std::string>> Factory<ObjectType>::getAllUnitKeysCombinations() const
    {
        /* We compute the Cartesian product across all possible unit keys. */
        return Enumerator::cartesianProduct<std::set<std::string>, std::vector<std::string>>(getKeysPerUnit());
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> Factory<ObjectType>::generateFromUnits(const std::vector<std::string>& unitKeys) const
    {
        /* We start with an empty pipeline */
        Pipeline<ObjectType> pipeline;

        for (int i = 0; i < unitKeys.size(); i++)
        {
            /* We generate a processor... */
            std::unique_ptr<Processor> processor = m_units[i]->generate(unitKeys[i]);

            /* ... And add it to the pipeline */
            pipeline.append(std::move(processor));
        }

        /* We return the finished pipeline */
        return pipeline;
    }

    /**
    * \class KeyDelimitedFactory KeyDelimitedFactory.h
    * A Factory that uses a character delimiter to retrieve the keys for its units.
    */
    template<class ObjectType>
    class KeyDelimitedFactory :
        public Factory<ObjectType>
    {
    public:

        /**
        * Returns all the keys supported by the KeyDelimitedFactory. The keys are
        * obtained by computing the Cartesian product of all possible unit keys and
        * then concatenating each result with a character delimiter.
        *
        * Note that, as a result, if any unit in the KeyDelimitedFactory does not
        * support any key, then the whole factory will not either, and this method
        * will return an empty vector.
        */
        std::set<std::string> getKeys() const override;

        /**
        * Returns the number of keys supported by the KeyDelimitedFactory. The
        * result is obtained by multiplying together the number of keys supported by
        * each unit inside the factory.
        *
        * Note that, as a result, if any unit in the KeyDelimitedFactory does not
        * support any key, then the whole factory will not either, and this method
        * will return 0.
        */
        size_t getNumKeys() const;

        /**
        * Generates a Pipeline for the proper object type.
        * @param[in] key The factory key to use for generating the pipeline.
        */
        Pipeline<ObjectType> generate(const std::string& key) const override;
    };

    template<class ObjectType>
    inline std::set<std::string> KeyDelimitedFactory<ObjectType>::getKeys() const
    {
        /*
        * To generate all the factory keys, we join each unit key combination with a
        * delimiter:
        */
        std::vector<std::vector<std::string>> combinations = Factory<ObjectType>::getAllUnitKeysCombinations();
        std::set<std::string> keys;
        for (const auto& combination : combinations)
            keys.insert(OT::String::join(combination, OPENTESTING_DELIMITER_UNIT_KEYS));
        return keys;
    }

    template<class ObjectType>
    inline size_t KeyDelimitedFactory<ObjectType>::getNumKeys() const
    {
        /* We retrieve the factory's units */
        const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& units = Factory<ObjectType>::getUnits();

        /* If the factory does not contain any unit, we return 0 */
        if (units.empty())
            return 0;

        /* Otherwise, we multiply together the number of keys supported by each factory */
        size_t numKeys = 1;
        for (const auto& unit : units)
            numKeys *= unit->getNumKeys();
        return numKeys;
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> KeyDelimitedFactory<ObjectType>::generate(const std::string& key) const
    {
        /*
        * We split the factory into unit keys and send each one to its corresponding
        * unit:
        */
        std::vector<std::string> unitKeys = OT::String::split(key, OPENTESTING_DELIMITER_UNIT_KEYS);
        return Factory<ObjectType>::generateFromUnits(unitKeys);
    }



    /*
    =================================================
    Questions
    =================================================
    */

    /**
    * \struct Answer Answer.h
    * Represents the answer of an examinee to a Question as a vector of strings.
    *
    * For most questions, the examinee may just provide a single string as an
    * answer, so the vector will be of size 1. If the expected answer is more
    * complex in structure (for example, mapping some elements together or drawing
    * something), the answer can be encoded as a sequence of strings, and so the
    * vector is likely to have a size greater than 1.
    *
    * The Answer class implements a virtual method isEqualTo() that compares an
    * Answer with another one and which can be overriden in derived classes. This
    * method is important, as it is this method that is called to determine whether
    * an Answer is correct for a particular Question (it must be among the
    * Question's set of correct answers). By default, two answers are said to be
    * equal if they contain exactly the same string elements and in the same order.
    * Derived classes might change this behavior and adapt to other Answer
    * structures (e.g. when the order does not matter for the Answer to be correct).
    */
    struct Answer
    {

        /** The elements of the answer */
        std::vector<std::string> elements;

        /** Builds an empty Answer */
        Answer();

        /**
        * Builds an Answer containing one single element.
        * @param[in] element The element to put in the Answer.
        */
        Answer(const std::string& element);

        /**
        * Builds an Answer containing multiple elements.
        * @param[in] elements The elements to put in the Answer.
        */
        Answer(const std::vector<std::string>& elements);

        /**
        * Compares two answers together. Two answers are considered equal if they
        * contain the exact same elements, and in the same order.
        * @param[in] answer1 The first Answer to compare.
        * @param[in] answer2 The second Answer to compare.
        */
        friend bool operator==(const Answer& answer1, const Answer& answer2);
    };

    /**
    * \struct Question Question.h
    * A Question ready to be asked to the examinee as part of a test or quizz.
    */
    struct Question
    {

        /** The Question's prompt represented as a string */
        std::string prompt;

        /** All answers accepted as correct */
        std::vector<Answer> correctAnswers;

        /** The explanation for why the correct answers are what they are */
        std::string explanation;

        /** Builds an empty Question */
        Question();

        /**
        * Builds a Question with a single correct answer.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] correctAnswer The correct answer to the Question.
        * @param[in] explanation The reason why the correct answer is the one given.
        */
        Question(const std::string& prompt, const Answer& correctAnswer, const std::string& explanation);

        /**
        * Builds a Question with multiple correct answers
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] correctAnswers The correct answers to the Question.
        * @param[in] explanation The reason why the correct answers are the ones
        *   given.
        */
        Question(const std::string& prompt, const std::vector<Answer>& correctAnswers, const std::string& explanation);

        /**
        * Returns true if the answer is given in argument is correct, and false
        * otherwise.
        *
        * By default, this method checks if the given answer appears as is in the
        * list of correct answers for this question. Derived classes can override
        * this method to allow for a more elaborate check (the method is virtual
        * for this purpose).
        * @param[in] answer The Answer to check.
        */
        virtual bool isAnswerCorrect(const Answer& answer) const;
    };

    /**
    * \struct MultipleChoiceQuestion MultipleChoiceQuestion.h
    * A type of Question where multiple options to choose from are presented to the
    * examinee.
    */
    struct MultipleChoiceQuestion :
        public Question
    {
        /**
        * \struct Option MultipleChoiceQuestion.h
        * An Option that can be chosen by the examinee to answer the question.
        */
        struct Option
        {
            /**
            * An identifier to refer to the Option. It must be unique within the
            * scope of the MultipleChoiceQuestion the Option belongs to.
            *
            * The identifier may be made visible to the examinee, so it must be
            * simple. Typically, this can be a letter (option 'A', option 'B', etc.)
            * or a number (option '1', option '2', etc.).
            */
            std::string identifier;

            /**
            * The actual value of the option that the examinee has to decide upon.
            *
            * For a multiple choice question, it would make sense for the value to
            * be one element of at least one of the correct answers, but this
            * constraint is not enforced.
            */
            std::string value;
        };

        /** The options to choose from */
        std::vector<Option> options;

        /** Builds an empty MultipleChoiceQuestion */
        MultipleChoiceQuestion();

        /**
        * Builds a MultipleChoiceQuestion with a single correct answer.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] options The options for the examinee to choose from.
        * @param[in] correctAnswer The correct answer to the Question.
        * @param[in] explanation The reason why the correct answer is the one given.
        */
        MultipleChoiceQuestion(const std::string& prompt, const std::vector<Option>& options, const Answer& correctAnswer, const std::string& explanation);

        /**
        * Builds a MultipleChoiceQuestion with multiple correct answers
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] options The options for the examinee to choose from.
        * @param[in] correctAnswers The correct answers to the Question.
        * @param[in] explanation The reason why the correct answers are the ones
        *   given.
        */
        MultipleChoiceQuestion(const std::string& prompt, const std::vector<Option>& options, const std::vector<Answer>& correctAnswers, const std::string& explanation);
    };



    /*
    =================================================
    Units for Question Generators
    =================================================
    */

    /**
    * \class TokenReplacementUnit TokenReplacementUnit.h
    * A Factory::Unit that aims at filling a question's prompt and its explanation
    * field through a token replacement mechanism.
    *
    * The unit relies on a set of tokens and a Bucket of replacement strings. The
    * unit uses its input key to choose a replacement string and then replaces any
    * occurrence of any of the tokens with this replacement string by the
    * intermediate of a ReplacementProcessor.
    */
    class TokenReplacementUnit :
        public Factory<MultipleChoiceQuestion>::Unit
    {
    public:

        /**
        * \class ReplacementProcessor StringBucket.h
        * A Pipeline::Processor object that fills the prompt and explanation fields
        * of a question by replacing some tokens with a replacement string.
        */
        class ReplacementProcessor :
            public Pipeline<MultipleChoiceQuestion>::Processor
        {
        public:

            /**
            * Creates a ReplacementProcessor that will replace any occurrence of the
            * given tokens by the replacement string.
            * @param[in] tokens The tokens to replace.
            * @param[in] replacementString The string to replace the tokens with.
            */
            ReplacementProcessor(const std::vector<std::string>& tokens, const std::string& replacementString);

            /**
            * Replaces any occurrence of the supported tokens with the replacement
            * string inside the question's prompt and explanation fields.
            * @param[in] question The question to perform the replacement on.
            */
            void process(MultipleChoiceQuestion& question) const override;

        private:

            /** The tokens to replace. */
            std::vector<std::string> m_tokens;

            /** The string to replace the tokens with. */
            std::string m_replacementString;
        };

        /**
        * Returns the set of keys supported by the unit.
        *
        * If the unit does not contain any replacement string or has no registered
        * token, then it is not usable, so the only key it supports is the null key
        * OPENTESTING_NULL_KEY ("N").
        *
        * On the other hand, if the unit contains at least one replacement string
        * and one token to replace, then the keys it supports are all the strings
        * representing a valid index between 0 and getSize() - 1 included, i.e. "0",
        * "1", "2", etc.
        */
        std::set<std::string> getKeys() const override;

        /**
        * Returns the number of keys supported by the unit.
        */
        size_t getNumKeys() const override;

        /**
        * Picks a replacement string and generates a Pipeline::Processor that
        * replaces all registered tokens with this string.
        * @param[in] key The key to use to pick the replacement string. If the unit
        *   does not contain any replacement string or has no registered token, then
        *   it is not usable, so the key must be equal to the null key
        *   OPENTESTING_NULL_KEY ("N"), in which case the unit will generate an
        *   InactiveProcessor that does not perform any operation. Otherwise, it
        *   must be a string representing a valid index between 0 and getSize() - 1
        *   included, e.g. "0", "1", "2", etc., in which case the unit will return
        *   an appropriate ReplacementProcessor that uses that string.
        */
        std::unique_ptr<Pipeline<MultipleChoiceQuestion>::Processor> generate(const std::string& key) const;

        /**
        * Returns all the tokens handled by the unit.
        */
        const std::vector<std::string>& getTokens() const;

        /**
        * Returns the replacement strings contained in the unit.
        */
        const std::vector<std::string>& getStrings() const;

        /**
        * Returns the number of replacement strings in the unit.
        */
        size_t getSize() const;

        /**
        * Adds a token to be used for replacement by the unit.
        * @param[in] token The token to add.
        */
        void addToken(const std::string& token);

        /**
        * Removes a token from the unit so the latter no longer handles it. If the
        * token given in argument is not currently supported by the unit, an invalid
        * argument exception is thrown.
        * @param[in] token The token to remove.
        */
        void removeToken(const std::string& token);

        /**
        * Removes all tokens from the unit.
        */
        void clearTokens();

        /**
        * Adds a replacement string to the unit.
        * @param[in] stringToAdd The string to add.
        */
        void addString(const std::string& stringToAdd);

        /**
        * Removes a replacement string from the unit. If the string given in
        * argument is not currently a replacement string in the unit, an invalid
        * argument exception is thrown.
        * @param[in] stringToRemove The string to remove.
        */
        void removeString(const std::string& stringToRemove);

        /**
        * Removes all replacement strings from the unit.
        */
        void clearStrings();

    protected:

        /**
        * Makes sure that no token appear in no replacement string, since otherwise
        * the ReplacementProcessor could enter an infinite loop while trying to
        * replace the token with this replacement string. If at least one token is
        * found in at least one of the replacement strings, an invalid argument
        * exception is thrown.
        */
        void checkForInfiniteLoop() const;

    private:

        /** The tokens registered for the unit. */
        std::vector<std::string> m_tokens;

        /** The bucket containing all possible replacement strings. */
        Bucket<std::string> m_bucket;
    };



    /*
    =================================================
    Question Generators
    =================================================
    */

    /**
    * \class GenericQuestionGenerator GenericQuestionGenerator.h
    * An object that generates a Question and returns a pointer to it, in the form
    * of a pointer to the most generic Question type, hence the name.
    */
    class GenericQuestionGenerator :
        public Generator<std::unique_ptr<Question>>
    {
    public:

        /**
        * Generates a Question and then casts it to the desired type. If the
        * Question generated could not be converted to the desired type, then this
        * method will return a null pointer.
        *
        * Note that casting is not compatible with exclusive ownership, so this
        * method returns a shared pointer instead of a unique pointer.
        * @param[in] key The key to use to generate the Question.
        */
        template<class QuestionType>
        std::shared_ptr<QuestionType> generateAndCast(const std::string& key) const;
    };

    template<class QuestionType>
    inline std::shared_ptr<QuestionType> GenericQuestionGenerator::generateAndCast(const std::string& key) const
    {
        /* We generate the question */
        std::unique_ptr<Question> question = generate(key);

        /* We turn the unique pointer into a shared pointer for dynamic casting */
        std::shared_ptr<Question> questionToCast = std::move(question);

        /* And finally we return the result of the casting operation */
        return std::dynamic_pointer_cast<QuestionType>(questionToCast);
    }

    /**
    * \class QuestionGenerator QuestionGenerator.h
    * A QuestionGenerator specialized in generating a particular type of Question.
    */
    template<class QuestionType>
    class QuestionGenerator :
        public GenericQuestionGenerator
    {
    public:

        /** A shorthand for the type of Factory used in the QuestionGenerator */
        typedef KeyDelimitedFactory<QuestionType> QuestionFactory;

        /** A shorthand for the type of Unit supported by the KeyDelimitedFactory */
        typedef typename QuestionFactory::Unit FactoryUnit;

        /** A shorthand for the type of objects generated by each Factory Unit */
        typedef typename QuestionFactory::Processor Processor;

        /** Defining a Table as a vector of factories */
        typedef std::vector<QuestionFactory> Table;

        /**
        * Returns all the keys supported by the QuestionGenerator. The keys are
        * obtained by computing the Cartesian product of all possible factory keys
        * and then concatenating each Factory's identifier with each of its keys
        * with a character delimiter.
        *
        * Note that, as a result, if any factory in the QuestionGenerator has a unit
        * that does not support any key, then the whole factory will not either, and
        * so the factory will be ignored and skipped when generating the keys.
        */
        std::set<std::string> getKeys() const override;

        /**
        * Returns the number of keys supported by the QuestionGenerator. This number
        * is obtained by first summing for each Table the number of keys supported
        * by its factories, and then multiplying these numbers together.
        *
        * Note that, as a result, if any factory in the QuestionGenerator has a unit
        * that does not support any key, then the whole factory will not either, and
        * so the factory will be ignored and not accounted for in the total number
        * of keys.
        */
        size_t getNumKeys() const;

        /**
        * Generates a Question based on the given key and returns a pointer to it.
        *
        * To generate a Question, the QuestionGenerator will first initialize a
        * Question object of the appropriate type using the initializeQuestion()
        * method, then pick one single QuestionFactory per Table based on the given
        * key, and use these factories to generate pipelines that will process and
        * complete the Question object.
        *
        * The returned pointer points to a Question of type Question, but the object
        * itself is an instance of the template type QuestionType. It can be casted
        * to the appropriate type later, or with the generateAndCast() method
        * directly. Note that casting requires to turn the pointer into a shared
        * pointer, since the casting operation does not support ownership
        * exclusivity.
        * @param[in] key The key to use for generating the Question.
        */
        std::unique_ptr<Question> generate(const std::string& key) const override;

        /**
        * Creates a new, empty Table and inserts it at the end of the
        * QuestionGenerator's Table container.
        */
        void appendTable();

        /**
        * Creates a new, empty QuestionFactory and inserts it at the end of the
        * given Table.
        * @param[in] tableIdentifier The index of the Table to add the
        *   QuestionFactory to. It must be in bound, i.e. non negative and less than
        *   the number of tables in the QuestionGenerator.
        */
        void appendFactory(int tableIdentifier);

        /**
        * Adds the given FactoryUnit at the end of the desired QuestionFactory.
        *
        * Note that the pointer to the unit given in argument will be moved to the
        * factory's internal storage, so it should not be accessed anymore after
        * this method is called.
        * @param[in] tableIdentifier The index of the Table containing the
        *   QuestionFactory where to make the insertion. It must be in bound, i.e.
        *   non negative and less than the number of tables in the
        *   QuestionGenerator.
        * @param[in] factoryIdentifier The index of the desired QuestionFactory
        *   to add the unit to within the Table. It must be in bound, i.e. non
        *   negative and less than the number of factories in the Table.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void appendFactoryUnit(int tableIdentifier, int factoryIdentifier, std::unique_ptr<FactoryUnit> unit);

        /**
        * Removes and destroys all units from the given QuestionFactory.
        * @param[in] tableIdentifier The index of the Table containing the
        *   QuestionFactory to clear. It must be in bound, i.e. non negative and
        *   less than the number of tables in the QuestionGenerator.
        * @param[in] factoryIdentifier The index of the desired QuestionFactory
        *   to clear within the Table. It must be in bound, i.e. non negative and
        *   less than the number of factories in the Table.
        */
        void clearFactory(int tableIdentifier, int factoryIdentifier);

        /**
        * Removes and destroys all factories and their units from the given Table.
        * @param[in] tableIdentifier The index of the Table to clear. It must be in
        *   bound, i.e. non negative and less than the number of tables in the
        *   QuestionGenerator.
        */
        void clearTable(int tableIdentifier);

        /**
        * Removes and destroys all tables and their content from the
        * QuestionGenerator.
        */
        void clear();

    protected:

        /**
        * Initializes a Question object of the appropriate type.
        *
        * This method is the first method called for generating a Question. The
        * returned object is then passed to a series of pipelines that modifies it,
        * one step at a time.
        *
        * This method is virtual so it can be overriden in derived classes. By
        * default, it just calls the default constructor of the appropriate Question
        * class.
        */
        virtual std::unique_ptr<QuestionType> initializeQuestion() const;

    private:

        /** The factory tables to pick from when generating the Question */
        std::vector<Table> m_tables;
    };

    template<class QuestionType>
    inline std::set<std::string> QuestionGenerator<QuestionType>::getKeys() const
    {
        std::vector<std::set<std::string>> keysPerTable;
        for (int t = 0; t < m_tables.size(); t++)
        {
            /*
            * We retrieve the keys of each factory and add the factory's index at
            * the beginning of each key as a factory identifier
            */
            std::set<std::string> tableKeys;
            for (int f = 0; f < m_tables[t].size(); f++)
                for (const auto& key : m_tables[t][f].getKeys())
                    tableKeys.insert(String::join({ std::to_string(f), key }, OPENTESTING_DELIMITER_FACTORY_KEY));

            keysPerTable.push_back(tableKeys);
        }

        /* We enumerate all possible combinations of table keys */
        std::vector<std::vector<std::string>> combinations = Enumerator::cartesianProduct<std::set<std::string>, std::vector<std::string>>(keysPerTable);

        /* We then create the keys by joining the combinations */
        std::set<std::string> keys;
        for (const auto& combination : combinations)
            keys.insert(String::join(combination, OPENTESTING_DELIMITER_TABLE_KEY));

        /* We return the result */
        return keys;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::getNumKeys() const
    {
        /* If the generator has no tables, we return 0 */
        if (m_tables.empty())
            return 0;

        /*
        * Otherwise, we multiply together the number of keys supported by each
        * table, which can be obtained by summing the number of keys supported by
        * each factory in the table.
        */
        size_t numKeys = 1;
        for (const auto& table : m_tables)
        {
            size_t numKeysPerTable = 0;
            for (const auto& factory : table)
                numKeysPerTable += factory.getNumKeys();
            numKeys *= numKeysPerTable;
        }
        return numKeys;
    }

    template<class QuestionType>
    inline std::unique_ptr<Question> QuestionGenerator<QuestionType>::generate(const std::string& key) const
    {
        /* We start by initializing a question of the appropriate type */
        std::unique_ptr<QuestionType> question = initializeQuestion();

        /* We then split the key into table keys */
        std::vector<std::string> tableKeys = String::split(key, OPENTESTING_DELIMITER_TABLE_KEY);

        for (int t = 0; t < tableKeys.size(); t++)
        {
            /* We first separate the factory's identifier from its key */
            std::vector<std::string> parts = OT::String::split(tableKeys[t], OPENTESTING_DELIMITER_FACTORY_KEY);
            int factoryID = std::stoi(parts[0]);
            std::string factoryKey = parts[1];

            /* We then generate a pipeline... */
            const Pipeline<QuestionType> pipeline = m_tables[t][factoryID].generate(factoryKey);

            /* ... And then use it to process the question */
            pipeline.process(*question);
        }

        /* Once the question has been processed by all factories, we return it */
        return question;
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::appendTable()
    {
        m_tables.push_back({});
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::appendFactory(int tableIdentifier)
    {
        m_tables[tableIdentifier].push_back({});
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::appendFactoryUnit(int tableIdentifier, int factoryIdentifier, std::unique_ptr<FactoryUnit> unit)
    {
        m_tables[tableIdentifier][factoryIdentifier].append(std::move(unit));
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clearFactory(int tableIdentifier, int factoryIdentifier)
    {
        m_tables[tableIdentifier][factoryIdentifier].clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clearTable(int tableIdentifier)
    {
        m_tables[tableIdentifier].clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clear()
    {
        m_tables.clear();
    }

    template<class QuestionType>
    inline std::unique_ptr<QuestionType> QuestionGenerator<QuestionType>::initializeQuestion() const
    {
        return std::make_unique<QuestionType>();
    }
}