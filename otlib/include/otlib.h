/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <vector>
#include <algorithm>
#include <memory>

namespace OT
{
    /*
    =================================================
    Utility
    =================================================
    */
    
    /**
    * \class Enumerator Enumerator.h
    * A utility class for enumerating combinations on sets of elements.
    */
    class Enumerator
    {
    public:

        /**
        * The Enumerator class has no constructor since all its methods are static
        * and meant to be used without an Enumerator object.
        */
        Enumerator() = delete;

        /**
        * Computes the Cartesian product of different sets of elements. This method
        * uses a recursive algorithm, and is compatible with all STL containers
        * relevant for OpenTesting.
        * @param[in] sets The sets of elements, stored in a vector.
        */
        template<typename ContainerType>
        static std::vector<ContainerType> cartesianProduct(const std::vector<ContainerType>& sets);
    };

    template<typename ContainerType>
    inline std::vector<ContainerType> Enumerator::cartesianProduct(const std::vector<ContainerType>& sets)
    {
        /*
        * If the vector of sets is empty, we return a singleton containing the empty
        * set only.
        */
        if (sets.empty())
            return { ContainerType() };

        /* We initialize a result vector */
        std::vector<ContainerType> result;

        /* We grab the head and tail of the sets... */
        const ContainerType& head = *sets.cbegin();
        std::vector<ContainerType> tail = sets;
        tail.erase(tail.begin());

        /* ... And we recursively call the cartesianProduct method */
        std::vector<ContainerType> tailProduct = cartesianProduct(tail);
        for (const auto& h : head)
            for (const auto& tailElement : tailProduct)
            {
                ContainerType element;
                element.insert(element.end(), h);
                for (const auto& x : tailElement)
                    element.insert(element.end(), x);
                result.insert(result.end(), std::move(element));
            }

        /* Finally, we return the result */
        return result;
    }



    /*
    =================================================
    Questions
    =================================================
    */

    /**
    * \struct Answer Answer.h
    * Represents the answer of an examinee to a Question as a vector of strings.
    *
    * For most questions, the examinee may just provide a single string as an
    * answer, so the vector will be of size 1. If the expected answer is more
    * complex in structure (for example, mapping some elements together or drawing
    * something), the answer can be encoded as a sequence of strings, and so the
    * vector is likely to have a size greater than 1.
    *
    * The Answer class implements a virtual method isEqualTo() that compares an
    * Answer with another one and which can be overriden in derived classes. This
    * method is important, as it is this method that is called to determine whether
    * an Answer is correct for a particular Question (it must be among the
    * Question's set of correct answers). By default, two answers are said to be
    * equal if they contain exactly the same string elements and in the same order.
    * Derived classes might change this behavior and adapt to other Answer
    * structures (e.g. when the order does not matter for the Answer to be correct).
    */
    struct Answer
    {

        /** The elements of the answer */
        std::vector<std::string> elements;

        /** Builds an empty Answer */
        Answer();

        /**
        * Builds an Answer containing one single element.
        * @param[in] element The element to put in the Answer.
        */
        Answer(const std::string& element);

        /**
        * Builds an Answer containing multiple elements.
        * @param[in] elements The elements to put in the Answer.
        */
        Answer(const std::vector<std::string>& elements);

        /**
        * Compares two answers together. Two answers are considered equal if they
        * contain the exact same elements, and in the same order.
        * @param[in] answer1 The first Answer to compare.
        * @param[in] answer2 The second Answer to compare.
        */
        friend bool operator==(const Answer& answer1, const Answer& answer2);
    };

    /**
    * \struct Question Question.h
    * A Question ready to be asked to the examinee as part of a test or quizz.
    */
    struct Question
    {

        /** The Question's prompt represented as a string */
        std::string prompt;

        /** All answers accepted as correct */
        std::vector<Answer> correctAnswers;

        /** The explanation for why the correct answers are what they are */
        std::string explanation;

        /** Builds an empty Question */
        Question();

        /**
        * Builds a Question with a single correct answer.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] correctAnswer The correct answer to the Question.
        * @param[in] explanation The reason why the correct answer is the one given.
        */
        Question(const std::string& prompt, const Answer& correctAnswer, const std::string& explanation);

        /**
        * Builds a Question with multiple correct answers
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] correctAnswers The correct answers to the Question.
        * @param[in] explanation The reason why the correct answers are the ones
        *   given.
        */
        Question(const std::string& prompt, const std::vector<Answer>& correctAnswers, const std::string& explanation);

        /**
        * Returns true if the answer is given in argument is correct, and false
        * otherwise.
        *
        * By default, this method checks if the given answer appears as is in the
        * list of correct answers for this question. Derived classes can override
        * this method to allow for a more elaborate check (the method is virtual
        * for this purpose).
        * @param[in] answer The Answer to check.
        */
        virtual bool isAnswerCorrect(const Answer& answer) const;
    };

    /**
    * \struct MultipleChoiceQuestion MultipleChoiceQuestion.h
    * A type of Question where multiple options to choose from are presented to the
    * examinee.
    */
    struct MultipleChoiceQuestion :
        public Question
    {
        /**
        * \struct Option MultipleChoiceQuestion.h
        * An Option that can be chosen by the examinee to answer the question.
        */
        struct Option
        {
            /**
            * An identifier to refer to the Option. It must be unique within the
            * scope of the MultipleChoiceQuestion the Option belongs to.
            *
            * The identifier may be made visible to the examinee, so it must be
            * simple. Typically, this can be a letter (option 'A', option 'B', etc.)
            * or a number (option '1', option '2', etc.).
            */
            std::string identifier;

            /**
            * The actual value of the option that the examinee has to decide upon.
            *
            * For a multiple choice question, it would make sense for the value to
            * be one element of at least one of the correct answers, but this
            * constraint is not enforced.
            */
            std::string value;
        };

        /** The options to choose from */
        std::vector<Option> options;

        /** Builds an empty MultipleChoiceQuestion */
        MultipleChoiceQuestion();

        /**
        * Builds a MultipleChoiceQuestion with a single correct answer.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] options The options for the examinee to choose from.
        * @param[in] correctAnswer The correct answer to the Question.
        * @param[in] explanation The reason why the correct answer is the one given.
        */
        MultipleChoiceQuestion(const std::string& prompt, const std::vector<Option>& options, const Answer& correctAnswer, const std::string& explanation);

        /**
        * Builds a MultipleChoiceQuestion with multiple correct answers
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] options The options for the examinee to choose from.
        * @param[in] correctAnswers The correct answers to the Question.
        * @param[in] explanation The reason why the correct answers are the ones
        *   given.
        */
        MultipleChoiceQuestion(const std::string& prompt, const std::vector<Option>& options, const std::vector<Answer>& correctAnswers, const std::string& explanation);
    };



    /*
    =================================================
    Generator
    =================================================
    */

    /**
    * \class Generator Generator.h
    * An object that can generate another object based on a key provided as a
    * string.
    */
    template<class GeneratedType>
    class Generator
    {
    public:

        /**
        * Returns the list of keys that are supported by the generator.
        */
        virtual std::vector<std::string> getKeys() const = 0;

        /**
        * Returns the number of keys supported by this generator.
        *
        * By default, this method generates all possible keys and counts them. If
        * there exists a faster way to compute this result, the method can be
        * overriden in derived classes to use a faster implementation (it is
        * virtual for that purpose).
        */
        virtual size_t getNumKeys() const;

        /**
        * Returns true if the key given in argument is a valid key for this
        * generator and false otherwise.
        *
        * By default, this method generates all possible keys and checks if the
        * given key appears in the list. If there exists a faster way to compute
        * this result, the method can be overriden in derived classes to use a
        * faster implementation (it is virtual for that purpose).
        * @param[in] key The key to check the validity of.
        */
        virtual bool isValidKey(const std::string& key) const;

        /**
        * Generates an object based on the given key. This method must be
        * implemented in derived classes, with the constraint that the same key must
        * generate the same object.
        * @param[in] key The key to use to generate the object. The key must be
        *   valid (see the getKeys() method for a list of valid keys).
        */
        virtual GeneratedType generate(const std::string& key) const = 0;

        /**
        * Retrieves all possible keys for this generator and uses the one at the
        * given index to generate a new object.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as
        *   returned by the getKeys() method.
        */
        virtual GeneratedType generateFromIndex(int keyIndex) const;
    };

    template<class GeneratedType>
    inline size_t Generator<GeneratedType>::getNumKeys() const
    {
        return getKeys().size();
    }

    template<class GeneratedType>
    inline bool Generator<GeneratedType>::isValidKey(const std::string& key) const
    {
        std::vector<std::string> validKeys = getKeys();
        return std::find(validKeys.cbegin(), validKeys.cend(), key) != validKeys.cend();
    }

    template<class GeneratedType>
    inline GeneratedType Generator<GeneratedType>::generateFromIndex(int keyIndex) const
    {
        return generate(getKeys()[keyIndex]);
    }



    /*
    =================================================
    QuestionGenerator
    =================================================
    */

    /**
    * \class Pipeline Pipeline.h
    * A generation Pipeline that builds a Question object by processing it one step
    * at a time.
    *
    * A Pipeline consists of a sequence of processors that each completes or
    * modifies a Question object. For example, a Processor can replace tokens in a
    * Question's prompt by some text, or add some options to a
    * MultipleChoiceQuestion. Once a Question traverses a Pipeline, it ends up in
    * its final state and is be ready to presented to the examinee.
    */
    template<class QuestionType>
    class Pipeline
    {
    public:

        /**
        * \struct Processor Pipeline.h
        * A processing unit that is part of a generation Pipeline and that aims at
        * completing or modifying an existing Question object.
        */
        struct Processor
        {
            /**
            * Processes the question given in argument. This method must be
            * implemented in all classes derived from Processor.
            * @param[in] question The Question to process. This object is meant to
            *   be modified by this method.
            */
            virtual void process(QuestionType& question) const = 0;
        };

        /**
        * Adds a Processor at the end of the Pipeline.
        *
        * Note that the pointer given in argument will be moved to the Pipeline's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] processor A pointer to the Processor to add. The pointer will
        *   be moved inside the Pipeline by this method, so it should not be
        *   accessed anymore after this method is called.
        */
        void append(std::unique_ptr<Processor> processor);

        /**
        * Passes the question given in argument throughout the whole pipeline,
        * calling one Processor at a time in the order in which they were inserted
        * with the append() method.
        * @param[in] question The Question to process. This object is meant to be
        *   modified by this method.
        */
        void process(QuestionType& question) const;

    private:

        /** The sequence of processors constituting the Pipeline */
        std::vector<std::unique_ptr<Processor>> m_processors;
    };

    template<class QuestionType>
    inline void Pipeline<QuestionType>::append(std::unique_ptr<Processor> processor)
    {
        /* We move the pointer into the Pipeline's internal storage */
        m_processors.push_back(std::move(processor));
    }

    template<class QuestionType>
    inline void Pipeline<QuestionType>::process(QuestionType& question) const
    {
        /* We pass the question throughout the processing pipeline */
        for (const auto& processor : m_processors)
            processor->process(question);
    }

    /**
    * \class Factory Factory.h
    * An object that generates a Pipeline for processing questions.
    *
    * Derived classes must implement the Pipeline generation mechanism. The easiest
    * way to do so is to use a fundamental tool that is built in the Factory class:
    * the Unit subclass. Note that one can always implement a custom mechanism if
    * preferred, and ignore the Unit-related attributes and methods in this class.
    *
    * A Unit is an elementary block of a Factory that can generate a
    * Pipeline::Processor object, i.e. the elementary block of a Pipeline. In that
    * sense, Unit-based factories and pipelines work hand in hand, the elements of
    * one generating the elements of the other. One can therefore derive from the
    * Unit class and just implement the generation of each single Processor, with
    * the Factory class taking care of chaining all the processors together into a
    * Pipeline.
    *
    * Units work with their individual keys, which are called "unit keys". Derived
    * classes can implement a way to split a factory key into multiple unit keys to
    * generate a Pipeline and its elements, or simply pass the same factory key to
    * all units and implement their parsing as best fits. The former version is more
    * common in OpenTesting. For example, a simple delimiting character mechanism is
    * used in the QuestionGenerator class to split an initial key into multiple unit
    * keys.
    */
    template<class QuestionType>
    class Factory :
        public Generator<Pipeline<QuestionType>>
    {
    public:

        /** A shorthand for Pipeline::Processor */
        typedef typename Pipeline<QuestionType>::Processor Processor;

        /** Definition of the Unit subclass as a Processor Generator */
        typedef Generator<std::unique_ptr<Processor>> Unit;

        /**
        * Adds a Unit at the end of the Factory.
        *
        * Note that the pointer given in argument will be moved to the Factory's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the Factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void append(std::unique_ptr<Unit> unit);

        /**
        * Removes and destroys all units from the Factory.
        */
        void clear();

        /**
        * Returns the sets of keys that is supported by each Unit. The returned
        * object is a vector where one element correspond to the set of keys
        * supported by the Unit at the same position in the Factory.
        */
        std::vector<std::vector<std::string>> getUnitKeys() const;

        /**
        * Returns all the possible combinations of individual unit keys that can be
        * sent the Factory's units to generate a Pipeline. These combinations are
        * computed using a simple Cartesian product. For example, if the Factory
        * contains two units with one supporting the keys "K1" and "K2" and one
        * supporting "KA" and "KB", then this method will return the 4 combinations
        * ("K1", "KA"), ("K1", "KB"), ("K2", "KA"), and ("K2", "KB").
        *
        * This method can be used to compute the set of all possible keys that can
        * be sent to the Factory itself. If the Factory just splits its own key into
        * unit keys based on a delimiter for example, which is a typical mechanism
        * implemented in the QuestionGenerator class, then joining each set of unit
        * key as returned by this method would lead to the set of all valid keys
        * supported by the Factory. If '-' was used as a delimiter in the example
        * above for instance, then the Factory's valid keys would be "K1-KA",
        * "K1-KB", "K2-K1", and "K2-KB".
        */
        std::vector<std::vector<std::string>> getAllUnitKeysCombinations() const;

        /**
        * Dispatches each key to its corresponding Unit so they all generate one
        * Pipeline::Processor each, and chains all resulting processors into a
        * Pipeline. Note that each key is sent to the Unit at the same position in
        * the Factory as the key in the vector argument, i.e. the first key in the
        * vector passed in argument will be sent to the first Unit, and so on.
        * @param[in] unitKeys The individual keys to send to each Unit. The size of
        *   this vector must match exactly the number of units in the Factory, and
        *   each key must be valid for its target Unit.
        */
        Pipeline<QuestionType> generateFromUnits(const std::vector<std::string>& unitKeys) const;

    private:

        /** The Factory's units */
        std::vector<std::unique_ptr<Unit>> m_units;
    };

    template<class QuestionType>
    inline void Factory<QuestionType>::append(std::unique_ptr<Unit> unit)
    {
        /* We move the pointer into the Factory's internal storage */
        m_units.push_back(std::move(unit));
    }

    template<class QuestionType>
    inline void Factory<QuestionType>::clear()
    {
        m_units.clear();
    }

    template<class QuestionType>
    inline std::vector<std::vector<std::string>> Factory<QuestionType>::getUnitKeys() const
    {
        /* We list and add all the keys for each unit */
        std::vector<std::vector<std::string>> unitKeys;
        for (const auto& unit : m_units)
            unitKeys.push_back(unit->getKeys());
        return unitKeys;
    }

    template<class QuestionType>
    inline std::vector<std::vector<std::string>> Factory<QuestionType>::getAllUnitKeysCombinations() const
    {
        /* We compute the Cartesian product across all possible unit keys. */
        return Enumerator::cartesianProduct(getUnitKeys());
    }

    template<class QuestionType>
    inline Pipeline<QuestionType> Factory<QuestionType>::generateFromUnits(const std::vector<std::string>& unitKeys) const
    {
        /* We start with an empty pipeline */
        Pipeline<QuestionType> pipeline;

        for (int i = 0; i < unitKeys.size(); i++)
        {
            /* We generate a processor... */
            std::unique_ptr<Processor> processor = m_units[i]->generate(unitKeys[i]);

            /* ... And add it to the pipeline */
            pipeline.append(std::move(processor));
        }

        /* We return the finished pipeline */
        return pipeline;
    }



    /*
    =================================================
    Filler
    =================================================
    */

    /**
    * \class Filler Filler.h
    * An object that fills a string by replacing a specific token with a filler
    * text.
    */
    class Filler
    {
    public:

        /**
        * Creates a new Filler for the given token.
        * @param[in] token The token to replace.
        */
        Filler(const std::string& token);

        /**
        * Creates a new Filler for the given token and filler text.
        * @param[in] token The token to replace.
        * @param[in] fillerText The text to replace the token with.
        */
        Filler(const std::string& token, const std::string& fillerText);

        /**
        * Defines the token to replace.
        * @param[in] token The token to replace.
        */
        void setToken(const std::string& token);

        /**
        * Defines the text to replace the token with.
        * @param[in] fillerText The text to replace the token with.
        */
        void setFillerText(const std::string& fillerText);

        /**
        * Replaces all occurrences of the token with the filler text in the string
        * passed in argument. The string is modified in place.
        * @param[in] textToFill The string to modify by replacing the token with the
        *   filler text. This string is passed by reference and modified in place.
        */
        void fill(std::string& textToFill) const;

    private:

        /**
        * Makes sure the token is not part of the filler text, since otherwise the
        * Filler will enter an infinite loop while trying to replace the token with
        * its filler text. If the token is found in the filler text, an invalid
        * argument exception will be thrown.
        */
        void checkForInfiniteLoop() const;

        /** The token to replace */
        std::string m_token;

        /** The text to replace the token with */
        std::string m_fillerText;
    };



    /*
    =================================================
    Buckets
    =================================================
    */

    /**
    * \class StringBucket StringBucket.h
    * A bucket of phrases to pick from.
    */
    class StringBucket :
        public Generator<std::string>
    {
    public:

        /**
        * Creates a StringBucket from a list of phrases.
        * @param[in] phrases The phrases to start with in the bucket.
        */
        StringBucket(std::vector<std::string> phrases = std::vector<std::string>());

        /**
        * Returns the phrases contained in the bucket.
        */
        std::vector<std::string> getPhrases() const;

        /**
        * Returns the list of keys supported by the generator.
        */
        std::vector<std::string> getKeys() const;

        /**
        * Returns the number of keys supported by the generator.
        */
        size_t getNumKeys() const override;

        /**
        * Returns the number of phrases in the bucket.
        */
        size_t getSize() const;

        /**
        * Picks a phrase from the bucket.
        * @param[in] key The key to use to pick the phrase. It must be an integer
        *   represented as a string, and the integer must be non-negative and less
        *   than the size of the bucket.
        */
        std::string generate(const std::string& key) const;

        /**
        * Adds a phrase to the bucket.
        * @param[in] phrase The phrase to add.
        */
        void add(const std::string& phrase);

        /**
        * Removes a phrase from the bucket.  If the phrase is not in the bucket, an
        * invalid argument exception is thrown.
        * @param[in] phrase The phrase to remove.
        */
        void remove(const std::string& phrase);

        /**
        * Empties the bucket.
        */
        void clear();

    protected:

        /**
        * Regenerates the keys based on the phrases contained in the bucket.
        */
        void updateKeys();

    private:

        /**
        * The phrases contained in the bucket.
        */
        std::vector<std::string> m_phrases;

        /**
        * The keys corresponding to each phrase in the bucket.
        */
        std::vector<std::string> m_keys;
    };
}