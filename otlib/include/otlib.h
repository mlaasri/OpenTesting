/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <vector>
#include <algorithm>
#include <iterator>
#include <memory>
#include <type_traits>
#include <typeinfo>
#include <set>
#include <stdexcept>

namespace OT
{
    /*
    =================================================
    General Configuration
    =================================================
    */

    /* Delimiters */

    /** The character delimiting individual Table keys */
    #define OPENTESTING_DELIMITER_TABLE_KEY ','

    /** The character delimiting a Factory's identifier from its key */
    #define OPENTESTING_DELIMITER_FACTORY_KEY '>'

    /** The character delimiting unit keys within a Factory key */
    #define OPENTESTING_DELIMITER_UNIT_KEYS '-'

    /** The character delimiting chosen indices in a Bucket key */
    #define OPENTESTING_DELIMITER_BUCKET_KEY '.'

    /** The character delimiting multiple bucket keys */
    #define OPENTESTING_DELIMITER_BUCKET_KEYS '+'

    /** The character delimiting a permutation key from the rest of a key */
    #define OPENTESTING_DELIMITER_PERMUTATION_KEY '!'

    /* Special Keys */

    /** The key returned by a Generator to indicate it cannot generate an object */
    #define OPENTESTING_NULL_KEY "N"

    /** The key returned by a Generator that only supports one single key */
    #define OPENTESTING_SINGLE_KEY "S"

    /* Symbols */

    /** The default blank symbol for inserting a blank into a prompt */
    #define OPENTESTING_DEFAULT_BLANK_SYMBOL "____________"



    /*
    =================================================
    Utility
    =================================================
    */

    /* General Utility */

    /**
    * \class String String.h
    * A utility class for manipulating strings.
    */
    class String
    {
    public:

        /**
        * The String class has no constructor since all its methods are static and
        * meant to be used without a String object.
        */
        String() = delete;

        /**
        * Splits the given string at any occurrence of the given delimiter.
        * @param[in] string The string to split.
        * @param[in] delimiter The delimiter.
        */
        static std::vector<std::string> split(const std::string& string, char delimiter);

        /**
        * Joins the strings given in argument with a delimiter in between each
        * string.
        * @param[in] strings The strings to join together.
        * @param[in] delimiter The delimiter to insert in between each string.
        */
        static std::string join(const std::vector<std::string>& strings, char delimiter);

        /**
        * Replaces all occurrences of a substring with another.
        * @param[in] string The string to make the replacement in.
        * @param[in] from The substring to replace.
        * @param[in] to The substring to make the replacement with.
        */
        static std::string& replaceAll(std::string& string, const std::string& from, const std::string& to);

        /**
        * Removes all occurrences of the given character in the given string.
        * @param[in] string The string to remove the character from.
        * @param[in] character The character to remove.
        */
        static std::string& removeAll(std::string& string, char character);

        /**
        * Removes any space at the beginning or end of the given string.
        *
        * The following characters are considered a space: the usual space
        * character, the tabulation character, the newline character, the vertical
        * tabulation character, the form feed character, and the carriage return
        * character.
        * @param[in] string The string to trim.
        */
        static std::string& trim(std::string& string);

        /**
        * Removes any space at the beginning of the given string.
        *
        * The following characters are considered a space: the usual space
        * character, the tabulation character, the newline character, the vertical
        * tabulation character, the form feed character, and the carriage return
        * character.
        * @param[in] string The string to trim.
        */
        static std::string& trimLeft(std::string& string);

        /**
        * Removes any space at the end of the given string.
        *
        * The following characters are considered a space: the usual space
        * character, the tabulation character, the newline character, the vertical
        * tabulation character, the form feed character, and the carriage return
        * character.
        * @param[in] string The string to trim.
        */
        static std::string& trimRight(std::string& string);

        /**
        * Returns true if the given string starts with the given substring and false
        * otherwise.
        * @param[in] string The string where to look for the substring.
        * @param[in] substring The string to look for.
        */
        static bool startsWith(const std::string& string, const std::string& substring);

        /**
        * Returns true if the given string ends with the given substring and false
        * otherwise.
        * @param[in] string The string where to look for the substring.
        * @param[in] substring The string to look for.
        */
        static bool endsWith(const std::string& string, const std::string& substring);

        /**
        * Returns true if the given string contains the given substring and false
        * otherwise.
        * @param[in] string The string where to look for the substring.
        * @param[in] substring The string to look for.
        */
        static bool contains(const std::string& string, const std::string& substring);

        /**
        * Returns true if the given string contains the given character and false
        * otherwise.
        * @param[in] string The string where to look for the character.
        * @param[in] character The character to look for.
        */
        static bool contains(const std::string& string, char character);
    };
    
    /**
    * \class Enumerator Enumerator.h
    * A utility class for enumerating combinations on sets of elements.
    */
    class Enumerator
    {
    public:

        /**
        * The Enumerator class has no constructor since all its methods are static
        * and meant to be used without an Enumerator object.
        */
        Enumerator() = delete;

        /**
        * Computes the Cartesian product of different sets of elements. This method
        * is compatible with all STL containers relevant for OpenTesting.
        *
        * If the vector passed in argument is empty or contains any empty set
        * inside, then this method will return an empty vector, as per the
        * definition of a Cartesian product.
        * @param[in] sets The sets of elements, stored in a vector. If empty or if
        *   it contains an empty set inside, the method will return an empty vector.
        */
        template<typename InputContainerType, typename OutputContainerType>
        static std::vector<OutputContainerType> cartesianProduct(const std::vector<InputContainerType>& sets);

        /**
        * Enumerates all possibles choices of a fixed number of objects from the
        * given STL container. Choices are made without replacement, so the same
        * object cannot be selected twice, except if it is present in multiple
        * copies in the input container.
        *
        * If K denotes the number of objects to choose and N the number of objects
        * available in the input container, then this method will return a vector
        * containing exactly N choose K elements, provided K is not greater than N.
        * If this is not the case, then this method will return an empty vector.
        *
        * Note that a choice represents a set of objects in which the order does not
        * matter (objects can be selected in any order). By convention, this method
        * will return objects in the order in which they appear in the input
        * container.
        * @param[in] objects The objects to choose from, stored in an STL container.
        *   If empty or if it contains fewer elements than the number of objects to
        *   choose, the method will return an empty vector.
        * @param[in] numObjectsToChoose The number of objects to choose from the
        *   container. It must be less than or equal to the number of objects in the
        *   container.
        */
        template<typename InputContainerType, typename OutputContainerType = InputContainerType>
        static std::vector<OutputContainerType> choices(const InputContainerType& objects, size_t numObjectsToChoose);

        /**
        * Enumerates all possibles permutations of the objects passed in argument.
        *
        * All objects are treated as individual instances and are permutated based
        * on their position in the input container and not on their value.
        * Therefore, if multiple copies of the same object appear in the container,
        * then the output will contain duplicated permutations. For example, the
        * vector {"A", "A"} is treated as two independent, individual strings "A"
        * and will generate two permutations equal to {"A", "A"}. Although they
        * appear identical, these permutations are not the same in the eyes of the
        * algorithm: one left the original vector intact while the other permutated
        * the two As. If unique permutations are needed, one can still use the
        * vector returned by this method and simply build a set container from it.
        *
        * If N denotes the number of objects passed in argument, then this method
        * will return a vector containing exactly N! elements.
        * @param[in] objects The objects to permutate, stored in an STL container.
        */
        template<typename ContainerType>
        static std::vector<ContainerType> permutations(const ContainerType& objects);
    };

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::cartesianProduct(const std::vector<InputContainerType>& sets)
    {
        /* If the vector of sets is empty, we return an empty set. */
        if (sets.empty())
            return {};

        /* If at least one of the sets is empty, we return an empty set. */
        for (const auto& set : sets)
            if (set.empty())
                return {};

        /*
        * Otherwise, we launch the computation, using the following algorithm:
        * assimilating each element in a set with its index in the set, we enumerate
        * all possible combinations of elements by enumerating all possible
        * combinations of indices from each set, which we obtain by incrementing a
        * vector of indices just like counting with a carry in arithmetic.
        *
        * For example, to compute the Cartesian product of {A0, A1} and {B0, B1}, we
        * start with a vector of indices equal to [0, 0] representing (A0, B0) and
        * successively increment the vector of indices to obtain [0, 1], [1, 0], and
        * [1, 1] respectively representing (A0, B1), (A1, B0), and (A1, B1).
        */

        /*
        * We initialize a result vector, a vector of indices, and a vector
        * containing the size of each set to detect when to move the carry over.
        */

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /* We initialize the vector of indices to increment */
        std::vector<size_t> indices(sets.size(), 0);

        /*
        * We initialize a vector containing the size of each set, which will dictate
        * when to move the carry over.
        */
        std::vector<size_t> sizes(sets.size());
        std::transform(sets.cbegin(), sets.cend(), sizes.begin(), [](const InputContainerType& set) { return set.size(); });

        /* Then we start the algorithm */
        do
        {
            /* We add the current combination */
            OutputContainerType combination;
            std::transform(indices.cbegin(), indices.cend(), sets.cbegin(), std::inserter(combination, combination.end()), [](const size_t& index, const InputContainerType& set) { return *std::next(set.cbegin(), index); });
            result.insert(result.end(), std::move(combination));

            /* And we update the indices of the next combination */
            (*indices.rbegin())++;
            for (int i = static_cast<int>(indices.size()) - 1; i >= 0; i--)

                /* Is there a carry to move over? */
                if (indices[i] >= sizes[i])
                {
                    indices[i] = 0;
                    if (i > 0)
                        indices[i - 1]++;
                }
        } while (std::any_of(indices.cbegin(), indices.cend(), [](size_t i) { return i != 0; }));

        /* Finally, we return the result */
        return result;
    }

    template<typename InputContainerType, typename OutputContainerType>
    inline std::vector<OutputContainerType> Enumerator::choices(const InputContainerType& objects, size_t numObjectsToChoose)
    {
        /*
        * If there are not enough objects to choose from, we return an empty vector.
        */
        if (numObjectsToChoose > objects.size())
            return {};

        /* We initialize a result vector */
        std::vector<OutputContainerType> result;

        /*
        * We introduce a selection mask that determines whether an object should be
        * chosen or not. The enumeration of all possible choices then boils down to
        * the enumeration of all possible permutations of the selection mask.
        */
        std::vector<bool> selectionMask(numObjectsToChoose, true);
        selectionMask.resize(objects.size(), false);
        do
        {
            OutputContainerType choice;
            auto it = objects.cbegin();
            for (int i = 0; i < objects.size(); i++)
            {
                if (selectionMask[i])
                    choice.insert(choice.end(), *it);
                it++;
            }
            result.insert(result.end(), choice);
        } while (std::prev_permutation(selectionMask.begin(), selectionMask.end()));

        /* We return the result */
        return result;
    }

    template<typename ContainerType>
    inline std::vector<ContainerType> Enumerator::permutations(const ContainerType& objects)
    {
        /* We list all valid indices for the input container */
        std::vector<int> indices(objects.size());
        for (int i = 0; i < objects.size(); i++)
            indices[i] = i;

        /* We initialize a result vector */
        std::vector<ContainerType> result;

        /* And we permutate the objects based on their indices */
        do
        {
            ContainerType permutation;
            for (const auto& index : indices)
                permutation.insert(permutation.end(), *std::next(objects.cbegin(), index));
            result.insert(result.end(), permutation);
        } while (std::next_permutation(indices.begin(), indices.end()));

        /* We return the result */
        return result;
    }

    /**
    * \class TypeTraits TypeTraits.h
    * A utility class for retrieving type traits.
    */
    class TypeTraits
    {
    public:

        /**
        * The TypeTraits class has no constructor since all its content is static
        * and meant to be used without a TypeTraits object.
        */
        TypeTraits() = delete;

        /**
        * The default type trait for indicating whether a type is an
        * std::unique_ptr. Its internal value is a boolean that is equal to false
        * since, by default, a type is not a unique pointer.
        */
        template<typename NonUniquePtrType>
        struct isUniquePtr
        {
            /**
            * The value of the type trait, which is equal to false since, by
            * default, a type is not a unique pointer.
            */
            static const bool value = false;
        };

        /**
        * The specialized type trait for indicating whether a type is an
        * std::unique_ptr. Its internal value is a boolean that is equal to true
        * since the specialized type is an std::unique_ptr.
        */
        template<class UniquePtrValueType, typename UniquePtrDeleterType>
        struct isUniquePtr<std::unique_ptr<UniquePtrValueType, UniquePtrDeleterType>>
        {
            /**
            * The value of the type trait, which is equal to true since the
            * specialized type is an std::unique_ptr.
            */
            static const bool value = true;
        };

        /**
        * The default type trait for indicating whether a type is an std::vector
        * container. Its internal value is a boolean that is equal to false since,
        * by default, a type is not a vector.
        */
        template<class NonVectorType>
        struct isVector
        {
            /**
            * The value of the type trait, which is equal to false since, by
            * default, a type is not a vector.
            */
            static const bool value = false;
        };

        /**
        * The specialized type trait for indicating whether a type is an std::vector
        * container. Its internal value is a boolean that is equal to true since the
        * specialized type is an std::vector.
        */
        template<class VectorValueType, typename VectorAllocatorType>
        struct isVector<std::vector<VectorValueType, VectorAllocatorType>>
        {
            /**
            * The value of the type trait, which is equal to true since the
            * specialized type is an std::vector.
            */
            static const bool value = true;
        };

        /**
        * The default type trait for indicating whether a type is an std::vector
        * of a particular type of objects or a derived class from that type. Its
        * internal value is a boolean that is equal to false since, by default, a
        * type does not match this criteria.
        */
        template<class NonVectorType, class BaseType>
        struct isVectorOfDerived
        {
            /**
            * The value of the type trait, which is equal to false since, by
            * default, a type does not match the desired criteria.
            */
            static const bool value = false;
        };

        /**
        * The specialized type trait for indicating whether a type is an std::vector
        * of a particular type of objects or a derived class from that type. Its
        * internal value is a boolean that evaluates if elements in the given vector
        * type derive from the given base type.
        */
        template<class VectorValueType, typename VectorAllocatorType, class BaseType>
        struct isVectorOfDerived<std::vector<VectorValueType, VectorAllocatorType>, BaseType>
        {
            /**
            * The value of the type trait, which is equal to true if and only if the
            * given type is an std::vector whose value type derives from the given
            * base type.
            */
            static const bool value = std::is_base_of<BaseType, VectorValueType>::value;
        };
    };

    /* Serialization */

    /* Forward declaration of the Serialized struct */
    struct Serialized;

    /* Forward declaration of the Bucket class */
    template<class ObjectType>
    class Bucket;

    /* Forward declaration of the Serializable class */
    class Serializable;

    /**
    * \class Writer Writer.h
    * A Writer is an object that serializes data of different types and stores the
    * result into an internal Serialized object.
    *
    * A Writer writes data in the form of key-value pairs where the key must be a
    * string and the value can be any supported object type or data structure (see
    * the signature of all the write() methods for a list of all supported types).
    * Each key must be unique within the scope of the Writer so the data it refers
    * to can be retrieved later with it.
    */
    class Writer
    {
    public:

        /** Creates a new, empty Serialized object and a Writer for it. */
        Writer();

        /** Destroys the Writer and its internal Serialized object. */
        ~Writer();

        /**
        * Serializes the given boolean and stores the result in the internal
        * Serialized object using the given key.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] value The boolean to serialize.
        */
        void write(const std::string& key, bool value);

        /**
        * Serializes the given unsigned integer and stores the result in the
        * internal Serialized object using the given key.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] value The unsigned integer to serialize.
        */
        void write(const std::string& key, size_t value);

        /**
        * Serializes the given string and stores the result in the internal
        * Serialized object using the given key.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] value The string to serialize.
        */
        void write(const std::string& key, const std::string& value);

        /**
        * Serializes the given vector of strings and stores the result in the
        * internal Serialized object using the given key.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] values The vector of strings to serialize.
        */
        void write(const std::string& key, const std::vector<std::string>& values);

        /**
        * Serializes the given Bucket of strings and stores the result in the
        * internal Serialized object using the given key.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] bucket The Bucket of strings to serialize.
        */
        void write(const std::string& key, const Bucket<std::string>& bucket);

        /**
        * Serializes the given Serializable object and stores the result in the
        * internal Serialized object using the given key. The Writer serializes the
        * object by calling its Serializable::serialize() method and passing itself
        * as the writer argument.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] serializable The object to serialize.
        */
        void write(const std::string& key, const Serializable& serializable);

        /**
        * Serializes the given vector of objects and stores the result in the
        * internal Serialized object using the given key. Each object in the vector
        * must derive from the Serializable class. The Writer serializes each object
        * individually by calling its Serializable::serialize() method and passing
        * itself as the writer argument.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] serializables The vector of objects to serialize.
        */
        template<class SerializableType>
        void write(const std::string& key, const std::vector<SerializableType>& serializables);

        /**
        * Serializes the given vector of objects and stores the result in the
        * internal Serialized object using the given key. Each pointer in the vector
        * must point to an object that derives from the Serializable class. The
        * Writer serializes each object individually by calling its
        * Serializable::serialize() method and passing itself as the writer
        * argument.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] serializables The vector of objects to serialize.
        */
        template<class SerializableType>
        void write(const std::string& key, const std::vector<std::unique_ptr<SerializableType>>& serializables);

        /**
        * Converts all the serialized data from the internal Serialized object into
        * a string and returns it. The returned string can later be used for
        * deserialization.
        * @param[in] compact Whether to return the shortest possible string or add
        *   indentation and new lines to make it more human-readable.
        */
        std::string toString(bool compact = true) const;

    protected:

        /** Returns the internal Serialized object. */
        const std::unique_ptr<Serialized>& getSerialized() const;

    private:

        /**
        * Serializes the given vector of object pointers and stores the result in
        * the internal Serialized object using the given key. The Writer serializes
        * each object individually by calling its Serializable::serialize() method
        * and passing itself as the writer argument.
        *
        * This method is a helper function for implementing the similar but
        * templated function for serializing vector of objects.
        * @param[in] key The key to use for identifying the serialized data in the
        *   internal Serialized object. If the Writer already wrote a value with
        *   this key before, the previous value will be erased and replaced with the
        *   new serialized data.
        * @param[in] serializables The vector of objects to serialize.
        */
        void write(const std::string& key, const std::vector<const Serializable*>& serializables);

        /** The internal Serialized object */
        std::unique_ptr<Serialized> m_serialized;
    };

    template<class SerializableType>
    inline void Writer::write(const std::string& key, const std::vector<SerializableType>& serializables)
    {
        /*
        * We simply convert the vector of objects into a vector of object pointers
        * and call the private helper method on it.
        */
        std::vector<const Serializable*> pointers(serializables.size());
        std::transform(serializables.cbegin(), serializables.cend(), pointers.begin(), [](const auto& serializable) { return &serializable; });
        write(key, pointers);
    }

    template<class SerializableType>
    inline void Writer::write(const std::string& key, const std::vector<std::unique_ptr<SerializableType>>& serializables)
    {
        /*
        * We simply convert the vector of unique pointers into a vector of raw
        * pointers and call the private helper method on it.
        */
        std::vector<const Serializable*> pointers(serializables.size());
        std::transform(serializables.cbegin(), serializables.cend(), pointers.begin(), [](const auto& serializable) { return serializable.get(); });
        write(key, pointers);
    }

    /**
    * \class Reader Reader.h
    * A Reader is an object that deserializes data from an internal Serialized
    * object into variables of different types.
    *
    * A Reader can read anything that a Writer can write. More precisely, it can
    * read key-value pairs where keys are strings that uniquely identify their
    * associated value and values are objects of one of the following supported
    * types:
    * - a "basic type", which is any default-constructible type used for the second
    *   argument of any of the protected methods named read() (e.g. booleans,
    *   unsigned integers, strings, default-constructible Serializable objects);
    * - a unique pointer to a basic type;
    * - a vector of objects where each object is either a basic type or a unique
    *   pointer to a basic type.
    *
    * Basic types and unique pointers to basic types are easy to deserialize with
    * two of the three templated read() methods. The first of the two methods covers
    * non-pointer basic types, i.e. bare basic types, while the other covers unique
    * pointers to basic types. The third templated read() method has a different
    * purpose: it is meant as a shortcut for deserializing vectors of
    * default-constructible Serializable objects, which can also be deserialized
    * manually using the createReadersFor() method, as explained below.
    *
    * Serializable objects can be deserialized in two ways: if a Serializable object
    * is default-constructible, then it qualifies as a basic type, so it can be
    * deserialized with the aforementioned templated read() methods. However, if it
    * is not default-constructible, then the object must be created beforehand and
    * the Reader can then be simply passed on to its Serializable::deserialize()
    * method.
    *
    * Vectors of Serializable objects can be deserialized in two ways as well: if
    * the Serializable type is default-constructible, then the vector can be easily
    * deserialized with the aforementioned, dedicated read() method. If the
    * Serializable type is not default-constructible, then the vector can be
    * deserialized by creating a vector of readers where each Reader can read its
    * own object. This can be achieved with the createReadersFor() method.
    *
    * If one needs more control over deserialization, the createReaderFor() method
    * can help. This method creates a Reader that focuses on a specific key inside
    * the data of the current Reader. As such, it can be leveraged to manually and
    * recursively extract serialized data down the tree.
    */
    class Reader
    {
    public:

        /**
        * Creates a Serialized object from the given string representation and a
        * Reader for it.
        * @param[in] source The string representation of the Serialized object to
        *   read from. The string should be generated by the Writer::toString()
        *   method of a Writer.
        */
        Reader(const std::string& source);

        /**
        * Creates a Reader for the data associated with the given key.
        *
        * This method can be leveraged to manually extract serialized data down the
        * tree in a recursive fashion.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object.
        */
        Reader createReaderFor(const std::string& key) const;

        /**
        * Creates a Reader for each element in the vector of objects associated with
        * the given key. Each Reader can then be used individually to read each
        * object in the vector.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must be associated with a vector of objects, i.e. a Writer must
        *   have written a vector of objects associated with this key.
        */
        std::vector<Reader> createReadersFor(const std::string& key) const;

        /**
        * Returns the value associated with the given key.
        *
        * This method is invoked when the template type is a bare basic type and not
        * a unique pointer to a basic type nor a vector of Serializable objects. See
        * its counterparts with the same name for unique pointers to basic types and
        * vectors of Serializable objects.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        */
        template<class ValueType>
        typename std::enable_if<!TypeTraits::isUniquePtr<ValueType>::value && !TypeTraits::isVectorOfDerived<ValueType, Serializable>::value, ValueType>::type read(const std::string& key) const;

        /**
        * Returns a unique pointer to the value associated with the given key.
        *
        * This method is invoked when the template type is a pointer to a basic
        * type. See its counterparts with the same name for bare basic types and
        * vectors of Serializable objects.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        */
        template<class UniquePtrType>
        typename std::enable_if<TypeTraits::isUniquePtr<UniquePtrType>::value, UniquePtrType>::type read(const std::string& key) const;

        /**
        * Reads the serialized data associated with the given key and deserializes
        * it as a vector of Serializable objects.
        *
        * This method is invoked if, and only if, the template type is a vector of
        * Serializable objects. See its counterparts with the same name for basic
        * types and pointers to basic types.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        */
        template<class SerializableVectorType>
        typename std::enable_if<TypeTraits::isVectorOfDerived<SerializableVectorType, Serializable>::value, SerializableVectorType>::type read(const std::string& key) const;

    protected:

        /**
        * Creates a Reader for the given Serialized object.
        *
        * Note that the Reader takes ownership of the Serialized object, i.e. the
        * pointer given in argument will be moved to the Reader's internal storage,
        * so it should not be accessed anymore after the Reader is created.
        * @param[in] serialized A pointer to the Serialized object to read from. The
        *   pointer will be moved inside the Reader, so it should not be accessed
        *   anymore after this constructor is called.
        */
        Reader(std::unique_ptr<Serialized> serialized);

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given boolean.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] value The boolean to write into.
        */
        void read(const std::string& key, bool& value) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given unsigned integer.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] value The unsigned integer to write into.
        */
        void read(const std::string& key, size_t& value) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given string.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] value The string to write into.
        */
        void read(const std::string& key, std::string& value) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given vector of strings.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] values The vector of strings to write into. If the vector
        *   already contains some strings, they will be erased and replaced with the
        *   new strings read from deserialization.
        */
        void read(const std::string& key, std::vector<std::string>& values) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given Bucket of strings.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] bucket The Bucket of strings to write into. If the bucket
        *   already contains some strings, they will be erased and replaced with the
        *   new strings read from deserialization. The bucket's selection size will
        *   also be overriden with the new value obtained from deserialization.
        */
        void read(const std::string& key, Bucket<std::string>& bucket) const;

        /**
        * Reads the serialized data associated with the given key from the internal
        * Serialized object and deserializes it into the given Serializable object.
        * The Reader deserializes the data into the object by calling its
        * Serializable::deserialize() method and passing itself as the reader
        * argument.
        * @param[in] key The key to use for retrieving the serialized data in the
        *   internal Serialized object. The key must exist in the Serialized object
        *   and it must point to data of the appropriate type for the
        *   deserialization to succeed.
        * @param[out] serializable The Serializable object to write into.
        */
        void read(const std::string& key, Serializable& serializable) const;

    private:

        /**
        * The internal Serialized object. Since it is not modified by Reader
        * objects, there is no need for exclusive ownership, so it is stored as a
        * shared pointer which Reader objects can reuse safely.
        */
        std::shared_ptr<const Serialized> m_serialized;
    };

    template<class ValueType>
    inline typename std::enable_if<!TypeTraits::isUniquePtr<ValueType>::value && !TypeTraits::isVectorOfDerived<ValueType, Serializable>::value, ValueType>::type Reader::read(const std::string& key) const
    {
        /* We initialize the return value to a default value */
        ValueType value;

        /* We deserialize data into it */
        read(key, value);

        /* And we return the result */
        return value;
    }

    template<class UniquePtrType>
    inline typename std::enable_if<TypeTraits::isUniquePtr<UniquePtrType>::value, UniquePtrType>::type Reader::read(const std::string& key) const
    {
        /* We initialize the return value to a unique pointer to a default value */
        std::unique_ptr<std::pointer_traits<UniquePtrType>::element_type> value = std::make_unique<std::pointer_traits<UniquePtrType>::element_type>();

        /* We deserialize data into it */
        read(key, *value);

        /* And we return the result */
        return value;
    }

    template<class SerializableVectorType>
    inline typename std::enable_if<TypeTraits::isVectorOfDerived<SerializableVectorType, Serializable>::value, SerializableVectorType>::type Reader::read(const std::string& key) const
    {
        /* We initialize a result vector of the appropriate type */
        std::vector<typename SerializableVectorType::value_type> serializables;

        /* Then we create a subreader for each vector element... */
        std::vector<Reader> subreaders = createReadersFor(key);

        /*
        * ... And we use these subreaders to deserialize each element and populate
        * the result vector.
        */
        for (const auto& subreader : subreaders)
        {
            typename SerializableVectorType::value_type serializable;
            serializable.deserialize(subreader);
            serializables.push_back(std::move(serializable));
        }

        /* Finally, we return the result vector */
        return serializables;
    }

    /**
    * \class Serializable Serializable.h
    * An object that can be serialized by a Writer and deserialized by a Reader.
    */
    class Serializable
    {
    public:

        /**
        * Destroys the Serializable object. The destructor is made virtual so
        * Serializable objects can be safely deleted from unique pointers to their
        * base class.
        */
        virtual ~Serializable() = default;

        /**
        * Serializes the object into a Serialized object using the given Writer.
        * @param[out] writer The writer to use to serialize the object.
        */
        virtual void serialize(Writer& writer) const = 0;

        /**
        * Deserializes the object from a Serialized object using the given Reader.
        * @param[in] reader The reader to use to deserialize the object.
        */
        virtual void deserialize(const Reader& reader) = 0;
    };

    /**
    * \class Instantiator Instantiator.h
    * A utility class for instantiating Serializable objects from their type name.
    *
    * The Instantiator class supports all OpenTesting Factory::Unit types, including
    * WrapperUnit for which a dedicated function must be used.
    *
    * Behind the scenes, the Instantiator class uses a combination of macros to test
    * for all valid type names and relies on compiler optimization for speed.
    */
    class Instantiator
    {
    public:

        /**
        * The Instantiator class has no constructor since all its methods are static
        * and meant to be used without an Instantiator object.
        */
        Instantiator() = delete;

        /**
        * Creates a new, empty instance of the given unit type. The unit type must
        * be one of the supported classes; otherwise, an invalid argument exception
        * is thrown.
        *
        * Supported unit types for this method are all Factory::Unit classes except
        * the WrapperUnit class. To instantiate a WrapperUnit, use the
        * instantiateWrapperUnit() method instead.
        * @param[in] unitType The name of the unit type to instantiate. It must
        *   correspond to a supported class; otherwise, an invalid exception will be
        *   thrown.
        */
        static std::unique_ptr<Serializable> instantiateUnit(const std::string& unitType);

        /**
        * Creates a new, empty WrapperUnit instance capable of wrapping a
        * Factory::Unit of the given type into a Factory with the given object type.
        * The unit type must be one of the supported classes; otherwise, an invalid
        * argument exception is thrown.
        *
        * Supported unit types for the internal unit are all Factory::Unit classes
        * except the WrapperUnit class itself. Supported object types are all the
        * object types of each of these units.
        * @param[in] internalUnitType The name of the internal unit type. It must
        *   correspond to a supported class; otherwise, an invalid exception will be
        *   thrown.
        * @param[in] derivedObjectTypeInfo A type_info object identifying the
        *   WrapperUnit's derived object type. It must correspond to a supported
        *   object type which must derive from the internal unit's object type;
        *   otherwise, an invalid exception will be thrown.
        */
        static std::unique_ptr<Serializable> instantiateWrapperUnit(const std::string& internalUnitType, const std::type_info& derivedObjectTypeInfo);

    private:

        /**
        * \class WrapperUnitExceptionThrower Instantiator.cpp
        * A utility object that throws an invalid argument exception upon creation.
        *
        * The sole purpose of this class is to interact with the macro logic used
        * behind the scenes of the Instantiator class. More precisely, it serves as
        * a possible return type in the Instantiator::instantiateWrapperUnit()
        * method when incompatible object types are requested for building a
        * WrapperUnit (hence the name of the class). If incompatible types are
        * requested, then the method will attempt to instantiate this class, which
        * will result in an exception being thrown.
        */
        class WrapperUnitExceptionThrower :
            public Serializable
        {
        public:

            /** Throws an invalid argument exception. */
            WrapperUnitExceptionThrower();

            /**
            * This method has no effect and returns immediately. It is only defined
            * here because it is required by Serializable.
            * @param[out] writer A Writer object. It will be left untouched.
            */
            void serialize(Writer& writer) const override {}

            /**
            * This method has no effect and returns immediately. It is only defined
            * here because it is required by Serializable.
            * @param[in] reader A Reader object.
            */
            void deserialize(const Reader& reader) override {}
        };
    };

    /* Hashing */

    /**
    * \class Hash Hash.h
    * A utility class for hashing objects.
    *
    * The Hash class supports the following hash functions:
    * - **DJBX33A**, which stands for "Daniel J. Bernstein, Times 33 with Addition",
    *   is a non-cryptographic hash function that prioritizes speed over quality. It
    *   is very fast to compute and produces hashes over a reasonable distribution,
    *   but it is not as secure as a cryptographic hash function.
    */
    class Hash
    {
    public:

        /**
        * The Hash class has no constructor since all its methods are static and
        * meant to be used without a Hash object.
        */
        Hash() = delete;

        /**
        * Hashes the given string with the DJBX33A hash function.
        *
        * Note that the DJBX33A hash function is meant to be used when speed is the
        * highest priority and the quality of the generated hashes is a lesser
        * concern. For other options, see the top-level documentation of the Hash
        * class.
        * @param[in] stringToHash The string to hash.
        */
        size_t DJBX33A(const std::string& stringToHash);

        /**
        * Hashes the given Serializable object with the DJBX33A hash function.
        *
        * This method first serializes the given object and then call the DJBX33A
        * hash function on the resulting string.
        *
        * Note that the DJBX33A hash function is meant to be used when speed is the
        * highest priority and the quality of the generated hashes is a lesser
        * concern. For other options, see the top-level documentation of the Hash
        * class.
        * @param[in] serializable The Serializable object to hash.
        */
        size_t DJBX33A(const Serializable& serializable);
    };



    /*
    =================================================
    Engine
    =================================================
    */

    /**
    * \class Generator Generator.h
    * An object that can generate another object based on a key provided as a
    * string.
    */
    template<class GeneratedType, typename KeyContainerType = std::vector<std::string>>
    class Generator
    {
    public:

        /** A handy accessor to the Generator's generated object type */
        typedef GeneratedType GeneratedType;

        /** A handy accessor to the Generator's key container type */
        typedef KeyContainerType KeyContainerType;

        /**
        * Returns the set of keys supported by the generator.
        */
        virtual KeyContainerType getKeys() const = 0;

        /**
        * Returns the number of keys supported by this generator.
        *
        * By default, this method generates all possible keys and counts them. If
        * there exists a faster way to compute this result, the method can be
        * overriden in derived classes to use a faster implementation (it is
        * virtual for that purpose).
        */
        virtual size_t getNumKeys() const;

        /**
        * Returns true if the key given in argument is a valid key for this
        * generator and false otherwise.
        *
        * By default, this method generates all possible keys and checks if the
        * given key appears in the list. If there exists a faster way to compute
        * this result, the method can be overriden in derived classes to use a
        * faster implementation (it is virtual for that purpose).
        * @param[in] key The key to check the validity of.
        */
        virtual bool isValidKey(const std::string& key) const;

        /**
        * Generates an object based on the given key. This method must be
        * implemented in derived classes, with the constraint that the same key must
        * generate the same object.
        * @param[in] key The key to use to generate the object. The key must be
        *   valid (see the getKeys() method for a list of valid keys).
        */
        virtual GeneratedType generate(const std::string& key) const = 0;

        /**
        * Retrieves all possible keys for this generator and uses the one at the
        * given index to generate a new object.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as
        *   returned by the getKeys() method.
        */
        virtual GeneratedType generateFromIndex(int keyIndex) const;
    };

    template<class GeneratedType, typename KeyContainerType>
    inline size_t Generator<GeneratedType, KeyContainerType>::getNumKeys() const
    {
        return getKeys().size();
    }

    template<class GeneratedType, typename KeyContainerType>
    inline bool Generator<GeneratedType, KeyContainerType>::isValidKey(const std::string& key) const
    {
        KeyContainerType validKeys = getKeys();
        return std::find(validKeys.cbegin(), validKeys.cend(), key) != validKeys.cend();
    }

    template<class GeneratedType, typename KeyContainerType>
    inline GeneratedType Generator<GeneratedType, KeyContainerType>::generateFromIndex(int keyIndex) const
    {
        KeyContainerType validKeys = getKeys();
        return generate(*std::next(validKeys.cbegin(), keyIndex));
    }

    /**
    * \class Bucket Bucket.h
    * A Bucket is a container-based Generator that contains a copy of all the
    * objects it can possibly generate and returns a selection of objects based on
    * a set of indices passed as a string key. Unless unable to do so, a Bucket
    * always generates the same number of objects, which is called its "selection
    * size". The selection size of a Bucket defaults to 1, but it can be changed at
    * runtime to generate different numbers of objects depending on the context. The
    * selection size must always be at least 1.
    *
    * Note that the selection is made without replacement, so the same object cannot
    * be selected twice, except if it is present in multiple copies inside the
    * bucket.
    *
    * If a Bucket is empty or it contains fewer objects than its selection size, the
    * only key it supports is the null key, which is a string defined by the macro
    * OPENTESTING_NULL_KEY (which currently evaluates to "N"). In this case, the
    * Bucket will always return an empty vector. Otherwise, if a Bucket is not empty
    * and contains enough objects for a selection to be made, then the keys it
    * supports are all the strings respecting the following format:
    * - The key must consist of numbers delimited by the
    *   OPENTESTING_DELIMITER_BUCKET_KEY ('.') character;
    * - Each number must represent a valid index between 0 and getSize() - 1
    *   included, i.e. "0", "1", "2", etc.;
    * - Each number must be unique;
    * - The numbers must be sorted in increasing order;
    * - There must be as many numbers as the selection size.
    *
    * In this case, the Bucket will simply return copies of the objects located at
    * the given indices. This implies that the size of the returned vector is always
    * guaranteed to be equal to the selection size in this situation.
    *
    * For example, if a bucket contains 3 objects and has a selection size of 2,
    * then it supports exactly the following keys:
    * - "0.1" (selects the first and second objects)
    * - "0.2" (selects the first and third objects),
    * - and "1.2" (selects the second and third objects).
    *
    * Notice that the bucket does not support the key "2.1" because its indices are
    * not in increasing order. This selection (second and third objects) is already
    * accounted for by the key "1.2".
    */
    template<class ObjectType>
    class Bucket :
        public Generator<std::vector<ObjectType>>
    {
    public:

        /** Creates an empty bucket with a selection size of 1 by default. */
        Bucket();

        /** Creates an empty bucket with the given selection size. */
        Bucket(size_t selectionSize);

        /**
        * Returns the set of keys supported by the bucket.
        *
        * If a Bucket is empty or it contains fewer objects than its selection size,
        * the only key it supports is the null key, which is a string defined by the
        * macro OPENTESTING_NULL_KEY (which currently evaluates to "N"). Otherwise,
        * the keys it supports are all the strings respecting the following format:
        * - The key must consist of numbers delimited by the
        *   OPENTESTING_DELIMITER_BUCKET_KEY ('.') character;
        * - Each number must represent a valid index between 0 and getSize() - 1
        *   included, i.e. "0", "1", "2", etc.;
        * - Each number must be unique;
        * - The numbers must be sorted in increasing order;
        * - There must be as many numbers as the selection size.
        *
        * For example, if a Bucket contains 3 objects and has a selection size of 2,
        * then it supports exactly the following keys:
        * - "0.1" (selects the first and second objects)
        * - "0.2" (selects the first and third objects),
        * - and "1.2" (selects the second and third objects).
        *
        * Notice that the bucket does not support the key "2.1" because its indices are
        * not in increasing order. This selection (second and third objects) is already
        * accounted for by the key "1.2".
        */
        typename Bucket<ObjectType>::KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the bucket. */
        size_t getNumKeys() const override;

        /**
        * Selects objects from the bucket based on the given key and returns a copy
        * of each. The selection is made without replacement, so the same object
        * cannot be selected twice, except if it is present in multiple copies
        * inside the bucket.
        *
        * The key must respect the format defined in the documentation of the
        * getKeys() method. If it does not, it is likely that an exception will be
        * thrown by this method.
        * @param[in] key The key to use to select the objects. If the bucket is
        *   empty or contains fewer objects than its selection size, the key must be
        *   equal to the null key OPENTESTING_NULL_KEY, in which case the bucket
        *   will return an empty vector. Otherwise, it must be a string respecting
        *   the format constraints defined in the documentation of the getKeys()
        *   method, in which case the bucket will return a vector containing copies
        *   of the objects located at the corresponding indices.
        */
        std::vector<ObjectType> generate(const std::string& key) const override;

        /**
        * Returns the selection size of the bucket, i.e. the number of objects to
        * select from the bucket on each generation.
        */
        size_t getSelectionSize() const;

        /** Returns all the objects contained in the bucket. */
        const std::vector<ObjectType>& getObjects() const;

        /** Returns the number of objects in the bucket. */
        size_t getSize() const;

        /** Returns true if the bucket is empty and false otherwise. */
        bool isEmpty() const;

        /**
        * Defines the selection size of the bucket, i.e. the number of objects to
        * select from the bucket on each generation.
        *
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of objects contained in the bucket. Otherwise, the bucket will
        * only generate empty vectors.
        * @param[in] selectionSize The number of objects to select on each
        *   generation. It must be at least 1.
        */
        void setSelectionSize(size_t selectionSize);

        /**
        * Adds an object to the bucket and places it at the end, so the object will
        * be associated with the highest index.
        * @param[in] object The object to add.
        */
        void append(const ObjectType& object);

        /**
        * Removes an object from the bucket. If the object given in argument is not
        * currently in the bucket, an invalid argument exception is thrown.
        * @param[in] object The object to remove.
        */
        void remove(const ObjectType& object);

        /** Removes and destroys all objects from the bucket. */
        void clear();

    protected:

        /** Regenerates the keys based on the objects contained in the bucket. */
        void updateKeys();

    private:

        /** The number of objects to select from the bucket on each generation. */
        size_t m_selectionSize;

        /** The objects contained in the bucket. */
        std::vector<ObjectType> m_objects;

        /** The keys supported by the bucket in its current state. */
        typename Bucket<ObjectType>::KeyContainerType m_keys;
    };

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket() :

        /* By default, we only select one object */
        Bucket(1)
    {}

    template<class ObjectType>
    inline Bucket<ObjectType>::Bucket(size_t selectionSize)
    {
        /*
        * We set the selection size. Note that this call will also initialize the
        * keys. Concretely, it will simply register the null key as the only valid
        * key since the bucket is empty for now.
        */
        setSelectionSize(selectionSize);
    }

    template<class ObjectType>
    inline typename Bucket<ObjectType>::KeyContainerType Bucket<ObjectType>::getKeys() const
    {
        return m_keys;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getNumKeys() const
    {
        return m_keys.size();
    }

    template<class ObjectType>
    inline std::vector<ObjectType> Bucket<ObjectType>::generate(const std::string& key) const
    {
        /* If we receive the null key, we generate an empty vector. */
        if (key == OPENTESTING_NULL_KEY)
            return {};

        /* Otherwise, we start parsing the key by splitting it into indices */
        std::vector<std::string> indices = String::split(key, OPENTESTING_DELIMITER_BUCKET_KEY);

        /*
        * We enforce the constraint that the number of indices should match the
        * selection size.
        */
        if (indices.size() != m_selectionSize)
            throw std::invalid_argument("Invalid bucket key: found " + std::to_string(indices.size()) + " indices for a selection size of " + std::to_string(m_selectionSize));

        /* We initialize a result vector */
        std::vector<ObjectType> result;

        /* We copy each object from the given indices */
        for (const auto& index : indices)
            result.push_back(m_objects[std::stoi(index)]);

        /* We return the result vector */
        return result;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSelectionSize() const
    {
        return m_selectionSize;
    }

    template<class ObjectType>
    inline const std::vector<ObjectType>& Bucket<ObjectType>::getObjects() const
    {
        return m_objects;
    }

    template<class ObjectType>
    inline size_t Bucket<ObjectType>::getSize() const
    {
        return m_objects.size();
    }

    template<class ObjectType>
    inline bool Bucket<ObjectType>::isEmpty() const
    {
        return m_objects.empty();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::setSelectionSize(size_t selectionSize)
    {
        /* We make sure the selection size is at least 1 */
        if (selectionSize == 0)
            throw std::invalid_argument("The selection size of a bucket must be at least 1 and cannot be set to 0.");

        /* If so, we set the new selection size and update the keys */
        m_selectionSize = selectionSize;
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::append(const ObjectType& object)
    {
        m_objects.push_back(object);
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::remove(const ObjectType& object)
    {
        /* We search for the object */
        auto it = std::find(m_objects.cbegin(), m_objects.cend(), object);

        /* If we cannot find it, we throw an exception */
        if (it == m_objects.cend())
            throw std::invalid_argument("Object could not be found in the bucket and cannot be removed.");

        /* Otherwise, we remove it from the vector */
        m_objects.erase(it);

        /* And we update the keys */
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::clear()
    {
        m_objects.clear();
        updateKeys();
    }

    template<class ObjectType>
    inline void Bucket<ObjectType>::updateKeys()
    {
        /*
        * If the bucket does not contain enough objects for a selection to be made
        * (which includes the case of an empty bucket since the selection size is
        * always at least 1), then the only key it supports is the null key.
        */
        if (m_selectionSize > m_objects.size())
            m_keys = { OPENTESTING_NULL_KEY };

        /*
        * Otherwise, the keys it supports are all the strings representing a valid
        * selection of objects from the bucket.
        */
        else
        {
            /* We list all valid indices for the bucket */
            std::vector<std::string> indicesAsString;
            for (int i = 0; i < m_objects.size(); i++)
                indicesAsString.push_back(std::to_string(i));

            /* Then we enumerate all choices among these indices */
            auto choices = Enumerator::choices<std::vector<std::string>>(indicesAsString, m_selectionSize);

            /*
            * And finally we concatenate each choice with a delimiter to obtain the
            * final keys
            */
            m_keys.clear();
            for (const auto& choice : choices)
                m_keys.insert(m_keys.end(), String::join(choice, OPENTESTING_DELIMITER_BUCKET_KEY));
        }
    }

    /**
    * \class Pipeline Pipeline.h
    * A generation Pipeline that builds an object by processing it one step at a
    * time.
    *
    * A Pipeline consists of a sequence of processors that each completes or
    * modifies an object. For example, if the object is a type of Question, then a
    * Processor could replace tokens in its prompt by some text, or add some options
    * if it is a MultipleChoiceQuestion. Once an object traverses a Pipeline, it
    * ends up in its final state and is ready to be used.
    */
    template<class ObjectType>
    class Pipeline
    {
    public:

        /** A handy accessor to the Pipeline's object type */
        typedef ObjectType ObjectType;

        /**
        * \struct Processor Pipeline.h
        * A processing unit that is part of a generation Pipeline and that aims at
        * completing or modifying an existing object.
        */
        struct Processor
        {
            /** A handy accessor to the Processor's object type */
            typedef ObjectType ObjectType;

            /**
            * Processes the object given in argument. This method must be
            * implemented in all classes derived from Processor.
            * @param[out] object The object to process. This object is meant to be
            *   modified by this method.
            */
            virtual void process(ObjectType& object) const = 0;
        };

        /**
        * Adds a Processor at the end of the Pipeline.
        *
        * Note that the pointer given in argument will be moved to the Pipeline's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] processor A pointer to the Processor to add. The pointer will
        *   be moved inside the Pipeline by this method, so it should not be
        *   accessed anymore after this method is called.
        */
        void append(std::unique_ptr<Processor> processor);

        /**
        * Passes the object given in argument throughout the whole pipeline, calling
        * one Processor at a time in the order in which they were inserted with the
        * append() method.
        * @param[in] object The object to process. This object is meant to be
        *   modified by this method.
        */
        void process(ObjectType& object) const;

    private:

        /** The sequence of processors constituting the Pipeline */
        std::vector<std::unique_ptr<Processor>> m_processors;
    };

    template<class ObjectType>
    inline void Pipeline<ObjectType>::append(std::unique_ptr<Processor> processor)
    {
        /* We move the pointer into the Pipeline's internal storage */
        m_processors.push_back(std::move(processor));
    }

    template<class ObjectType>
    inline void Pipeline<ObjectType>::process(ObjectType& object) const
    {
        /* We pass the object throughout the processing pipeline */
        for (const auto& processor : m_processors)
            processor->process(object);
    }

    /**
    * \class InactiveProcessor InactiveProcessor.h
    * A Pipeline::Processor that is inactive and does not perform any operation.
    *
    * An InactiveProcessor usually serves as a placeholder in a Pipeline, for
    * example if a Factory::Unit is bypassed during generation.
    */
    template<class QuestionType>
    class InactiveProcessor :
        public Pipeline<QuestionType>::Processor
    {
    public:

        /**
        * Does not perform any operation and leaves the question object passed in
        * argument intact. This method just returns immediately.
        * @param[in] question A reference to a question object. The object will be
        *   left intact.
        */
        void process(QuestionType& question) const override {}
    };

    /**
    * \class Factory Factory.h
    * A generator of Pipeline objects for processing other objects.
    *
    * Derived classes must implement the Pipeline generation mechanism. The easiest
    * way to do so is to use a fundamental tool that is built in the Factory class:
    * the Unit subclass. Note that one can always implement a custom mechanism if
    * preferred, and ignore the Unit-related attributes and methods in this class.
    *
    * A Unit is an elementary block of a Factory that can generate a
    * Pipeline::Processor object, i.e. the elementary block of a Pipeline. In that
    * sense, Unit-based factories and pipelines work hand in hand, the elements of
    * one generating the elements of the other. One can therefore derive from the
    * Unit class and just implement the generation of each single Processor, with
    * the Factory class taking care of chaining all the processors together into a
    * Pipeline.
    *
    * Units work with their individual keys, which are called "unit keys". Derived
    * classes can implement a way to split a factory key into multiple unit keys to
    * generate a Pipeline and its elements, or simply pass the same factory key to
    * all units and implement their parsing as best fits. The former version is more
    * common in OpenTesting. For example, a simple delimiting character mechanism is
    * used in the KeyDelimitedFactory derived class to split an initial key into
    * multiple unit keys.
    */
    template<class ObjectType>
    class Factory :
        public Generator<Pipeline<ObjectType>>,
        public Serializable
    {
    public:

        /** A handy accessor to the Factory's object type */
        typedef ObjectType ObjectType;

        /** A shorthand for Pipeline::Processor */
        typedef typename Pipeline<ObjectType>::Processor Processor;

        /**
        * \class Unit Factory.h
        * A Pipeline::Processor Generator.
        */
        class Unit :
            public Generator<std::unique_ptr<Processor>>,
            public Serializable
        {
        public:

            /** A handy accessor to the Unit's object type */
            typedef ObjectType ObjectType;
        };

        /**
        * Returns the internal units of the Factory.
        */
        const std::vector<std::unique_ptr<Unit>>& getUnits() const;

        /**
        * Returns the sets of keys that is supported by each Unit. The returned
        * object is a vector where one element correspond to the set of keys
        * supported by the Unit at the same position in the Factory.
        */
        std::vector<typename Factory<ObjectType>::KeyContainerType> getKeysPerUnit() const;

        /**
        * Returns all the possible combinations of individual unit keys that can be
        * sent the Factory's units to generate a Pipeline. These combinations are
        * computed using a simple Cartesian product. For example, if the Factory
        * contains two units with one supporting the keys "K1" and "K2" and one
        * supporting "KA" and "KB", then this method will return the 4 combinations
        * ("K1", "KA"), ("K1", "KB"), ("K2", "KA"), and ("K2", "KB").
        *
        * This method can be used to compute the set of all possible keys that can
        * be sent to the Factory itself. If the Factory just splits its own key into
        * unit keys based on a delimiter for example, which is a typical mechanism
        * implemented in the KeyDelimitedFactory class, then joining each set of
        * unit keys as returned by this method would lead to the set of all valid
        * keys supported by the Factory. If '-' was used as a delimiter in the
        * example above for instance, then the Factory's valid keys would be
        * "K1-KA", "K1-KB", "K2-K1", and "K2-KB".
        */
        std::vector<std::vector<std::string>> getAllUnitKeysCombinations() const;

        /**
        * Adds a Unit at the end of the Factory.
        *
        * Note that the pointer given in argument will be moved to the Factory's
        * internal storage, so it should not be accessed anymore after this method
        * is called.
        * @param[in] unit A pointer to the Unit to add. The pointer will be moved
        *   inside the Factory by this method, so it should not be accessed anymore
        *   after this method is called.
        */
        void append(std::unique_ptr<Unit> unit);

        /**
        * Removes and destroys all units from the Factory.
        */
        void clear();

        /**
        * Dispatches each key to its corresponding Unit so they all generate one
        * Pipeline::Processor each, and chains all resulting processors into a
        * Pipeline. Note that each key is sent to the Unit at the same position in
        * the Factory as the key in the vector argument, i.e. the first key in the
        * vector passed in argument will be sent to the first Unit, and so on.
        * @param[in] unitKeys The individual keys to send to each Unit. The size of
        *   this vector must match exactly the number of units in the Factory, and
        *   each key must be valid for its target Unit.
        */
        Pipeline<ObjectType> generateFromUnits(const std::vector<std::string>& unitKeys) const;

        /**
        * Serializes the factory with the given Writer.
        * @param[out] writer The writer to use to serialize the factory.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the factory with the given Reader.
        *
        * The Reader must contain the serialized data of a "valid" factory, i.e. a
        * factory (1) whose units are all direct instances of an OpenTesting
        * Factory::Unit type and (2) which does not contain any empty WrapperUnit.
        * If either of this constraint is violated, an invalid argument or runtime
        * error exception will be thrown.
        * @param[in] reader The reader to use to deserialize the factory. The
        *   serialized data it contains must correspond to a valid factory, as
        *   defined in the documentation of this method.
        */
        void deserialize(const Reader& reader) override;

    private:

        /** The Factory's units */
        std::vector<std::unique_ptr<Unit>> m_units;
    };

    template<class ObjectType>
    inline const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& Factory<ObjectType>::getUnits() const
    {
        return m_units;
    }

    template<class ObjectType>
    inline std::vector<typename Factory<ObjectType>::KeyContainerType> Factory<ObjectType>::getKeysPerUnit() const
    {
        /* We list and add all the keys for each unit */
        std::vector<typename Factory<ObjectType>::KeyContainerType> unitKeys;
        for (const auto& unit : m_units)
            unitKeys.push_back(unit->getKeys());
        return unitKeys;
    }

    template<class ObjectType>
    inline std::vector<std::vector<std::string>> Factory<ObjectType>::getAllUnitKeysCombinations() const
    {
        /* We compute the Cartesian product across all possible unit keys. */
        return Enumerator::cartesianProduct<typename Factory<ObjectType>::KeyContainerType, std::vector<std::string>>(getKeysPerUnit());
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::append(std::unique_ptr<Unit> unit)
    {
        /* We move the pointer into the Factory's internal storage */
        m_units.push_back(std::move(unit));
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::clear()
    {
        m_units.clear();
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> Factory<ObjectType>::generateFromUnits(const std::vector<std::string>& unitKeys) const
    {
        /* We start with an empty pipeline */
        Pipeline<ObjectType> pipeline;

        for (int i = 0; i < unitKeys.size(); i++)
        {
            /* We generate a processor... */
            std::unique_ptr<Processor> processor = m_units[i]->generate(unitKeys[i]);

            /* ... And add it to the pipeline */
            pipeline.append(std::move(processor));
        }

        /* We return the finished pipeline */
        return pipeline;
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::serialize(Writer& writer) const
    {
        /*
        * We write the type of the factory as simply "Factory" without its template
        * arguments, as this information can be retrieved from context.
        */
        writer.write("type", std::string("Factory"));
        writer.write("units", m_units);
    }

    template<class ObjectType>
    inline void Factory<ObjectType>::deserialize(const Reader& reader)
    {
        /* We initialize a vector for storing deserialized units */
        std::vector<std::unique_ptr<Unit>> units;

        /* Then we create a reader for each unit to deserialize */
        std::vector<OT::Reader> unitReaders = reader.createReadersFor("units");

        /* And we loop through each unit and deserialize it */
        for (const auto& unitReader : unitReaders)
        {
            /* We retrieve the unit type */
            std::string unitType = unitReader.read<std::string>("type");

            /*
            * We initialize a null pointer for the unit. The pointer will be
            * overriden in the following if statement.
            */
            std::unique_ptr<Serializable> unit = nullptr;

            /*
            * If the unit is a WrapperUnit, we need to collect some information on
            * its internal unit before instantiating it.
            */
            if (unitType == "WrapperUnit")
            {
                /*
                * We first determine whether the WrapperUnit has an internal unit
                * with the "hasInternalUnit" boolean flag. If it does, then we have
                * enough information to instantiate the WrapperUnit, so we proceed
                * and create a new, empty WrapperUnit using the Instantiator utility
                * class.
                */
                if (unitReader.read<bool>("hasInternalUnit"))
                {
                    /* We retrieve the type of the internal unit */
                    Reader internalUnitReader = unitReader.createReaderFor("internalUnit");
                    std::string internalUnitType = internalUnitReader.read<std::string>("type");

                    /* And instantiate an appropriate WrapperUnit for it */
                    unit = Instantiator::instantiateWrapperUnit(internalUnitType, typeid(ObjectType));
                }

                /*
                * Otherwise, we do not have enough information to deserialize the
                * WrapperUnit, so we throw a runtime error exception.
                */
                else
                    throw std::runtime_error("Empty WrapperUnit: could not deserialize the factory since at least one unit is an empty WrapperUnit.");
            }

            /*
            * If the unit is not a WrapperUnit, we just instantiate it from its type
            * using the Instantiator utility class.
            */
            else
                unit = Instantiator::instantiateUnit(unitType);

            /*
            * We test if the unit is compatible with the factory's internal Unit
            * type. It will always be the case when the top reader reads from a
            * valid Serialized object obtained from the serialization of a valid
            * factory. However, if the Serialized object was obtained from another
            * source that can be modified at runtime (e.g. a file), then this
            * guarantee might no longer hold, which justifies the test.
            *
            * To test if the unit is of a compatible type, we simply attempt to
            * convert the underlying object to the factory's internal Unit type with
            * dynamic casting. If we succeed, then we know the unit is compatible,
            * so we add it to the factory. Otherwise, the unit is not compatible and
            * cannot be added to the factory, so we throw a runtime error exception.
            */
            if (auto maybeUnit = dynamic_cast<Unit*>(unit.get()))
            {
                /*
                * If the unit is compatible, we add it to the factory. We have to
                * use raw pointers for this and manually pass the object into its
                * target unique pointer since dynamic casting is not compatible with
                * exclusive ownership.
                *
                * Although this procedure is necessary for maintaining flexibility
                * with types during deseralization, it entails releasing the unique
                * pointer 'maybeUnit' for a brief moment, which introduces a risk of
                * memory leak. To mitigate this risk, we only release the pointer at
                * the very last moment, i.e. right before passing its target to the
                * casted pointer.
                */
                std::unique_ptr<Unit> castedUnit(nullptr);
                unit.release();
                castedUnit.reset(maybeUnit);

                /* Then we deserialize data into the casted unit */
                castedUnit->deserialize(unitReader);

                /* Finally, we add the unit to the result vector */
                units.push_back(std::move(castedUnit));
            }

            /*
            * If the unit is not compatible, we stop here and throw a runtime error
            * exception.
            */
            else
                throw std::runtime_error("Incompatible unit: could not deserialize the factory since at least one unit is not compatible.");
        }

        /*
        * Finally, once all units are deserialized, we replace the factory's
        * internal vector of units with the new one.
        */
        m_units = std::move(units);
    }

    /**
    * \class WrapperUnit WrapperUnit.h
    * A Factory::Unit that wraps another unit of a different type inside so that the
    * latter can be used in factories with the same object type as the WrapperUnit.
    * The object type of the WrapperUnit must be a descendant of that of its
    * internal unit. If it does not, the code will not compile.
    *
    * The WrapperUnit class addresses the following scenario: a unit whose object
    * type is A cannot be natively used in a factory whose object type is B, even if
    * B derives from A. By wrapping the unit into a WrapperUnit whose object type is
    * B, it becomes possible to add it to the factory. In that way, the WrapperUnit
    * class provides downward compatibility (from A down to B) so units can be used
    * across object types, provided the object types are compatible (i.e. one is an
    * ancestor of the other).
    *
    * The WrapperUnit owns its internal unit and defers every function call to it.
    * The WrapperUnit::Processor that the unit generates also owns an internal
    * processor and defers its calls to it. The overhead that the WrapperUnit class
    * adds to its internal unit consists of these two layers of indirection only.
    */
    template<class BaseObjectType, class DerivedObjectType>
    class WrapperUnit :
        public Factory<DerivedObjectType>::Unit
    {
    public:

        /**
        * \class Processor WrapperUnit.h
        * A Pipeline::Processor object that wraps another processor of a different
        * type inside so the latter can be used in factories with the same object
        * type as the WrapperUnit::Processor. The WrapperUnit::Processor simply
        * defers its calls to its internal processor.
        */
        class Processor :
            public Pipeline<DerivedObjectType>::Processor
        {
        public:

            /**
            * Creates a WrapperUnit::Processor that wraps the processor given
            * in argument.
            *
            * The WrapperUnit::Processor will take ownership of the latter, i.e. the
            * pointer to the processor given in argument will be moved to the
            * WrapperUnit::Processor's internal storage, so it should not be
            * accessed anymore after the WrapperUnit::Processor is created.
            * @param[in] processor A pointer to the processor to wrap. The pointer
            *   will be moved inside the WrapperUnit::Processor by this method, so
            *   it should not be accessed anymore after this method is called.
            */
            Processor(std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> processor);

            /**
            * Calls the internal processor on the given object.
            * @param[out] object The object to process. Its class must derive from
            *   the object type of the internal processor.
            */
            void process(DerivedObjectType& object) const;

        private:

            /** The internal processor wrapped in the WrapperUnit::Processor */
            std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> m_internalProcessor;
        };

        /**
        * Creates an empty WrapperUnit with no internal unit.
        *
        * Until provided with an internal unit through its wrap() method, the
        * WrapperUnit will have no effect and always generate an InactiveProcessor.
        */
        WrapperUnit();

        /**
        * Creates a WrapperUnit that wraps the unit given in argument.
        *
        * The WrapperUnit will take ownership of the latter, i.e. the pointer to the
        * unit given in argument will be moved to the WrapperUnit's internal
        * storage, so it should not be accessed anymore after the WrapperUnit is
        * created.
        * @param[in] unit A pointer to the unit to wrap. The pointer will be moved
        *   inside the WrapperUnit by this constructor, so it should not be accessed
        *   anymore after this constructor is called.
        */
        WrapperUnit(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit);

        /**
        * Returns the set of keys supported by the unit.
        *
        * If the WrapperUnit contains an internal unit, then the keys it supports
        * are exactly the same as those of that unit. Otherwise, if the WrapperUnit
        * is empty (e.g. if it was created from its default constructor), then the
        * only key it supports is the null key.
        */
        typename WrapperUnit<BaseObjectType, DerivedObjectType>::KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the unit. */
        size_t getNumKeys() const override;

        /**
        * Returns true if the key given in argument is a valid key for the unit and
        * false otherwise.
        * @param[in] key The key to check the validity of.
        */
        bool isValidKey(const std::string& key) const override;

        /**
        * If it exists, calls the internal unit with the given key to generate a
        * processor, wraps the generated processor into a WrapperUnit::Processor,
        * and returns the latter. In this case, the key is transferred directly to
        * the internal unit, so it must respect the format defined in the
        * documentation of the internal unit's getKeys() method. If it does not,
        * this method is likely to throw an exception.
        *
        * If the WrapperUnit is empty and contains no internal unit (e.g. if it was
        * created from its default constructor), then this method simply returns an
        * InactiveProcessor that does not perform any operation.
        * @param[in] key The key to transfer to the internal unit, if it exists. In
        *   this case, it must respect the format defined in the documentation of
        *   the internal unit's getKeys() method. If the WrapperUnit does not
        *   contain any internal unit (e.g. if it was created from its default
        *   constructor), then it must be equal to the null key
        *   OPENTESTING_NULL_KEY, in which case the unit will generate an
        *   InactiveProcessor that does not perform any operation.
        */
        std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> generate(const std::string& key) const override;

        /**
        * Retrieves all keys supported by the unit as defined by the getKeys()
        * method and uses the one at the given index to generate a new
        * WrapperUnit::Processor.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as returned
        *   by the getKeys() method.
        */
        std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> generateFromIndex(int keyIndex) const override;

        /** Returns a pointer reference to the internal unit. */
        std::unique_ptr<typename Factory<BaseObjectType>::Unit>& getInternalUnit();

        /**
        * Wraps the given unit inside the WrapperUnit. If a unit was already wrapped
        * inside, it will be destroyed and replaced by the new one.
        *
        * The WrapperUnit will take ownership of the latter, i.e. the pointer to the
        * unit given in argument will be moved to the WrapperUnit's internal
        * storage, so it should not be accessed anymore after the WrapperUnit is
        * created.
        * @param[in] unit A pointer to the unit to wrap. The pointer will be moved
        *   inside the WrapperUnit, so it should not be accessed anymore after this
        *   method is called.
        */
        void wrap(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit);

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    private:

        /** The internal unit wrapped in the WrapperUnit */
        std::unique_ptr<typename Factory<BaseObjectType>::Unit> m_internalUnit;
    };

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::Processor::Processor(std::unique_ptr<typename Pipeline<BaseObjectType>::Processor> processor) :

        /*
        * The WrapperUnit::Processor takes ownership of the processor and moves the
        * pointer inside its storage.
        */
        m_internalProcessor(std::move(processor))
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::Processor::process(DerivedObjectType& object) const
    {
        /*
        * We just transfer the call to the internal processor. This is where it is
        * necessary that the WrapperUnit's object type derives from the internal
        * unit's object type: the processor that the latter generates must be able
        * to process the derived object type.
        */
        m_internalProcessor->process(object);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::WrapperUnit() :
        m_internalUnit(nullptr)
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline WrapperUnit<BaseObjectType, DerivedObjectType>::WrapperUnit(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit) :

        /*
        * The WrapperUnit takes ownership of the unit and moves the pointer inside
        * its storage.
        */
        m_internalUnit(std::move(unit))
    {}

    template<class BaseObjectType, class DerivedObjectType>
    inline typename WrapperUnit<BaseObjectType, DerivedObjectType>::KeyContainerType WrapperUnit<BaseObjectType, DerivedObjectType>::getKeys() const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)

            /* ... We simply transfer the call to it. */
            return m_internalUnit->getKeys();

        /* Otherwise, we return the null key */
        return { OPENTESTING_NULL_KEY };
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline size_t WrapperUnit<BaseObjectType, DerivedObjectType>::getNumKeys() const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)

            /* ... We simply transfer the call to it. */
            return m_internalUnit->getNumKeys();

        /* Otherwise, we return 1 since the unit only supports the null key */
        return 1;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline bool WrapperUnit<BaseObjectType, DerivedObjectType>::isValidKey(const std::string& key) const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)

            /* ... We simply transfer the call to it. */
            return m_internalUnit->isValidKey(key);

        /*
        * Otherwise, we compare the key with the null key, which is the only key
        * supported by the unit in this case.
        */
        return key == OPENTESTING_NULL_KEY;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> WrapperUnit<BaseObjectType, DerivedObjectType>::generate(const std::string& key) const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)
        {
            /* ... We generate a processor with the internal unit and wrap it */
            auto processor = m_internalUnit->generate(key);
            return std::make_unique<Processor>(std::move(processor));
        }

        /*
        * Otherwise, we generate an inactive processor so that questions will be
        * left untouched.
        */
        return std::make_unique<InactiveProcessor<DerivedObjectType>>();
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Pipeline<DerivedObjectType>::Processor> WrapperUnit<BaseObjectType, DerivedObjectType>::generateFromIndex(int keyIndex) const
    {
        /* If the WrapperUnit has an internal unit... */
        if (m_internalUnit)
        {
            /* ... We generate a processor with the internal unit and wrap it */
            auto processor = m_internalUnit->generateFromIndex(keyIndex);
            return std::make_unique<Processor>(std::move(processor));
        }

        /*
        * Otherwise, we generate an inactive processor so that questions will be
        * left untouched.
        */
        return std::make_unique<InactiveProcessor<DerivedObjectType>>();
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline std::unique_ptr<typename Factory<BaseObjectType>::Unit>& WrapperUnit<BaseObjectType, DerivedObjectType>::getInternalUnit()
    {
        return m_internalUnit;
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::wrap(std::unique_ptr<typename Factory<BaseObjectType>::Unit> unit)
    {
        m_internalUnit = std::move(unit);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::serialize(Writer& writer) const
    {
        /*
        * We write the type of the WrapperUnit as simply "WrapperUnit" without its
        * template arguments, as this information can be retrieved from context.
        */
        writer.write("type", std::string("WrapperUnit"));

        /*
        * To be able to serialize and deserialize the WrapperUnit even if it does
        * not have an internal unit, we store an additional boolean flag
        * "hasInternalUnit" indicating whether the internal unit pointer is null. If
        * it is, then we simply do not pursue with its serialization.
        */
        if (m_internalUnit)
        {
            writer.write("hasInternalUnit", true);
            writer.write("internalUnit", *m_internalUnit);
        }
        else
            writer.write("hasInternalUnit", false);
    }

    template<class BaseObjectType, class DerivedObjectType>
    inline void WrapperUnit<BaseObjectType, DerivedObjectType>::deserialize(const Reader& reader)
    {
        /*
        * We first retrieve the information on whether the WrapperUnit has an
        * internal unit with the "hasInternalUnit" boolean flag. If it does, then we
        * deserialize the internal unit.
        */
        if (reader.read<bool>("hasInternalUnit"))
        {
            /* We start by creating a subreader for the internal unit */
            Reader subreader = reader.createReaderFor("internalUnit");

            /*
            * Then we initialize the internal unit to a default object using the
            * Instantiator utility class.
            */
            std::string internalUnitType = subreader.read<std::string>("type");
            std::unique_ptr<Serializable> unit = Instantiator::instantiateUnit(internalUnitType);

            /* Then we deserialize data into it */
            unit->deserialize(subreader);

            /*
            * Finally, we move the unit into the WrapperUnit. We have to use raw
            * pointers for this and manually pass it to the internal pointer since
            * dynamic casting is not compatible with exclusive ownership.
            *
            * Although this procedure is necessary for maintaining flexibility with
            * types during deseralization, it entails releasing the unique pointer
            * 'unit' for a brief moment, which introduces a risk of memory leak. To
            * mitigate this risk, we only release the pointer at the very last
            * moment, i.e. right before passing its target to the internal pointer.
            */
            auto castedUnit = dynamic_cast<typename Factory<BaseObjectType>::Unit*>(unit.get());
            unit.release();
            m_internalUnit.reset(castedUnit);
        }

        /*
        * Otherwise, we return immediately and leave the WrapperUnit in its default
        * state, which corresponds exactly to a WrapperUnit with no internal unit.
        */
    }

    /**
    * \class KeyDelimitedFactory KeyDelimitedFactory.h
    * A Factory that uses a character delimiter to retrieve the keys for its units.
    */
    template<class ObjectType>
    class KeyDelimitedFactory :
        public Factory<ObjectType>
    {
    public:

        /**
        * Returns all the keys supported by the KeyDelimitedFactory. The keys are
        * obtained by computing the Cartesian product of all possible unit keys and
        * then concatenating each result with a character delimiter.
        *
        * Note that, as a result, if any unit in the KeyDelimitedFactory does not
        * support any key, then the whole factory will not either, and this method
        * will return an empty vector.
        */
        typename KeyDelimitedFactory<ObjectType>::KeyContainerType getKeys() const override;

        /**
        * Returns the number of keys supported by the KeyDelimitedFactory. The
        * result is obtained by multiplying together the number of keys supported by
        * each unit inside the factory.
        *
        * Note that, as a result, if any unit in the KeyDelimitedFactory does not
        * support any key, then the whole factory will not either, and this method
        * will return 0.
        */
        size_t getNumKeys() const;

        /**
        * Generates a Pipeline for the proper object type.
        * @param[in] key The factory key to use for generating the pipeline.
        */
        Pipeline<ObjectType> generate(const std::string& key) const override;
    };

    template<class ObjectType>
    inline typename KeyDelimitedFactory<ObjectType>::KeyContainerType KeyDelimitedFactory<ObjectType>::getKeys() const
    {
        /*
        * To generate all the factory keys, we join each unit key combination with a
        * delimiter:
        */
        std::vector<std::vector<std::string>> combinations = Factory<ObjectType>::getAllUnitKeysCombinations();
        typename KeyDelimitedFactory<ObjectType>::KeyContainerType keys;
        for (const auto& combination : combinations)
            keys.insert(keys.end(), OT::String::join(combination, OPENTESTING_DELIMITER_UNIT_KEYS));
        return keys;
    }

    template<class ObjectType>
    inline size_t KeyDelimitedFactory<ObjectType>::getNumKeys() const
    {
        /* We retrieve the factory's units */
        const std::vector<std::unique_ptr<typename Factory<ObjectType>::Unit>>& units = Factory<ObjectType>::getUnits();

        /* If the factory does not contain any unit, we return 0 */
        if (units.empty())
            return 0;

        /* Otherwise, we multiply together the number of keys supported by each factory */
        size_t numKeys = 1;
        for (const auto& unit : units)
            numKeys *= unit->getNumKeys();
        return numKeys;
    }

    template<class ObjectType>
    inline Pipeline<ObjectType> KeyDelimitedFactory<ObjectType>::generate(const std::string& key) const
    {
        /*
        * We split the factory into unit keys and send each one to its corresponding
        * unit:
        */
        std::vector<std::string> unitKeys = OT::String::split(key, OPENTESTING_DELIMITER_UNIT_KEYS);
        return Factory<ObjectType>::generateFromUnits(unitKeys);
    }



    /*
    =================================================
    Questions
    =================================================
    */

    /**
    * \struct Answer Answer.h
    * Represents the answer of an examinee to a Question as a vector of strings.
    *
    * For most questions, the examinee may just provide a single string as an
    * answer, so the vector will be of size 1. If the expected answer is more
    * complex in structure (for example, mapping some elements together or drawing
    * something), the answer can be encoded as a sequence of strings, and so the
    * vector is likely to have a size greater than 1.
    */
    struct Answer
    {

        /** The elements of the answer */
        std::vector<std::string> elements;

        /** Builds an empty Answer */
        Answer();

        /**
        * Builds an Answer containing one single element.
        * @param[in] element The element to put in the Answer.
        */
        Answer(const std::string& element);

        /**
        * Builds an Answer containing multiple elements.
        * @param[in] elements The elements to put in the Answer.
        */
        Answer(const std::vector<std::string>& elements);

        /**
        * Compares two answers together. Two answers are considered equal if they
        * contain the exact same elements and in the same order.
        * @param[in] answer1 The first Answer to compare.
        * @param[in] answer2 The second Answer to compare.
        */
        friend bool operator==(const Answer& answer1, const Answer& answer2);
    };

    /**
    * \struct Question Question.h
    * A Question ready to be asked to the examinee as part of a test or quizz.
    */
    struct Question
    {

        /** The Question's prompt represented as a string */
        std::string prompt;

        /** All answers accepted as correct */
        std::vector<Answer> correctAnswers;

        /** The explanation for why the correct answers are what they are */
        std::string explanation;

        /** Builds an empty Question */
        Question();

        /**
        * Builds a Question with a single correct answer.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] correctAnswer The correct answer to the Question.
        * @param[in] explanation The reason why the correct answer is the one given.
        */
        Question(const std::string& prompt, const Answer& correctAnswer, const std::string& explanation);

        /**
        * Builds a Question with multiple correct answers
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] correctAnswers The correct answers to the Question.
        * @param[in] explanation The reason why the correct answers are the ones
        *   given.
        */
        Question(const std::string& prompt, const std::vector<Answer>& correctAnswers, const std::string& explanation);

        /**
        * Returns true if the answer is given in argument is correct, and false
        * otherwise.
        *
        * By default, this method checks if the given answer appears as is in the
        * list of correct answers for this question. Derived classes can override
        * this method to allow for a more elaborate check (the method is virtual
        * for this purpose).
        * @param[in] answer The Answer to check.
        */
        virtual bool isAnswerCorrect(const Answer& answer) const;
    };

    /**
    * \struct MultipleChoiceQuestion MultipleChoiceQuestion.h
    * A type of Question where multiple options to choose from can be presented to
    * the examinee.
    *
    * Options are encoded as strings and organized into OptionGroup objects. An
    * OptionGroup is a collection of options that belong together and that are meant
    * to be presented together to the examinee. It is useful for cases where the
    * examinee must select multiple options from multiple lists (for example when
    * the examinee must fill in multiple blanks), but one can always manage and
    * display options as they desire. In its simplest form, a MultipleChoiceQuestion
    * can have one single OptionGroup containing all the options necessary for the
    * question.
    */
    struct MultipleChoiceQuestion :
        public Question
    {
        /**
        * \struct OptionGroup MultipleChoiceQuestion.h
        * A container of options.
        */
        struct OptionGroup
        {
            /**
            * An optional title for the OptionGroup that can be displayed to the
            * examinee. For example, if the MultipleChoiceQuestion consists in
            * filling multiple blanks and each blank has its own list of options,
            * the title can map the options back to the blank they correspond to.
            */
            std::string title;

            /**
            * The options contained in the OptionGroup. Options are encoded as
            * strings.
            */
            std::vector<std::string> options;
        };

        /** The option groups to present to the examinee */
        std::vector<OptionGroup> optionGroups;

        /** Builds an empty MultipleChoiceQuestion */
        MultipleChoiceQuestion();

        /**
        * Builds a MultipleChoiceQuestion with a single correct answer and some
        * options to choose from, organized into option groups.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] optionGroups The options for the examinee to choose from,
        *   organized into OptionGroup objects.
        * @param[in] correctAnswer The correct answer to the Question.
        * @param[in] explanation The reason why the correct answer is the one given.
        */
        MultipleChoiceQuestion(const std::string& prompt, const std::vector<OptionGroup>& optionGroups, const Answer& correctAnswer, const std::string& explanation);

        /**
        * Builds a MultipleChoiceQuestion with multiple correct answers and some
        * options to choose from.
        * @param[in] prompt The prompt to show the examinee.
        * @param[in] optionGroups The options for the examinee to choose from,
        *   organized into OptionGroup objects.
        * @param[in] correctAnswers The correct answers to the Question.
        * @param[in] explanation The reason why the correct answers are the ones
        *   given.
        */
        MultipleChoiceQuestion(const std::string& prompt, const std::vector<OptionGroup>& optionGroups, const std::vector<Answer>& correctAnswers, const std::string& explanation);
    };



    /*
    =================================================
    Units for Question Generators
    =================================================
    */

    /**
    * \class PromptInitializationUnit PromptInitializationUnit.h
    * A Factory::Unit that selects a prompt from a list of prompts and initializes a
    * question with it.
    *
    * The unit relies on a single Bucket containing all the possible prompts to
    * choose from. The unit passes its input key to its internal Bucket to choose a
    * prompt and then initializes a question with the selected prompt by the
    * intermediate of a PromptInitializationUnit::Processor.
    */
    class PromptInitializationUnit :
        public Factory<Question>::Unit
    {
    public:

        /**
        * \class Processor PromptInitializationUnit.h
        * A Pipeline::Processor object that initializes the prompt of a question.
        */
        class Processor :
            public Pipeline<Question>::Processor
        {
        public:

            /**
            * Creates a PromptInitializationUnit::Processor that will initialize the
            * prompt of a question with the given prompt.
            * @param[in] prompt The prompt to initialize the question with.
            */
            Processor(const std::string& prompt);

            /**
            * Initializes the question's prompt. Any existing prompt will be
            * overriden.
            * @param[out] question The question to initialize.
            */
            void process(Question& question) const override;

        private:

            /** The prompt to initialize a question with. */
            std::string m_prompt;
        };

        /**
        * Returns the set of keys supported by the unit.
        *
        * If the unit does not contain any prompt to choose from, the only key it
        * supports is the null key OPENTESTING_NULL_KEY ("N"). Otherwise, if the
        * unit contains at least one prompt, then the keys it supports are all the
        * strings representing a valid index between 0 and getSize() - 1 included,
        * i.e. "0", "1", "2", etc.
        */
        KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the unit. */
        size_t getNumKeys() const override;

        /**
        * Picks a prompt and generates a PromptInitializationUnit::Processor that
        * initializes questions with this prompt.
        * @param[in] key The key to use to pick the prompt. If the unit does not
        *   contain any prompt, the key must be equal to the null key
        *   OPENTESTING_NULL_KEY ("N"), in which case the unit will generate an
        *   InactiveProcessor that does not perform any operation. Otherwise, it
        *   must be a string representing a valid index between 0 and getSize() - 1
        *   included, e.g. "0", "1", "2", etc., in which case the unit will return
        *   a PromptInitializationUnit::Processor using the prompt at the given
        *   index in its internal Bucket for initializing questions.
        */
        std::unique_ptr<Pipeline<Question>::Processor> generate(const std::string& key) const override;

        /** Returns the prompts contained in the unit. */
        const std::vector<std::string>& getPrompts() const;

        /** Returns the number of prompts contained in the unit. */
        size_t getSize() const;

        /**
        * Adds a prompt to the unit.
        * @param[in] prompt The prompt to add.
        */
        void addPrompt(const std::string& prompt);

        /**
        * Removes a prompt from the unit. If the prompt given in argument is not
        * currently contained in the unit, an invalid argument exception is thrown.
        * @param[in] prompt The prompt to remove.
        */
        void removePrompt(const std::string& prompt);

        /** Removes all prompts from the unit. */
        void clearPrompts();

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    private:

        /** The bucket containing all possible prompts to choose from. */
        Bucket<std::string> m_bucket;
    };

    /**
    * \class ExplanationCompletionUnit ExplanationCompletionUnit.h
    * A Factory::Unit that completes the explanation field of a question.
    *
    * The unit relies on a single string called the "explanation chunk" which
    * provides some information to the examinee on why a question's correct answers
    * are what they are. The unit appends the explanation chunk at the end of a
    * question's explanation field by the intermediate of an
    * ExplanationCompletionUnit::Processor. The current explanation and the chunk
    * are directly concatenated without any separator.
    *
    * The unit only supports the single key, which is a string defined by the macro
    * OPENTESTING_SINGLE_KEY (which evaluates to "S").
    */
    class ExplanationCompletionUnit :
        public Factory<Question>::Unit
    {
    public:

        /**
        * \class Processor ExplanationCompletionUnit.h
        * A Pipeline::Processor object that completes the explanation field of a
        * question by appending an explanation chunk at the end of it.
        */
        class Processor :
            public Pipeline<Question>::Processor
        {
        public:

            /**
            * Creates an ExplanationCompletionUnit::Processor that will complete the
            * explanation field of a question by appending the explanation chunk
            * given in argument at the end of it.
            * @param[in] explanationChunk The explanation chunk to add to questions.
            */
            Processor(const std::string& explanationChunk);

            /**
            * Appends the explanation chunk at the end of the question's explanation
            * field. The two strings (the current explanation and the chunk) are
            * directly concatenated without any separator.
            * @param[out] question The question to add the explanation chunk to.
            */
            void process(Question& question) const override;

        private:

            /** The explanation chunk to add to a question */
            std::string m_explanationChunk;
        };

        /**
        * Returns a set containing the single key, which is the only key supported
        * by the unit. The single key is defined by the macro OPENTESTING_SINGLE_KEY
        * (which evaluates to "S").
        */
        KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the unit, i.e. 1. */
        size_t getNumKeys() const override;

        /**
        * Generates a ExplanationCompletionUnit::Processor that appends the
        * explanation chunk at the end of the explanation field of a question.
        * @param[in] key The key to use for the generation. It must be equal to the
        *   single key OPENTESTING_SINGLE_KEY ("S").
        */
        std::unique_ptr<Pipeline<Question>::Processor> generate(const std::string& key) const override;

        /** Returns the explanation chunk. */
        const std::string& getExplanationChunk() const;

        /**
        * Sets the explanation chunk.
        * @param[in] explanationChunk The explanation chunk to use.
        */
        void setExplanationChunk(const std::string& explanationChunk);

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    private:

        /** The explanation chunk to use for completing explanation fields */
        std::string m_explanationChunk;
    };

    /**
    * \class TokenReplacementUnit TokenReplacementUnit.h
    * A Factory::Unit that uses a token replacement mechanism to complete the
    * components of a question. The unit can be configured to complete a question's
    * prompt, its explanation field, or both.
    *
    * The unit relies on a set of tokens and a Bucket of replacement strings. The
    * unit uses its input key to choose a replacement string and then replaces any
    * occurrence of any of the tokens with this replacement string by the
    * intermediate of a TokenReplacementUnit::Processor.
    */
    class TokenReplacementUnit :
        public Factory<Question>::Unit
    {
    public:

        /**
        * \class Processor TokenReplacementUnit.h
        * A Pipeline::Processor object that fills the prompt and explanation fields
        * of a question by replacing some tokens with a replacement string.
        */
        class Processor :
            public Pipeline<Question>::Processor
        {
        public:

            /**
            * Creates a TokenReplacementUnit::Processor that will replace any
            * occurrence of the given tokens by the replacement string.
            * @param[in] tokens The tokens to replace.
            * @param[in] replacementString The string to replace the tokens with.
            * @param[in] replaceInPrompt Whether to replace tokens in a question's
            *   prompt.
            * @param[in] replaceInExplanation Whether to replace tokens in a
            *   question's explanation field.
            */
            Processor(const std::vector<std::string>& tokens, const std::string& replacementString, bool replaceInPrompt, bool replaceInExplanation);

            /**
            * Replaces any occurrence of the supported tokens with the replacement
            * string inside the question's prompt and explanation fields.
            * @param[out] question The question to perform the replacement on.
            */
            void process(Question& question) const override;

        private:

            /** The tokens to replace. */
            std::vector<std::string> m_tokens;

            /** The string to replace the tokens with. */
            std::string m_replacementString;

            /** Whether to replace the tokens in a question's prompt */
            bool m_replaceInPrompt;

            /** Whether to replace the tokens in a question's explanation field */
            bool m_replaceInExplanation;
        };

        /**
        * Creates an empty unit with no tokens nor replacement strings and
        * configured to modify both the prompt and explanation fields of a question.
        */
        TokenReplacementUnit();

        /**
        * Returns the set of keys supported by the unit.
        *
        * If the unit does not contain any replacement string or has no registered
        * token, then it is not usable, so the only key it supports is the null key
        * OPENTESTING_NULL_KEY ("N").
        *
        * On the other hand, if the unit contains at least one replacement string
        * and one token to replace, then the keys it supports are all the strings
        * representing a valid index between 0 and getSize() - 1 included, i.e. "0",
        * "1", "2", etc.
        */
        KeyContainerType getKeys() const override;

        /**
        * Returns the number of keys supported by the unit.
        */
        size_t getNumKeys() const override;

        /**
        * Picks a replacement string and generates a TokenReplacementUnit::Processor
        * that replaces all registered tokens with this string.
        * @param[in] key The key to use to pick the replacement string. If the unit
        *   does not contain any replacement string or has no registered token, then
        *   it is not usable, so the key must be equal to the null key
        *   OPENTESTING_NULL_KEY ("N"), in which case the unit will generate an
        *   InactiveProcessor that does not perform any operation. Otherwise, it
        *   must be a string representing a valid index between 0 and getSize() - 1
        *   included, e.g. "0", "1", "2", etc., in which case the unit will return
        *   an appropriate TokenReplacementUnit::Processor that uses this string.
        */
        std::unique_ptr<Pipeline<Question>::Processor> generate(const std::string& key) const override;

        /**
        * Returns all the tokens handled by the unit.
        */
        const std::vector<std::string>& getTokens() const;

        /**
        * Returns the replacement strings contained in the unit.
        */
        const std::vector<std::string>& getReplacementStrings() const;

        /**
        * Returns the number of replacement strings in the unit.
        */
        size_t getSize() const;

        /**
        * Returns true if the unit replaces tokens in prompts and false otherwise.
        */
        bool isReplacementInPromptEnabled() const;

        /**
        * Returns true if the unit replaces tokens in explanation fields and false
        * otherwise.
        */
        bool isReplacementInExplanationEnabled() const;

        /**
        * Adds a token to be used for replacement by the unit.
        * @param[in] token The token to add.
        */
        void addToken(const std::string& token);

        /**
        * Removes a token from the unit so the latter no longer handles it. If the
        * token given in argument is not currently supported by the unit, an invalid
        * argument exception is thrown.
        * @param[in] token The token to remove.
        */
        void removeToken(const std::string& token);

        /**
        * Removes all tokens from the unit.
        */
        void clearTokens();

        /**
        * Adds a replacement string to the unit.
        * @param[in] stringToAdd The string to add.
        */
        void addReplacementString(const std::string& stringToAdd);

        /**
        * Removes a replacement string from the unit. If the string given in
        * argument is not currently a replacement string in the unit, an invalid
        * argument exception is thrown.
        * @param[in] stringToRemove The string to remove.
        */
        void removeReplacementString(const std::string& stringToRemove);

        /**
        * Removes all replacement strings from the unit.
        */
        void clearReplacementStrings();

        /**
        * Enables the replacement of tokens in prompts.
        */
        void enableReplacementInPrompt();

        /**
        * Disables the replacement of tokens in prompts.
        */
        void disableReplacementInPrompt();

        /**
        * Enables the replacement of tokens in explanation fields.
        */
        void enableReplacementInExplanation();

        /**
        * Disables the replacement of tokens in explanation fields.
        */
        void disableReplacementInExplanation();

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    protected:

        /**
        * Makes sure that no token appear in no replacement string, since otherwise
        * the TokenReplacementUnit::Processor could enter an infinite loop while
        * trying to replace the token with this replacement string. If at least one
        * token is found in at least one of the replacement strings, an invalid
        * argument exception is thrown.
        */
        void checkForInfiniteLoop() const;

    private:

        /** The tokens registered for the unit. */
        std::vector<std::string> m_tokens;

        /** The bucket containing all possible replacement strings. */
        Bucket<std::string> m_bucket;

        /** Whether to replace the tokens in a question's prompt */
        bool m_replaceInPrompt;

        /** Whether to replace the tokens in a question's explanation field */
        bool m_replaceInExplanation;
    };

    /**
    * \class OptionSelectionUnit OptionSelectionUnit.h
    * A Factory::Unit that selects the options to present to the examinee when
    * answering a MultipleChoiceQuestion.
    *
    * The unit relies on two internal buckets, one with correct options and one with
    * incorrect options. The unit selects options from these two buckets, groups all
    * of them into a MultipleChoiceQuestion::OptionGroup, adds a title to it, and
    * then shuffles it. The title is user-defined and can be changed at runtime. The
    * unit then adds the MultipleChoiceQuestion::OptionGroup to the
    * MultipleChoiceQuestion and the correct options to the list of correct answers
    * to the MultipleChoiceQuestion by the intermediate of an
    * OptionSelectionUnit::Processor.
    *
    * Unless unable to do so, the unit will always select the same number of correct
    * options, which is called the "correct selection size", and the same number of
    * incorrect options, which is called the "incorrect selection size". Both
    * selection sizes must always be at least 1 and can be changed at runtime. The
    * sum of these two selection sizes is called the "total selection size".
    */
    class OptionSelectionUnit :
        public Factory<MultipleChoiceQuestion>::Unit
    {
    public:

        /**
        * \class Processor OptionSelectionUnit.h
        * A Pipeline::Processor object that adds options to a
        * MultipleChoiceQuestion.
        */
        class Processor :
            public Pipeline<MultipleChoiceQuestion>::Processor
        {
        public:

            /**
            * Creates an OptionSelectionUnit::Processor that will add the given
            * option group and correct answers to the multiple choice questions it
            * is instructed to process.
            * @param[in] optionGroup The option group to add.
            * @param[in] correctOptions The correct options to add as correct
            *   answers. Each correct option should be part of the option group,
            *   although this constraint is not enforced.
            */
            Processor(const MultipleChoiceQuestion::OptionGroup& optionGroup, const std::vector<std::string>& correctOptions);

            /**
            * Adds the MultipleChoiceQuestion::OptionGroup to the
            * MultipleChoiceQuestion and the correct options to the list of correct
            * answers to the MultipleChoiceQuestion. If the question has no correct
            * answers yet, the processor will create a new one and fill it with the
            * correct options. Otherwise, the processor will add the correct options
            * to each existing correct answer.
            * @param[out] question The multiple choice question to add options to.
            */
            void process(MultipleChoiceQuestion& question) const override;

        private:

            /** The group of options to add. */
            MultipleChoiceQuestion::OptionGroup m_optionGroup;

            /** The correct options to add to the list of correct answers. */
            std::vector<std::string> m_correctOptions;
        };

        /**
        * Creates an empty unit with an empty title and with the correct and
        * incorrect selection sizes both set to 1 by default.
        */
        OptionSelectionUnit();

        /**
        * Returns the set of keys supported by the unit.
        *
        * If any of the unit's buckets is empty or does not contain enough options
        * to choose from, then the unit is not usable, so the only key it supports
        * is the null key OPENTESTING_NULL_KEY ("N").
        *
        * On the other hand, if the unit contains enough options in both of its
        * buckets, then the keys it supports are all the strings respecting the
        * format "[correct_key]+[incorrect_key]![permutation_key]" where:
        * - [correct_key] is a valid key for the bucket of correct options;
        * - [incorrect_key] is a valid key for the bucket of incorrect options;
        * - [permutation_key] is a permutation of all indices between 0 and
        *   getTotalSelectionSize() - 1 delimited by the
        *   OPENTESTING_DELIMITER_BUCKET_KEY (".") character.
        *
        * For example, if the buckets contain 1 correct and 2 incorrect options and
        * each bucket has a selection size of 1, then the unit supports exactly the
        * following keys:
        * - "0+0!0.1" (selects the first correct and incorrect options and leaves
        *   them in this order without performing any permutation)
        * - "0+0!1.0" (selects the first correct and incorrect options and switches
        *   their position by applying one permutation)
        * - "0+1!0.1" (selects the first correct and second incorrect options and
        *   leaves them in this order without performing any permutation)
        * - "0+1!1.0" (selects the first correct and second incorrect options and
        *   switches their position by applying one permutation)
        */
        KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the unit. */
        size_t getNumKeys() const override;

        /**
        * Selects correct and incorrect options from the corresponding buckets and
        * generates an OptionSelectionUnit::Processor that adds these options to
        * multiple choice questions.
        *
        * The key must respect the format defined in the documentation of the
        * getKeys() method. If it does not, this method is likely to throw an
        * exception.
        * @param[in] key The key to use for picking the correct and incorrect
        *   options and shuffling them. If any of the unit's buckets is empty or
        *   does not contain enough options to choose from, the key must be equal to
        *   the null key OPENTESTING_NULL_KEY ("N"), in which case the unit will
        *   generate an InactiveProcessor that does not perform any operation.
        *   Otherwise, it must be a string respecting the format defined in the
        *   documentation of the getKeys() method, in which case the unit will
        *   return an appropriate OptionSelectionUnit::Processor for these options.
        */
        std::unique_ptr<Pipeline<MultipleChoiceQuestion>::Processor> generate(const std::string& key) const override;

        /**
        * Returns the title that the unit will give to the generated
        * MultipleChoiceQuestion::OptionGroup.
        */
        const std::string& getTitle() const;

        /**
        * Returns the correct selection size, i.e. the number of correct options to
        * select on each generation.
        */
        size_t getCorrectSelectionSize() const;

        /**
        * Returns the incorrect selection size, i.e. the number of incorrect options
        * to select on each generation.
        */
        size_t getIncorrectSelectionSize() const;

        /**
        * Returns the total selection size, i.e. the total number of options to
        * select (both correct and incorrect) on each generation.
        */
        size_t getTotalSelectionSize() const;

        /**
        * Sets the title that the unit will give to the generated
        * MultipleChoiceQuestion::OptionGroup.
        * @param[in] title The title to give to the
        *   MultipleChoiceQuestion::OptionGroup.
        */
        void setTitle(const std::string& title);

        /**
        * Adds the given option to the Bucket of correct options.
        * @param[in] option The option to add as a correct option.
        */
        void appendCorrectOption(const std::string& option);

        /**
        * Adds the given option to the Bucket of incorrect options.
        * @param[in] option The option to add as an incorrect option.
        */
        void appendIncorrectOption(const std::string& option);

        /**
        * Removes an option from the Bucket of correct options. If the option given
        * in argument is not currently in the bucket, an invalid argument exception
        * is thrown.
        * @param[in] option The option to remove.
        */
        void removeCorrectOption(const std::string& option);

        /**
        * Removes an option from the Bucket of incorrect options. If the option
        * given in argument is not currently in the bucket, an invalid argument
        * exception is thrown.
        * @param[in] option The option to remove.
        */
        void removeIncorrectOption(const std::string& option);

        /** Removes all correct options from the unit */
        void clearCorrectOptions();

        /** Removes all incorrect options from the unit */
        void clearIncorrectOptions();

        /**
        * Defines the correct selection size, i.e. the number of correct options to
        * select on each generation.
        *
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of options contained in the bucket of correct options.
        * Otherwise, the unit will only generate InactiveProcessor objects that will
        * have no effect on the questions they receive.
        * @param[in] selectionSize The number of correct options to select on each
        *   generation. It must be at least 1.
        */
        void setCorrectSelectionSize(size_t selectionSize);

        /**
        * Defines the incorrect selection size, i.e. the number of incorrect options
        * to select on each generation.
        *
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of options contained in the bucket of incorrect options.
        * Otherwise, the unit will only generate InactiveProcessor objects that will
        * have no effect on the questions they receive.
        * @param[in] selectionSize The number of incorrect options to select on each
        *   generation. It must be at least 1.
        */
        void setIncorrectSelectionSize(size_t selectionSize);

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    protected:

        /**
        * Regenerates the keys based on the objects contained in the unit's buckets.
        */
        void updateKeys();

    private:

        /** The title for the MultipleChoiceQuestion::OptionGroup */
        std::string m_title;

        /** The Bucket containing all possible correct options. */
        Bucket<std::string> m_correctOptions;

        /** The Bucket containing all possible incorrect options. */
        Bucket<std::string> m_incorrectOptions;

        /** The keys supported by the unit in its current state. */
        KeyContainerType m_keys;
    };

    /**
    * \class BlankUnit BlankUnit.h
    * A Factory::Unit that adds a blank to the prompt of a MultipleChoiceQuestion
    * and selects the options to present to the examinee for completing the blank.
    *
    * Internally, the unit is just a combination of a TokenReplacementUnit and an
    * OptionSelectionUnit. The TokenReplacementUnit adds the blank to the prompt
    * using its token replacement mechanism while the OptionSelectionUnit selects
    * the options for filling it and groups them into a
    * MultipleChoiceQuestion::OptionGroup.
    *
    * The unit relies on three parameters: a blank identifier, a boolean flag for
    * toggling the display of the blank identifier, and a blank symbol. Each of
    * these parameters can be changed at runtime. The blank identifier is a string
    * that should uniquely identify the blank within a question (e.g. a number or a
    * letter) and that the examinee can use to map a blank to its corresponding
    * options when there are multiple blanks in the same question. The flag is a
    * boolean indicating whether the blank identifier should be shown or hidden from
    * the examinee, for example if not necessary because there is only one blank in
    * the question or there is no ambiguity regarding the correspondence between
    * blanks and options. The blank symbol is a string that acts as a placeholder
    * for the missing word or expression in the prompt (e.g. "_________").
    *
    * These three parameters define how the blank will appear in the prompt and how
    * it will be referred to in the MultipleChoiceQuestion::OptionGroup. If the flag
    * is set to true (i.e. show the identifier), the blank is added to the prompt as
    * a string of the form "([identifier])[symbol]" and the title of the
    * MultipleChoiceQuestion::OptionGroup is set to "Blank ([identifier])" where
    * [identifier] is the blank identifier and [symbol] is the blank symbol. If the
    * flag is set to false, the identifier will be hidden so the blank will be shown
    * as "[symbol]" and the title of the MultipleChoiceQuestion::OptionGroup will
    * just be "Blank".
    *
    * For example, if the identifier is "i", the symbol is "_________", and the flag
    * is set to true, then the blank will be shown as "(i)_________" in the prompt
    * and the title of the MultipleChoiceQuestion::OptionGroup will be "Blank (i)".
    * If the flag is set to false, then the blank will be shown as "_________" and
    * the title of the MultipleChoiceQuestion::OptionGroup will be "Blank".
    */
    class BlankUnit :
        public Factory<MultipleChoiceQuestion>::Unit
    {
    public:

        /**
        * \class Processor BlankUnit.h
        * A Pipeline::Processor object that replaces tokens with a blank in a
        * question's prompt and adds options to the question for completing the
        * blank.
        *
        * The processor just chains a TokenReplacementUnit::Processor with an
        * OptionSelectionUnit::Processor which are both generated by the BlankUnit's
        * internal units.
        */
        class Processor :
            public Pipeline<MultipleChoiceQuestion>::Processor
        {
        public:

            /**
            * Creates a Processor that will replace any occurrence of the given
            * tokens with a blank in the question's prompt and add the given options
            * and correct answers to the question.
            * @param[in] promptProcessor The processor to call for replacing the
            *   tokens with the blank.
            * @param[in] optionProcessor The processor to call for adding options
            *   and correct answers to the question.
            */
            Processor(const TokenReplacementUnit::Processor& promptProcessor, const OptionSelectionUnit::Processor& optionProcessor);

            /**
            * Replaces any occurrence of the supported tokens with a blank inside
            * the question's prompt and adds the selected options to the question.
            * @param[out] question The multiple choice question to add the blank and
            *   options to.
            */
            void process(MultipleChoiceQuestion& question) const override;

        private:

            /**
            * The internal processor in charge of adding the blank to the prompt.
            */
            TokenReplacementUnit::Processor m_promptProcessor;

            /**
            * The internal processor in charge of adding options to a question for
            * completing the blank.
            */
            OptionSelectionUnit::Processor m_optionProcessor;
        };

        /**
        * Creates an empty BlankUnit with an empty identifier, a boolean flag for
        * showing the identifier set to false, and a blank symbol set to
        * OpenTesting's default blank symbol.
        */
        BlankUnit();

        /**
        * Creates a BlankUnit with the given blank identifier, a boolean flag for
        * showing the identifier set to true, and a blank symbol set to
        * OpenTesting's default blank symbol.
        * @param[in] identifier The identifier to use for the blank.
        */
        BlankUnit(const std::string& identifier);

        /**
        * Returns the set of keys supported by the unit, which is exactly the same
        * set of keys as that supported by the internal OptionSelectionUnit. See the
        * documentation of the OptionSelectionUnit::getKeys() method for more
        * information on the supported format and values.
        */
        KeyContainerType getKeys() const override;

        /** Returns the number of keys supported by the unit. */
        size_t getNumKeys() const override;

        /**
        * Generates a BlankUnit::Processor that can add a blank to a multiple choice
        * question.
        *
        * The key must either be the null key or a valid key for the internal
        * OptionSelectionUnit. If the key is the null key, this method will simply
        * generate an InactiveProcessor. Otherwise, the key will be directly passed
        * to the internal OptionSelectionUnit to select correct and incorrect
        * options. In this case, the key must respect the format defined in the
        * documentation of the OptionSelectionUnit::getKeys() method. If it does
        * not, this method will likely throw an exception.
        * @param[in] key The key to pass to the OptionSelectionUnit. It must either
        *   be the null key or respect the format defined in the documentation of
        *   the OptionSelectionUnit::getKeys() method.
        */
        std::unique_ptr<Pipeline<MultipleChoiceQuestion>::Processor> generate(const std::string& key) const override;

        /** Returns the blank identifier. */
        const std::string& getBlankIdentifier() const;

        /**
        * Returns the boolean flag indicating whether the blank identifier should be
        * shown (true) or hidden (false) from the examinee.
        */
        bool shouldShowBlankIdentifier() const;

        /** Returns the blank symbol. */
        const std::string& getBlankSymbol() const;

        /**
        * Returns the internal TokenReplacementUnit holding the tokens to replace
        * with the blank symbol.
        */
        const TokenReplacementUnit& getTokenReplacementUnit();

        /**
        * Returns the internal OptionSelectionUnit holding the options to choose
        * from.
        */
        const OptionSelectionUnit& getOptionSelectionUnit();

        /**
        * Sets the blank identifier.
        * @param[in] identifier The blank identifier to use.
        */
        void setBlankIdentifier(const std::string& identifier);

        /**
        * Requests that the blank identifier be shown to the examinee in both the
        * prompt and MultipleChoiceQuestion::OptionGroup title.
        *
        * This method essentially toggles the unit's internal boolean flag for
        * showing the identifier to true.
        */
        void showBlankIdentifer();

        /**
        * Requests that the blank identifier be hidden from the examinee in both the
        * prompt and MultipleChoiceQuestion::OptionGroup title.
        *
        * This method essentially toggles the unit's internal boolean flag for
        * showing the identifier to false.
        */
        void hideBlankIdentifer();

        /**
        * Sets the blank symbol that signals that a word or expression is missing
        * from a prompt.
        * @param[in] symbol The blank symbol to use.
        */
        void setBlankSymbol(const std::string& symbol);

        /**
        * Adds a token to be replaced by a blank.
        * @param[in] token The token to add.
        */
        void addToken(const std::string& token);

        /**
        * Removes a token from the internal TokenReplacementUnit so it is no longer
        * replaced with a blank. If the token given in argument is not currently
        * supported by the unit, an invalid argument exception is thrown.
        * @param[in] token The token to remove.
        */
        void removeToken(const std::string& token);

        /**
        * Removes all tokens from the unit.
        */
        void clearTokens();

        /**
        * Adds the given option to the Bucket of correct options in the internal
        * OptionSelectionUnit.
        * @param[in] option The option to add as a correct option.
        */
        void appendCorrectOption(const std::string& option);

        /**
        * Adds the given option to the Bucket of incorrect options in the internal
        * OptionSelectionUnit.
        * @param[in] option The option to add as an incorrect option.
        */
        void appendIncorrectOption(const std::string& option);

        /**
        * Removes an option from the Bucket of correct options in the internal
        * OptionSelectionUnit. If the option given in argument is not currently in
        * the bucket, an invalid argument exception is thrown.
        * @param[in] option The option to remove.
        */
        void removeCorrectOption(const std::string& option);

        /**
        * Removes an option from the Bucket of incorrect options in the internal
        * OptionSelectionUnit. If the option given in argument is not currently in
        * the bucket, an invalid argument exception is thrown.
        * @param[in] option The option to remove.
        */
        void removeIncorrectOption(const std::string& option);

        /** Removes all correct options from the internal OptionSelectionUnit */
        void clearCorrectOptions();

        /** Removes all incorrect options from the internal OptionSelectionUnit */
        void clearIncorrectOptions();

        /**
        * Defines the correct selection size, i.e. the number of correct options to
        * select on each generation.
        *
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of options contained in the bucket of correct options in the
        * internal OptionSelectionUnit. Otherwise, the unit will only generate
        * InactiveProcessor objects that will have no effect on the questions they
        * receive.
        * @param[in] selectionSize The number of correct options to select on each
        *   generation. It must be at least 1.
        */
        void setCorrectSelectionSize(size_t selectionSize);

        /**
        * Defines the incorrect selection size, i.e. the number of incorrect options
        * to select on each generation.
        *
        * The selection size given in argument must be at least 1. Otherwise, an
        * invalid argument exception is thrown. It should also be at most equal to
        * the number of options contained in the bucket of incorrect options in the
        * internal OptionSelectionUnit. Otherwise, the unit will only generate
        * InactiveProcessor objects that will have no effect on the questions they
        * receive.
        * @param[in] selectionSize The number of incorrect options to select on each
        *   generation. It must be at least 1.
        */
        void setIncorrectSelectionSize(size_t selectionSize);

        /**
        * Serializes the unit with the given Writer.
        * @param[out] writer The writer to use to serialize the unit.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the unit with the given Reader.
        * @param[in] reader The reader to use to deserialize the unit.
        */
        void deserialize(const Reader& reader) override;

    protected:

        /**
        * Updates the unit's internal TokenReplacementUnit and OptionSelectionUnit
        * according to the unit's current state.
        *
        * This method regenerates the TokenReplacementUnit's replacement string and
        * the OptionSelectionUnit's MultipleChoiceQuestion::OptionGroup title.
        */
        void updateUnits();

    private:

        /** The blank identifier */
        std::string m_blankIdentifier;

        /**
        * The boolean flag indicating whether the blank identifier should be shown
        * (true) or hidden (false) from the examinee.
        */
        bool m_showBlankIdentifier;

        /** The blank symbol */
        std::string m_blankSymbol;

        /**
        * The internal unit containing the tokens and the string to replace them
        * with. The unit contains exactly one single replacement string at all time.
        */
        TokenReplacementUnit m_tokenReplacementUnit;

        /**
        * The internal unit in charge of selecting the options for completing the
        * blank.
        */
        OptionSelectionUnit m_optionSelectionUnit;
    };



    /*
    =================================================
    Question Generators
    =================================================
    */

    /**
    * \class GenericQuestionGenerator GenericQuestionGenerator.h
    * An object that generates a Question and returns a pointer to it, in the form
    * of a pointer to the most generic Question type, hence the name.
    */
    class GenericQuestionGenerator :
        public Generator<std::unique_ptr<Question>>
    {
    public:

        /**
        * Generates a Question and then casts it to the desired type. If the
        * Question generated could not be converted to the desired type, then this
        * method will return a null pointer.
        *
        * Note that casting is not compatible with exclusive ownership, so this
        * method returns a shared pointer instead of a unique pointer.
        * @param[in] key The key to use to generate the Question.
        */
        template<class QuestionType>
        std::shared_ptr<QuestionType> generateAndCast(const std::string& key) const;
    };

    template<class QuestionType>
    inline std::shared_ptr<QuestionType> GenericQuestionGenerator::generateAndCast(const std::string& key) const
    {
        /* We generate the question */
        std::unique_ptr<Question> question = generate(key);

        /* We turn the unique pointer into a shared pointer for dynamic casting */
        std::shared_ptr<Question> questionToCast = std::move(question);

        /* And finally we return the result of the casting operation */
        return std::dynamic_pointer_cast<QuestionType>(questionToCast);
    }

    /**
    * \class QuestionGenerator QuestionGenerator.h
    * A GenericQuestionGenerator specialized in generating a particular type of
    * Question.
    */
    template<class QuestionType>
    class QuestionGenerator :
        public GenericQuestionGenerator,
        public Serializable
    {
    public:

        /** A shorthand for the type of Factory used in the QuestionGenerator */
        typedef KeyDelimitedFactory<QuestionType> Factory;

        /**
        * \struct Table QuestionGenerator.h
        * A vector of factories for a QuestionGenerator to choose from for
        * generating a question. The QuestionGenerator will only pick one factory
        * per Table.
        */
        struct Table :
            public Serializable
        {
            /** The factories contained in the Table */
            std::vector<Factory> factories;

            /**
            * Returns the factories contained in the Table as a const reference. To
            * get a non-const reference, use the public member variable
            * Table::factories directly instead.
            *
            * Since the returned vector is a const reference, it does not allow
            * factories to be directly modified through it, i.e. no factory can be
            * added or removed and no unit can be added to or removed from any
            * factory using it. However, existing units inside the current factories
            * can still be accessed and modified through it.
            */
            const std::vector<Factory>& getFactories() const;

            /** Returns the number of factories contained in the Table. */
            size_t getNumFactories() const;

            /**
            * Creates a new, empty factory, inserts it at the end of the Table, and
            * returns a reference to it.
            *
            * Note that since the factory is added at the end, its index within the
            * Table will be equal to getNumFactories() - 1.
            */
            Factory& appendNewFactory();

            /**
            * Removes and destroys all factories and their content from the Table.
            */
            void clear();

            /**
            * Serializes the Table with the given Writer.
            * @param[out] writer The writer to use to serialize the Table.
            */
            void serialize(Writer& writer) const override;

            /**
            * Deserializes the Table with the given Reader.
            * @param[in] reader The reader to use to deserialize the Table.
            */
            void deserialize(const Reader& reader) override;
        };

        /**
        * Returns all the keys supported by the QuestionGenerator. The keys are
        * obtained by computing the Cartesian product of all possible factory keys
        * and then concatenating each Factory's identifier with each of its keys
        * with a character delimiter.
        *
        * Note that, as a result, if any factory in the QuestionGenerator has a unit
        * that does not support any key, then the whole factory will not either, and
        * so the factory will be ignored and skipped when generating the keys.
        */
        typename QuestionGenerator<QuestionType>::KeyContainerType getKeys() const override;

        /**
        * Returns the number of keys supported by the QuestionGenerator. This number
        * is obtained by first summing for each Table the number of keys supported
        * by its factories, and then multiplying these numbers together.
        *
        * Note that, as a result, if any factory in the QuestionGenerator has a unit
        * that does not support any key, then the whole factory will not either, and
        * so the factory will be ignored and not accounted for in the total number
        * of keys.
        */
        size_t getNumKeys() const;

        /**
        * Generates a Question based on the given key and returns a pointer to it.
        *
        * To generate a Question, the QuestionGenerator will first initialize a
        * Question object of the appropriate type using the initializeQuestion()
        * method, then pick one single factory per Table based on the given key, and
        * use these factories to generate pipelines that will process and complete
        * the Question object.
        *
        * The returned pointer points to a Question of type Question, but the object
        * itself is an instance of the template type QuestionType. It can be casted
        * to the appropriate type later, or with the generateAndCast() method
        * directly. Note that casting requires to turn the pointer into a shared
        * pointer, since the casting operation does not support ownership
        * exclusivity.
        * @param[in] key The key to use for generating the Question.
        */
        std::unique_ptr<Question> generate(const std::string& key) const override;

        /**
        * Returns the tables contained in the QuestionGenerator as a const
        * reference. To get a non-const reference, use the public member variable
        * QuestionGenerator::tables directly instead.
        *
        * Since the returned vector is a const reference, it does not allow tables
        * to be directly modified through it, i.e. no table can be added or removed
        * and no factory can be added to or removed from any table using it.
        * However, existing units inside existing factories can still be accessed
        * and modified through it.
        */
        const std::vector<Table>& getTables() const;

        /** Returns the number of tables contained in the QuestionGenerator. */
        size_t getNumTables() const;

        /**
        * Creates a new, empty Table, inserts it at the end of the
        * QuestionGenerator's Table vector, and returns a reference to it.
        *
        * Note that since the Table is added at the end, its index within the
        * QuestionGenerator will be equal to getNumTables() - 1.
        */
        Table& appendNewTable();

        /**
        * Removes and destroys all tables and their content from the
        * QuestionGenerator.
        */
        void clear();

        /**
        * Serializes the QuestionGenerator with the given Writer.
        * @param[out] writer The writer to use to serialize the QuestionGenerator.
        */
        void serialize(Writer& writer) const override;

        /**
        * Deserializes the QuestionGenerator with the given Reader.
        * @param[in] reader The reader to use to deserialize the QuestionGenerator.
        */
        void deserialize(const Reader& reader) override;

        /** The factory tables to pick from when generating the Question */
        std::vector<Table> tables;

    protected:

        /**
        * Initializes a Question object of the appropriate type.
        *
        * This method is the first method called for generating a Question. The
        * returned object is then passed to a series of pipelines that modifies it,
        * one step at a time.
        *
        * This method is virtual so it can be overriden in derived classes. By
        * default, it just calls the default constructor of the appropriate Question
        * class.
        */
        virtual std::unique_ptr<QuestionType> initializeQuestion() const;
    };

    template<class QuestionType>
    inline const std::vector<typename QuestionGenerator<QuestionType>::Factory>& QuestionGenerator<QuestionType>::Table::getFactories() const
    {
        return factories;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::Table::getNumFactories() const
    {
        return factories.size();
    }

    template<class QuestionType>
    inline typename QuestionGenerator<QuestionType>::Factory& QuestionGenerator<QuestionType>::Table::appendNewFactory()
    {
        factories.push_back({});
        return factories.back();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::Table::clear()
    {
        factories.clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::Table::serialize(Writer& writer) const
    {
        writer.write("type", std::string("Table"));
        writer.write("factories", factories);
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::Table::deserialize(const Reader& reader)
    {
        factories = reader.read<std::vector<Factory>>("factories");
    }

    template<class QuestionType>
    inline typename QuestionGenerator<QuestionType>::KeyContainerType QuestionGenerator<QuestionType>::getKeys() const
    {
        std::vector<typename QuestionGenerator<QuestionType>::KeyContainerType> keysPerTable;
        for (const auto& table : tables)
        {
            /*
            * We retrieve the keys of each factory and add the factory's index at
            * the beginning of each key as a factory identifier
            */
            typename QuestionGenerator<QuestionType>::KeyContainerType tableKeys;
            for (int f = 0; f < table.getNumFactories(); f++)
                for (const auto& key : table.factories[f].getKeys())
                    tableKeys.insert(tableKeys.end(), String::join({ std::to_string(f), key }, OPENTESTING_DELIMITER_FACTORY_KEY));

            keysPerTable.push_back(tableKeys);
        }

        /* We enumerate all possible combinations of table keys */
        std::vector<std::vector<std::string>> combinations = Enumerator::cartesianProduct<typename QuestionGenerator<QuestionType>::KeyContainerType, std::vector<std::string>>(keysPerTable);

        /* We then create the keys by joining the combinations */
        typename QuestionGenerator<QuestionType>::KeyContainerType keys;
        for (const auto& combination : combinations)
            keys.insert(keys.end(), String::join(combination, OPENTESTING_DELIMITER_TABLE_KEY));

        /* We return the result */
        return keys;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::getNumKeys() const
    {
        /* If the generator has no tables, we return 0 */
        if (tables.empty())
            return 0;

        /*
        * Otherwise, we multiply together the number of keys supported by each
        * table, which can be obtained by summing the number of keys supported by
        * each factory in the table.
        */
        size_t numKeys = 1;
        for (const auto& table : tables)
        {
            size_t numKeysPerTable = 0;
            for (const auto& factory : table.factories)
                numKeysPerTable += factory.getNumKeys();
            numKeys *= numKeysPerTable;
        }
        return numKeys;
    }

    template<class QuestionType>
    inline std::unique_ptr<Question> QuestionGenerator<QuestionType>::generate(const std::string& key) const
    {
        /* We start by initializing a question of the appropriate type */
        std::unique_ptr<QuestionType> question = initializeQuestion();

        /* We then split the key into table keys */
        std::vector<std::string> tableKeys = String::split(key, OPENTESTING_DELIMITER_TABLE_KEY);

        for (int t = 0; t < tableKeys.size(); t++)
        {
            /* We first separate the factory's identifier from its key */
            std::vector<std::string> parts = OT::String::split(tableKeys[t], OPENTESTING_DELIMITER_FACTORY_KEY);
            int factoryID = std::stoi(parts[0]);
            std::string factoryKey = parts[1];

            /* We then generate a pipeline... */
            const Pipeline<QuestionType> pipeline = tables[t].factories[factoryID].generate(factoryKey);

            /* ... And then use it to process the question */
            pipeline.process(*question);
        }

        /* Once the question has been processed by all factories, we return it */
        return question;
    }

    template<class QuestionType>
    inline const std::vector<typename QuestionGenerator<QuestionType>::Table>& QuestionGenerator<QuestionType>::getTables() const
    {
        return tables;
    }

    template<class QuestionType>
    inline size_t QuestionGenerator<QuestionType>::getNumTables() const
    {
        return tables.size();
    }

    template<class QuestionType>
    inline typename QuestionGenerator<QuestionType>::Table& QuestionGenerator<QuestionType>::appendNewTable()
    {
        tables.push_back({});
        return tables.back();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::clear()
    {
        tables.clear();
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::serialize(Writer& writer) const
    {
        writer.write("type", std::string("QuestionGenerator"));
        writer.write("tables", tables);
    }

    template<class QuestionType>
    inline void QuestionGenerator<QuestionType>::deserialize(const Reader& reader)
    {
        tables = reader.read<std::vector<Table>>("tables");
    }

    template<class QuestionType>
    inline std::unique_ptr<QuestionType> QuestionGenerator<QuestionType>::initializeQuestion() const
    {
        return std::make_unique<QuestionType>();
    }
}