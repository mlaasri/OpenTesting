/***********************************************************************
**
** This file is part of OpenTesting, an open-source framework for
** designing standardized tests and informal quizzes.
**
** OpenTesting is free software: you can redistribute it and / or
** modify it under the terms of the GNU General Public License as
** published by the Free Software Foundation, either version 3 of the
** License, or (at your option) any later version.
**
** OpenTesting is distributed in the hope that it will be useful, but
** WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
** General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with OpenTesting. If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2023, mlaasri
**
***********************************************************************/

#pragma once

#include <string>
#include <vector>

namespace OT
{
    /*
    =================================================
    Generator
    =================================================
    */

    /**
    * \class Generator Generator.h
    * An object that can generate another object based on a key provided as a
    * string.
    */
    template<class T>
    class Generator
    {
    public:

        /**
        * Returns the list of keys that are supported by the generator.
        */
        virtual std::vector<std::string> getKeys() const = 0;

        /**
        * Returns the number of keys supported by this generator.
        *
        * By default, this method generates all possible keys and counts them. If
        * there exists a faster way to compute this result, the method can be
        * overriden in derived classes to use a faster implementation (it is
        * virtual for that purpose).
        */
        virtual size_t getNumKeys() const;

        /**
        * Returns true if the key given in argument is a valid key for this
        * generator and false otherwise.
        *
        * By default, this method generates all possible keys and checks if the
        * given key appears in the list. If there exists a faster way to compute
        * this result, the method can be overriden in derived classes to use a
        * faster implementation (it is virtual for that purpose).
        * @param[in] key The key to check the validity of.
        */
        virtual bool isValidKey(const std::string& key) const;

        /**
        * Generates an object based on the given key. This method must be
        * implemented in derived classes, with the constraint that the same key must
        * generate the same object.
        * @param[in] key The key to use to generate the object. The key must be
        *   valid (see the getKeys() method for a list of valid keys).
        */
        virtual T generate(const std::string& key) const = 0;

        /**
        * Retrieves all possible keys for this generator and uses the one at the
        * given index to generate a new object.
        * @param[in] keyIndex The index of the key to use for the generation. It
        *   must be non-negative and less than the number of valid keys as
        *   returned by the getKeys() method.
        */
        virtual T generateFromIndex(int keyIndex) const;
    };

    template<class T>
    inline size_t Generator<T>::getNumKeys() const
    {
        return getKeys().size();
    }

    template<class T>
    inline bool Generator<T>::isValidKey(const std::string& key) const
    {
        std::vector<std::string> validKeys = getKeys();
        return std::find(validKeys.cbegin(), validKeys.cend(), key) != validKeys.cend();
    }

    template<class T>
    inline T Generator<T>::generateFromIndex(int keyIndex) const
    {
        return generate(getKeys()[keyIndex]);
    }



    /*
    =================================================
    Bucket
    =================================================
    */

    /**
    * \class Bucket Bucket.h
    * A bucket of words or expressions to pick from.
    */
    class Bucket : public Generator<std::string>
    {
    public:

        /**
        * Creates a bucket from a list of words.
        */
        Bucket(std::vector<std::string> words = std::vector<std::string>());

        /**
        * Returns the words contained in the bucket.
        */
        std::vector<std::string> getWords() const;

        /**
        * Returns the list of keys that are supported by the generator.
        */
        std::vector<std::string> getKeys() const;

        /**
        * Returns the list of keys that are supported by the generator.
        */
        size_t getNumKeys() const override;

        /**
        * Returns the number of words in the bucket.
        */
        size_t getSize() const;

        /**
        * Picks a word from the bucket.
        * @param[in] key The key to use to pick the word. It must be an integer
        *   represented as a string, and the integer must be non-negative and less
        *   than the size of the bucket.
        */
        std::string generate(const std::string& key) const;

        /**
        * Adds a word to the bucket.
        * @param[in] word The word to add.
        */
        void add(const std::string& word);

        /**
        * Removes a word from the bucket.  If the word is not in the bucket, an
        * exception is thrown.
        * @param[in] word The word to remove.
        */
        void remove(const std::string& word);

        /**
        * Empties the bucket.
        */
        void clear();

    protected:

        void updateKeys();

    private:

        /**
        * The list of words or expressions contained in the bucket.
        */
        std::vector<std::string> m_words;

        /**
        * The keys corresponding to each word in the bucket.
        */
        std::vector<std::string> m_keys;
    };



    /*
    =================================================
    Question
    =================================================
    */

    /**
    * \struct Answer Answer.h
    * Represents the answer of an examinee to a Question as a vector of strings.
    *
    * For most questions, the exminee may just provide a single string as an answer,
    * so the vector will be of size 1. If the expected answer is more complex in
    * structure (for example, mapping some elements together or drawing something),
    * the answer can be encoded as a sequence of strings, and so the vector is
    * likely to have a size greater than 1.
    *
    * The Answer class implements a virtual method isEqualTo() that compares an
    * Answer with another one and which can be overriden in derived classes. This
    * method is important, as it is this method that is called to determine whether
    * an Answer is correct for a particular Question (it must be among the
    * Question's set of correct answers). By default, two answers are said to be
    * equal if they contain exactly the same string elements and in the same order.
    * Derived classes might change this behavior and adapt to other Answer
    * structures (e.g. when the order does not matter for the Answer to be correct).
    */
    struct Answer
    {

        /** The elements of the answer */
        std::vector<std::string> elements;

        /** Builds an Answer from an existing vector of elements */
        Answer(const std::vector<std::string>& elements);

        /** Build an Answer containing one single element */
        Answer(const std::string& element);

        /**
        * Returns true if the answer is equal to the one given in argument, and
        * false otherwise.
        * @param[in] other The Answer to make the comparison with.
        */
        virtual bool isEqualTo(const Answer& other) const;

        friend bool operator==(const Answer& answer1, const Answer& answer2);
    };

    /**
    * \struct Question Question.h
    * A Question ready to be asked to the examinee as part of a test or quizz.
    */
    struct Question
    {

        /** The Question's prompt represented as a string */
        std::string prompt;

        /** All answers accepted as correct */
        std::vector<Answer> correctAnswers;

        /** The explanation for why the correct answers are what they are */
        std::string explanation;

        /**
        * Returns true if the answer is given in argument is correct, and false
        * otherwise.
        * @param[in] answer The Answer to check.
        */
        bool checkAnswer(const Answer& answer) const;
    };
}